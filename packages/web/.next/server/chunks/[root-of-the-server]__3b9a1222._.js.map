{"version":3,"sources":["../../../../../node_modules/wasmcurves/src/utils.js","../../../../../node_modules/wasmcurves/src/build_int.js","../../../../../node_modules/wasmcurves/src/build_timesscalar.js","../../../../../node_modules/wasmcurves/src/build_batchinverse.js","../../../../../node_modules/wasmcurves/src/build_batchconvertion.js","../../../../../node_modules/wasmcurves/src/build_batchop.js","../../../../../node_modules/wasmcurves/src/bigint.js","../../../../../node_modules/wasmcurves/src/build_f1m.js","../../../../../node_modules/wasmcurves/src/build_f1.js","../../../../../node_modules/wasmcurves/src/build_f2m.js","../../../../../node_modules/wasmcurves/src/build_f3m.js","../../../../../node_modules/wasmcurves/src/build_timesscalarnaf.js","../../../../../node_modules/wasmcurves/src/build_multiexp.js","../../../../../node_modules/wasmcurves/src/build_curve_jacobian_a0.js","../../../../../node_modules/wasmcurves/src/build_fft.js","../../../../../node_modules/wasmcurves/src/build_pol.js","../../../../../node_modules/wasmcurves/src/build_qap.js","../../../../../node_modules/wasmcurves/src/build_applykey.js","../../../../../node_modules/wasmcurves/src/bn128/build_bn128.js","../../../../../node_modules/wasmcurves/src/bls12381/build_bls12381.js","../../../../../node_modules/wasmcurves/index.js","../../../../../node_modules/web-worker/cjs/node.js","../../../../../node_modules/ejs/lib/utils.js","turbopack:///[project]/node_modules/ejs/package.json","../../../../../node_modules/ejs/lib/ejs.js","../../../../../node_modules/snarkjs/src/r1cs_constraint_processor.js","../../../../../node_modules/ffjavascript/src/bn128.js","../../../../../node_modules/ffjavascript/src/threadman.js","../../../../../node_modules/fastfile/src/bigmemfile.js","../../../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/threadman.js","../../../../../packages/web/app/api/validate/route.ts","../../../../../node_modules/%40iden3/bigarray/src/bigarray.js","../../../../../node_modules/snarkjs/src/bigarray.js","../../../../../node_modules/snarkjs/src/zkey_export_solidityverifier.js","../../../../../node_modules/fastfile/src/memfile.js","../../../../../node_modules/snarkjs/src/zkey_constants.js","../../../../../node_modules/snarkjs/src/plonk_constants.js","../../../../../node_modules/ffjavascript/src/scalar.js","../../../../../node_modules/fastfile/src/osfile.js","../../../../../node_modules/ffjavascript/main.js","../../../../../node_modules/ffjavascript/src/random.js","../../../../../node_modules/ffjavascript/src/bigbuffer.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/scalar.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/main.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/bigbuffer.js","../../../../../node_modules/ffjavascript/src/engine_pairing.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_pairing.js","../../../../../node_modules/snarkjs/src/curves.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_multiexp.js","../../../../../node_modules/ffjavascript/src/engine_multiexp.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_applykey.js","../../../../../node_modules/ffjavascript/src/engine_batchconvert.js","../../../../../node_modules/ffjavascript/src/threadman_thread.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_batchconvert.js","../../../../../node_modules/ffjavascript/src/engine_applykey.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/threadman_thread.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/random.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/utils.js","../../../../../node_modules/ffjavascript/src/utils.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/fsqrt.js","../../../../../node_modules/snarkjs/src/zkey_export_json.js","../../../../../node_modules/ffjavascript/src/fsqrt.js","../../../../../node_modules/fastfile/src/fastfile.js","../../../../../node_modules/ffjavascript/src/curves.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/curves.js","../../../../../node_modules/%40iden3/binfileutils/src/binfileutils.js","../../../../../node_modules/r1csfile/src/r1csfile.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_field2.js","../../../../../node_modules/ffjavascript/src/engine_fft.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/engine_fft.js","../../../../../node_modules/ffjavascript/src/wasm_field2.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/bn128.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/bls12381.js","../../../../../node_modules/ffjavascript/src/chacha.js","../../../../../node_modules/ffjavascript/src/bls12381.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/chacha.js","../../../../../node_modules/ffjavascript/src/wasm_curve.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_curve.js","../../../../../node_modules/snarkjs/node_modules/%40noble/hashes/src/_u64.ts","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_field3.js","../../../../../node_modules/ffjavascript/src/wasm_field3.js","../../../../../node_modules/snarkjs/src/zkey_export_bellman.js","../../../../../node_modules/snarkjs/node_modules/%40noble/hashes/src/_md.ts","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/f1field.js","../../../../../node_modules/ffjavascript/src/wasm_field1.js","../../../../../node_modules/ffjavascript/src/f1field.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/wasm_field1.js","../../../../../node_modules/snarkjs/node_modules/%40noble/hashes/src/blake2.ts","../../../../../node_modules/next/src/build/templates/app-route.ts","../../../../../node_modules/snarkjs/node_modules/%40noble/hashes/src/utils.ts","../../../../../node_modules/snarkjs/node_modules/%40noble/hashes/src/_blake.ts","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/engine.js","../../../../../node_modules/ffjavascript/src/engine.js","../../../../../node_modules/snarkjs/node_modules/%40noble/hashes/src/sha3.ts","../../../../../node_modules/snarkjs/src/powersoftau_export_challenge.js","../../../../../node_modules/circom_runtime/js/utils.js","../../../../../node_modules/snarkjs/src/groth16_exportsoliditycalldata.js","../../../../../node_modules/snarkjs/src/mul_z.js","../../../../../node_modules/snarkjs/src/proof.js","../../../../../node_modules/wasmbuilder/src/utils.js","../../../../../node_modules/snarkjs/src/r1cs_print.js","../../../../../node_modules/snarkjs/src/fflonk_full_prove.js","../../../../../node_modules/snarkjs/src/fflonk_constants.js","../../../../../node_modules/snarkjs/src/plonk_exportsoliditycalldata.js","../../../../../node_modules/snarkjs/src/polynomial/polynomial.js","../../../../../node_modules/wasmbuilder/src/protoboard.js","../../../../../node_modules/wasmbuilder/src/codebuilder.js","../../../../../node_modules/wasmbuilder/src/codebuilder_wat.js","../../../../../node_modules/snarkjs/src/polynomial/evaluations.js","../../../../../node_modules/snarkjs/src/loadsyms.js","../../../../../node_modules/ffjavascript/src/f3field.js","../../../../../node_modules/snarkjs/src/wtns_export_json.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/f3field.js","../../../../../node_modules/snarkjs/src/Keccak256Transcript.js","../../../../../node_modules/snarkjs/src/groth16_fullprove.js","../../../../../node_modules/wasmbuilder/src/functionbuilder.js","../../../../../node_modules/snarkjs/src/fflonk_export_calldata.js","../../../../../node_modules/snarkjs/src/misc.js","../../../../../node_modules/snarkjs/src/r1cs_info.js","../../../../../node_modules/snarkjs/src/plonk_fullprove.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/futils.js","../../../../../node_modules/ffjavascript/src/futils.js","../../../../../node_modules/wasmbuilder/src/functionbuilder_wat.js","../../../../../node_modules/circom_runtime/js/witness_calculator.js","../../../../../node_modules/snarkjs/src/zkey_verify_fromr1cs.js","../../../../../node_modules/snarkjs/src/powersoftau_truncate.js","../../../../../node_modules/ffjavascript/src/f2field.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/f2field.js","../../../../../node_modules/snarkjs/src/groth16_verify.js","../../../../../node_modules/snarkjs/src/fflonk_export_solidity_verifier.js","../../../../../node_modules/snarkjs/src/keypair.js","../../../../../node_modules/wasmbuilder/src/modulebuilder_wat.js","../../../../../node_modules/wasmbuilder/src/modulebuilder.js","../../../../../node_modules/snarkjs/src/r1cs_export_json.js","../../../../../node_modules/snarkjs/src/powersoftau_preparephase2.js","../../../../../node_modules/snarkjs/src/powersoftau_export_json.js","../../../../../node_modules/snarkjs/src/wtns_calculate.js","../../../../../node_modules/snarkjs/src/wtns_utils.js","../../../../../node_modules/snarkjs/src/plonk_equation.js","../../../../../node_modules/snarkjs/src/powersoftau_convert.js","../../../../../node_modules/snarkjs/src/powersoftau_beacon.js","../../../../../node_modules/snarkjs/src/wtns_debug.js","../../../../../node_modules/snarkjs/src/plonk_prove.js","../../../../../node_modules/snarkjs/src/groth16_prove.js","../../../../../node_modules/snarkjs/src/zkey_verify_frominit.js","../../../../../node_modules/snarkjs/src/fflonk_verify.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/ec.js","../../../../../node_modules/ffjavascript/src/ec.js","../../../../../node_modules/snarkjs/src/zkey_export_verificationkey.js","../../../../../node_modules/snarkjs/src/powersoftau_verify.js","../../../../../node_modules/snarkjs/src/powersoftau_utils.js","../../../../../node_modules/snarkjs/src/powersoftau_import.js","../../../../../node_modules/snarkjs/src/zkey_import_bellman.js","../../../../../node_modules/snarkjs/src/wtns_check.js","../../../../../node_modules/snarkjs/src/plonk_verify.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/polfield.js","../../../../../node_modules/r1csfile/node_modules/ffjavascript/src/fft.js","../../../../../node_modules/ffjavascript/src/polfield.js","../../../../../node_modules/ffjavascript/src/fft.js","../../../../../node_modules/snarkjs/src/mpc_applykey.js","../../../../../node_modules/snarkjs/src/polynomial/cpolynomial.js","../../../../../node_modules/snarkjs/src/zkey_contribute.js","../../../../../node_modules/snarkjs/src/zkey_beacon.js","../../../../../node_modules/snarkjs/src/powersoftau_contribute.js","../../../../../node_modules/snarkjs/src/zkey_new.js","../../../../../node_modules/snarkjs/src/plonk_setup.js","../../../../../node_modules/snarkjs/src/powersoftau_challenge_contribute.js","../../../../../node_modules/snarkjs/src/zkey_bellman_contribute.js","../../../../../node_modules/snarkjs/src/fflonk_prove.js","../../../../../node_modules/snarkjs/src/zkey_utils.js","../../../../../node_modules/snarkjs/src/fflonk_setup.js","../../../../../node_modules/snarkjs/src/powersoftau_new.js"],"sourcesContent":["/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexports.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {\n    const b = Array(len);\n    let v = BigInt(_a);\n    for (let i=0; i<len; i++) {\n        b[i] = Number(v & 0xFFn);\n        v = v >> 8n;\n    }\n    return b;\n};\n\nexports.bigInt2U32LE = function bigInt2BytesLE(_a, len) {\n    const b = Array(len);\n    let v = BigInt(_a);\n    for (let i=0; i<len; i++) {\n        b[i] = Number(v & 0xFFFFFFFFn);\n        v = v >> 32n;\n    }\n    return b;\n};\n\nexports.isOcamNum = function(a) {\n    if (!Array.isArray(a)) return false;\n    if (a.length != 3) return false;\n    if (typeof a[0] !== \"number\") return false;\n    if (typeof a[1] !== \"number\") return false;\n    if (!Array.isArray(a[2])) return false;\n    return true;\n};\n\n\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildInt(module, n64, _prefix) {\n\n    const prefix = _prefix || \"int\";\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {};\n\n    const n32 = n64*2;\n    const n8 = n64*8;\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"px\"),\n                        i*8\n                    )\n                )\n            );\n        }\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_const(0)\n                )\n            );\n        }\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i64_store(\n                c.getLocal(\"pr\"),\n                0,\n                c.i64_const(1)\n            )\n        );\n        for (let i=1; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_const(0)\n                )\n            );\n        }\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"px\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_eqz(\n                    c.i64_load(c.getLocal(\"px\"))\n                ));\n            }\n            return c.if(\n                c.i64_eqz(\n                    c.i64_load(c.getLocal(\"px\"), n*8 )\n                ),\n                getCompCode(n-1),\n                c.ret(c.i32_const(0))\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"py\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_eq(\n                    c.i64_load(c.getLocal(\"px\")),\n                    c.i64_load(c.getLocal(\"py\"))\n                ));\n            }\n            return c.if(\n                c.i64_eq(\n                    c.i64_load(c.getLocal(\"px\"), n*8 ),\n                    c.i64_load(c.getLocal(\"py\"), n*8 )\n                ),\n                getCompCode(n-1),\n                c.ret(c.i32_const(0))\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n\n\n    function buildGte() {\n        const f = module.addFunction(prefix+\"_gte\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"py\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_ge_u(\n                    c.i64_load(c.getLocal(\"px\")),\n                    c.i64_load(c.getLocal(\"py\"))\n                ));\n            }\n            return c.if(\n                c.i64_lt_u(\n                    c.i64_load(c.getLocal(\"px\"), n*8 ),\n                    c.i64_load(c.getLocal(\"py\"), n*8 )\n                ),\n                c.ret(c.i32_const(0)),\n                c.if(\n                    c.i64_gt_u(\n                        c.i64_load(c.getLocal(\"px\"), n*8 ),\n                        c.i64_load(c.getLocal(\"py\"), n*8 )\n                    ),\n                    c.ret(c.i32_const(1)),\n                    getCompCode(n-1)\n                )\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n\n\n    function buildAdd() {\n\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_add(\n                c.i64_load32_u(c.getLocal(\"x\")),\n                c.i64_load32_u(c.getLocal(\"y\"))\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"r\"),\n            c.getLocal(\"c\"),\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_add(\n                        c.i64_load32_u(c.getLocal(\"x\"), 4*i),\n                        c.i64_load32_u(c.getLocal(\"y\"), 4*i)\n                    ),\n                    c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"r\"),\n                i*4,\n                c.getLocal(\"c\")\n            ));\n        }\n\n        f.addCode(c.i32_wrap_i64(c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))));\n    }\n\n\n    function buildSub() {\n\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_sub(\n                c.i64_load32_u(c.getLocal(\"x\")),\n                c.i64_load32_u(c.getLocal(\"y\"))\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"r\"),\n            c.i64_and(\n                c.getLocal(\"c\"),\n                c.i64_const(\"0xFFFFFFFF\")\n            )\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_sub(\n                        c.i64_load32_u(c.getLocal(\"x\"), 4*i),\n                        c.i64_load32_u(c.getLocal(\"y\"), 4*i)\n                    ),\n                    c.i64_shr_s (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"r\"),\n                i*4,\n                c.i64_and( c.getLocal(\"c\"), c.i64_const(\"0xFFFFFFFF\"))\n            ));\n        }\n\n        f.addCode(c.i32_wrap_i64 ( c.i64_shr_s (c.getLocal(\"c\"), c.i64_const(32))));\n    }\n\n\n    function buildMul() {\n\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"y\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const loadX = [];\n        const loadY = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadY[j]) {\n                Y = c.teeLocal(\"y\"+j, c.i64_load32_u( c.getLocal(\"y\"), j*4));\n                loadY[j] = true;\n            } else {\n                Y = c.getLocal(\"y\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            for (let i=Math.max(0, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.getLocal(\"r\"),\n                    k*4,\n                    c.getLocal(c0)\n                )\n            );\n            [c0, c1] = [c1, c0];\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_shr_u(\n                        c.getLocal(c0),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4*2-4,\n                c.getLocal(c0)\n            )\n        );\n\n    }\n\n\n\n    function buildSquare() {\n\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"c0_old\", \"i64\");\n        f.addLocal(\"c1_old\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const loadX = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadX[j]) {\n                Y = c.teeLocal(\"x\"+j, c.i64_load32_u( c.getLocal(\"x\"), j*4));\n                loadX[j] = true;\n            } else {\n                Y = c.getLocal(\"x\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n        let c0_old = \"c0_old\";\n        let c1_old = \"c1_old\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            f.addCode(\n                c.setLocal(c0, c.i64_const(0)),\n                c.setLocal(c1, c.i64_const(0)),\n            );\n\n            for (let i=Math.max(0, k-n32+1); (i<((k+1)>>1) )&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Multiply by 2\n            f.addCode(\n                c.setLocal(c0,\n                    c.i64_shl(\n                        c.i64_and(\n                            c.getLocal(c0),\n                            c.i64_const(0xFFFFFFFF)\n                        ),\n                        c.i64_const(1)\n                    )\n                )\n            );\n\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_add(\n                        c.i64_shl(\n                            c.getLocal(c1),\n                            c.i64_const(1)\n                        ),\n                        c.i64_shr_u(\n                            c.getLocal(c0),\n                            c.i64_const(32)\n                        )\n                    )\n                )\n            );\n\n            if (k%2 == 0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(k>>1, k>>1)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Add the old carry\n\n            if (k>0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            c.i64_and(\n                                c.getLocal(c0_old),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.i64_add(\n                                c.getLocal(c1),\n                                c.i64_shr_u(\n                                    c.getLocal(c0),\n                                    c.i64_const(32)\n                                )\n                            ),\n                            c.getLocal(c1_old)\n                        )\n                    )\n                );\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.getLocal(\"r\"),\n                    k*4,\n                    c.getLocal(c0)\n                )\n            );\n\n            f.addCode(\n                c.setLocal(\n                    c0_old,\n                    c.getLocal(c1)\n                ),\n                c.setLocal(\n                    c1_old,\n                    c.i64_shr_u(\n                        c.getLocal(c0_old),\n                        c.i64_const(32)\n                    )\n                )\n            );\n\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4*2-4,\n                c.getLocal(c0_old)\n            )\n        );\n\n    }\n\n\n    function buildSquareOld() {\n        const f = module.addFunction(prefix+\"_squareOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n    function _buildMul1() {\n        const f = module.addFunction(prefix+\"__mul1\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"y\", \"i64\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_mul(\n                c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                c.getLocal(\"y\")\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"pr\"),\n            0,\n            0,\n            c.getLocal(\"c\"),\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_mul(\n                        c.i64_load32_u(c.getLocal(\"px\"), 4*i, 0),\n                        c.getLocal(\"y\")\n                    ),\n                    c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"pr\"),\n                i*4,\n                0,\n                c.getLocal(\"c\")\n            ));\n        }\n    }\n\n    function _buildAdd1() {\n        const f = module.addFunction(prefix+\"__add1\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i64\");\n        f.addLocal(\"c\", \"i64\");\n        f.addLocal(\"px\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\"px\", c.getLocal(\"x\")));\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_add(\n                c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                c.getLocal(\"y\")\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"px\"),\n            0,\n            0,\n            c.getLocal(\"c\"),\n        ));\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_shr_u(\n                c.getLocal(\"c\"),\n                c.i64_const(32)\n            )\n        ));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i64_eqz(c.getLocal(\"c\"))\n            ),\n            c.setLocal(\n                \"px\",\n                c.i32_add(\n                    c.getLocal(\"px\"),\n                    c.i32_const(4)\n                )\n            ),\n\n            c.setLocal(\n                \"c\",\n                c.i64_add(\n                    c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                    c.getLocal(\"c\")\n                )\n            ),\n\n            c.i64_store32(\n                c.getLocal(\"px\"),\n                0,\n                0,\n                c.getLocal(\"c\"),\n            ),\n\n            c.setLocal(\n                \"c\",\n                c.i64_shr_u(\n                    c.getLocal(\"c\"),\n                    c.i64_const(32)\n                )\n            ),\n\n            c.br(0)\n        )));\n    }\n\n\n    function buildDiv() {\n        _buildMul1();\n        _buildAdd1();\n\n        const f = module.addFunction(prefix+\"_div\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"c\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"rr\", \"i32\");\n        f.addLocal(\"cc\", \"i32\");\n        f.addLocal(\"eX\", \"i32\");\n        f.addLocal(\"eY\", \"i32\");\n        f.addLocal(\"sy\", \"i64\");\n        f.addLocal(\"sx\", \"i64\");\n        f.addLocal(\"ec\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Y = c.i32_const(module.alloc(n8));\n        const Caux = c.i32_const(module.alloc(n8));\n        const Raux = c.i32_const(module.alloc(n8));\n        const C = c.getLocal(\"cc\");\n        const R = c.getLocal(\"rr\");\n        const pr1 = module.alloc(n8*2);\n        const R1 = c.i32_const(pr1);\n        const R2 = c.i32_const(pr1+n8);\n\n        // Ic c is 0 then store it in an auxiliary buffer\n        f.addCode(c.if(\n            c.getLocal(\"c\"),\n            c.setLocal(\"cc\", c.getLocal(\"c\")),\n            c.setLocal(\"cc\", Caux)\n        ));\n\n        // Ic r is 0 then store it in an auxiliary buffer\n        f.addCode(c.if(\n            c.getLocal(\"r\"),\n            c.setLocal(\"rr\", c.getLocal(\"r\")),\n            c.setLocal(\"rr\", Raux)\n        ));\n\n        // Copy\n        f.addCode(c.call(prefix + \"_copy\", c.getLocal(\"x\"), R));\n        f.addCode(c.call(prefix + \"_copy\", c.getLocal(\"y\"), Y));\n        f.addCode(c.call(prefix + \"_zero\", C));\n        f.addCode(c.call(prefix + \"_zero\", R1));\n\n\n        f.addCode(c.setLocal(\"eX\", c.i32_const(n8-1)));\n        f.addCode(c.setLocal(\"eY\", c.i32_const(n8-1)));\n\n        // while (eY>3)&&(Y[eY]==0) ey--;\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i32_or(\n                    c.i32_load8_u(\n                        c.i32_add(Y , c.getLocal(\"eY\")),\n                        0,\n                        0\n                    ),\n                    c.i32_eq(\n                        c.getLocal(\"eY\"),\n                        c.i32_const(3)\n                    )\n                )\n            ),\n            c.setLocal(\"eY\", c.i32_sub(c.getLocal(\"eY\"), c.i32_const(1))),\n            c.br(0)\n        )));\n\n        f.addCode(\n            c.setLocal(\n                \"sy\",\n                c.i64_add(\n                    c.i64_load32_u(\n                        c.i32_sub(\n                            c.i32_add( Y, c.getLocal(\"eY\")),\n                            c.i32_const(3)\n                        ),\n                        0,\n                        0\n                    ),\n                    c.i64_const(1)\n                )\n            )\n        );\n\n        // Force a divide by 0 if quotien is 0\n        f.addCode(\n            c.if(\n                c.i64_eq(\n                    c.getLocal(\"sy\"),\n                    c.i64_const(1)\n                ),\n                c.drop(c.i64_div_u(c.i64_const(0), c.i64_const(0)))\n            )\n        );\n\n        f.addCode(c.block(c.loop(\n\n            // while (eX>7)&&(Y[eX]==0) ex--;\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_or(\n                        c.i32_load8_u(\n                            c.i32_add(R , c.getLocal(\"eX\")),\n                            0,\n                            0\n                        ),\n                        c.i32_eq(\n                            c.getLocal(\"eX\"),\n                            c.i32_const(7)\n                        )\n                    )\n                ),\n                c.setLocal(\"eX\", c.i32_sub(c.getLocal(\"eX\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.setLocal(\n                \"sx\",\n                c.i64_load(\n                    c.i32_sub(\n                        c.i32_add( R, c.getLocal(\"eX\")),\n                        c.i32_const(7)\n                    ),\n                    0,\n                    0\n                )\n            ),\n\n            c.setLocal(\n                \"sx\",\n                c.i64_div_u(\n                    c.getLocal(\"sx\"),\n                    c.getLocal(\"sy\")\n                )\n            ),\n            c.setLocal(\n                \"ec\",\n                c.i32_sub(\n                    c.i32_sub(\n                        c.getLocal(\"eX\"),\n                        c.getLocal(\"eY\")\n                    ),\n                    c.i32_const(4)\n                )\n            ),\n\n            // While greater than 32 bits or ec is neg, shr and inc exp\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_and(\n                        c.i64_eqz(\n                            c.i64_and(\n                                c.getLocal(\"sx\"),\n                                c.i64_const(\"0xFFFFFFFF00000000\")\n                            )\n                        ),\n                        c.i32_ge_s(\n                            c.getLocal(\"ec\"),\n                            c.i32_const(0)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"sx\",\n                    c.i64_shr_u(\n                        c.getLocal(\"sx\"),\n                        c.i64_const(8)\n                    )\n                ),\n\n                c.setLocal(\n                    \"ec\",\n                    c.i32_add(\n                        c.getLocal(\"ec\"),\n                        c.i32_const(1)\n                    )\n                ),\n                c.br(0)\n            )),\n\n            c.if(\n                c.i64_eqz(c.getLocal(\"sx\")),\n                [\n                    ...c.br_if(\n                        2,\n                        c.i32_eqz(c.call(prefix + \"_gte\", R, Y))\n                    ),\n                    ...c.setLocal(\"sx\", c.i64_const(1)),\n                    ...c.setLocal(\"ec\", c.i32_const(0))\n                ]\n            ),\n\n            c.call(prefix + \"__mul1\", Y, c.getLocal(\"sx\"), R2),\n            c.drop(c.call(\n                prefix + \"_sub\",\n                R,\n                c.i32_sub(R2, c.getLocal(\"ec\")),\n                R\n            )),\n            c.call(\n                prefix + \"__add1\",\n                c.i32_add(C, c.getLocal(\"ec\")),\n                c.getLocal(\"sx\")\n            ),\n            c.br(0)\n        )));\n    }\n\n    function buildInverseMod() {\n\n        const f = module.addFunction(prefix+\"_inverseMod\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"pm\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"t\", \"i32\");\n        f.addLocal(\"newt\", \"i32\");\n        f.addLocal(\"r\", \"i32\");\n        f.addLocal(\"qq\", \"i32\");\n        f.addLocal(\"qr\", \"i32\");\n        f.addLocal(\"newr\", \"i32\");\n        f.addLocal(\"swp\", \"i32\");\n        f.addLocal(\"x\", \"i32\");\n        f.addLocal(\"signt\", \"i32\");\n        f.addLocal(\"signnewt\", \"i32\");\n        f.addLocal(\"signx\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux1 = c.i32_const(module.alloc(n8));\n        const aux2 = c.i32_const(module.alloc(n8));\n        const aux3 = c.i32_const(module.alloc(n8));\n        const aux4 = c.i32_const(module.alloc(n8));\n        const aux5 = c.i32_const(module.alloc(n8));\n        const aux6 = c.i32_const(module.alloc(n8));\n        const mulBuff = c.i32_const(module.alloc(n8*2));\n        const aux7 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"t\", aux1),\n            c.call(prefix + \"_zero\", aux1),\n            c.setLocal(\"signt\", c.i32_const(0)),\n        );\n\n        f.addCode(\n            c.setLocal(\"r\", aux2),\n            c.call(prefix + \"_copy\", c.getLocal(\"pm\"), aux2)\n        );\n\n        f.addCode(\n            c.setLocal(\"newt\", aux3),\n            c.call(prefix + \"_one\", aux3),\n            c.setLocal(\"signnewt\", c.i32_const(0)),\n        );\n\n        f.addCode(\n            c.setLocal(\"newr\", aux4),\n            c.call(prefix + \"_copy\", c.getLocal(\"px\"), aux4)\n        );\n\n\n\n\n        f.addCode(c.setLocal(\"qq\", aux5));\n        f.addCode(c.setLocal(\"qr\", aux6));\n        f.addCode(c.setLocal(\"x\", aux7));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.call(prefix + \"_isZero\", c.getLocal(\"newr\") )\n            ),\n            c.call(prefix + \"_div\", c.getLocal(\"r\"), c.getLocal(\"newr\"), c.getLocal(\"qq\"), c.getLocal(\"qr\")),\n\n            c.call(prefix + \"_mul\", c.getLocal(\"qq\"), c.getLocal(\"newt\"), mulBuff),\n\n            c.if(\n                c.getLocal(\"signt\"),\n                c.if(\n                    c.getLocal(\"signnewt\"),\n                    c.if (\n                        c.call(prefix + \"_gte\", mulBuff, c.getLocal(\"t\")),\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(0))\n                        ],\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", c.getLocal(\"t\"), mulBuff, c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(1))\n                        ],\n                    ),\n                    [\n                        ...c.drop(c.call(prefix + \"_add\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                        ...c.setLocal(\"signx\", c.i32_const(1))\n                    ]\n                ),\n                c.if(\n                    c.getLocal(\"signnewt\"),\n                    [\n                        ...c.drop(c.call(prefix + \"_add\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                        ...c.setLocal(\"signx\", c.i32_const(0))\n                    ],\n                    c.if (\n                        c.call(prefix + \"_gte\", c.getLocal(\"t\"), mulBuff),\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", c.getLocal(\"t\"), mulBuff, c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(0))\n                        ],\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(1))\n                        ]\n                    )\n                )\n            ),\n\n            c.setLocal(\"swp\", c.getLocal(\"t\")),\n            c.setLocal(\"t\", c.getLocal(\"newt\")),\n            c.setLocal(\"newt\", c.getLocal(\"x\")),\n            c.setLocal(\"x\", c.getLocal(\"swp\")),\n\n            c.setLocal(\"signt\", c.getLocal(\"signnewt\")),\n            c.setLocal(\"signnewt\", c.getLocal(\"signx\")),\n\n            c.setLocal(\"swp\", c.getLocal(\"r\")),\n            c.setLocal(\"r\", c.getLocal(\"newr\")),\n            c.setLocal(\"newr\", c.getLocal(\"qr\")),\n            c.setLocal(\"qr\", c.getLocal(\"swp\")),\n\n            c.br(0)\n        )));\n\n        f.addCode(c.if(\n            c.getLocal(\"signt\"),\n            c.drop(c.call(prefix + \"_sub\", c.getLocal(\"pm\"), c.getLocal(\"t\"), c.getLocal(\"pr\"))),\n            c.call(prefix + \"_copy\", c.getLocal(\"t\"), c.getLocal(\"pr\"))\n        ));\n    }\n\n\n    buildCopy();\n    buildZero();\n    buildIsZero();\n    buildOne();\n    buildEq();\n    buildGte();\n    buildAdd();\n    buildSub();\n    buildMul();\n    buildSquare();\n    buildSquareOld();\n    buildDiv();\n    buildInverseMod();\n    module.exportFunction(prefix+\"_copy\");\n    module.exportFunction(prefix+\"_zero\");\n    module.exportFunction(prefix+\"_one\");\n    module.exportFunction(prefix+\"_isZero\");\n    module.exportFunction(prefix+\"_eq\");\n    module.exportFunction(prefix+\"_gte\");\n    module.exportFunction(prefix+\"_add\");\n    module.exportFunction(prefix+\"_sub\");\n    module.exportFunction(prefix+\"_mul\");\n    module.exportFunction(prefix+\"_square\");\n    module.exportFunction(prefix+\"_squareOld\");\n    module.exportFunction(prefix+\"_div\");\n    module.exportFunction(prefix+\"_inverseMod\");\n\n    return prefix;\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildTimesScalar(module, fnName, elementLen, opAB, opAA, opCopy, opInit) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"base\", \"i32\");\n    f.addParam(\"scalar\", \"i32\");\n    f.addParam(\"scalarLength\", \"i32\");\n    f.addParam(\"r\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"b\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const aux = c.i32_const(module.alloc(elementLen));\n\n    f.addCode(\n        c.if(\n            c.i32_eqz(c.getLocal(\"scalarLength\")),\n            [\n                ...c.call(opInit, c.getLocal(\"r\")),\n                ...c.ret([])\n            ]\n        )\n    );\n    f.addCode(c.call(opCopy, c.getLocal(\"base\"), aux));\n    f.addCode(c.call(opInit, c.getLocal(\"r\")));\n    f.addCode(c.setLocal(\"i\", c.getLocal(\"scalarLength\")));\n    f.addCode(c.block(c.loop(\n        c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n\n        c.setLocal(\n            \"b\",\n            c.i32_load8_u(\n                c.i32_add(\n                    c.getLocal(\"scalar\"),\n                    c.getLocal(\"i\")\n                )\n            )\n        ),\n        ...innerLoop(),\n        c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n        c.br(0)\n    )));\n\n\n    function innerLoop() {\n        const code = [];\n        for (let i=0; i<8; i++) {\n            code.push(\n                ...c.call(opAA, c.getLocal(\"r\"), c.getLocal(\"r\")),\n                ...c.if(\n                    c.i32_ge_u( c.getLocal(\"b\"), c.i32_const(0x80 >> i)),\n                    [\n                        ...c.setLocal(\n                            \"b\",\n                            c.i32_sub(\n                                c.getLocal(\"b\"),\n                                c.i32_const(0x80 >> i)\n                            )\n                        ),\n                        ...c.call(opAB, c.getLocal(\"r\"),aux, c.getLocal(\"r\"))\n                    ]\n                )\n            );\n        }\n        return code;\n    }\n\n};\n","\nmodule.exports = buildBatchInverse;\n\nfunction buildBatchInverse(module, prefix) {\n\n\n    const n8 = module.modules[prefix].n64*8;\n\n    const f = module.addFunction(prefix+\"_batchInverse\");\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"inStep\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addParam(\"outStep\", \"i32\");\n    f.addLocal(\"itAux\", \"i32\");\n    f.addLocal(\"itIn\", \"i32\");\n    f.addLocal(\"itOut\",\"i32\");\n    f.addLocal(\"i\",\"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const AUX = c.i32_const(module.alloc(n8));\n\n\n    // Alloc Working space for accumulated umltiplications\n    f.addCode(\n        c.setLocal(\"itAux\", c.i32_load( c.i32_const(0) )),\n        c.i32_store(\n            c.i32_const(0),\n            c.i32_add(\n                c.getLocal(\"itAux\"),\n                c.i32_mul(\n                    c.i32_add(\n                        c.getLocal(\"n\"),\n                        c.i32_const(1)\n                    ),\n                    c.i32_const(n8)\n                )\n            )\n        )\n    );\n\n    f.addCode(\n\n        // aux[0] = a;\n        c.call(prefix+\"_one\", c.getLocal(\"itAux\")),\n        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]\n        c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n        c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n        c.setLocal(\"i\", c.i32_const(0)),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n            c.if(\n                c.call(prefix+\"_isZero\", c.getLocal(\"itIn\")),\n                c.call(\n                    prefix + \"_copy\",\n                    c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    c.getLocal(\"itAux\")\n                ),\n                c.call(\n                    prefix+\"_mul\",\n                    c.getLocal(\"itIn\"),\n                    c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    c.getLocal(\"itAux\")\n                )\n            ),\n            c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n            c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        )),\n\n        // point to the last\n        c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n        c.setLocal(\"itAux\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8))),\n        // itOut = pOut + (n-1)*stepOut   // Point to the last\n        c.setLocal(\n            \"itOut\",\n            c.i32_add(\n                c.getLocal(\"pOut\"),\n                c.i32_mul(\n                    c.i32_sub(c.getLocal(\"n\"), c.i32_const(1)),\n                    c.getLocal(\"outStep\"),\n                )\n            )\n        ),\n\n        // aux[n-1] = 1/aux[n-1]\n        c.call(prefix+\"_inverse\", c.getLocal(\"itAux\"), c.getLocal(\"itAux\") ),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eqz( c.getLocal(\"i\"))),\n            c.if(\n                c.call(prefix+\"_isZero\", c.getLocal(\"itIn\")),\n                [\n                    ...c.call(\n                        prefix + \"_copy\",\n                        c.getLocal(\"itAux\"),\n                        c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    ),\n                    ...c.call(\n                        prefix + \"_zero\",\n                        c.getLocal(\"itOut\")\n                    )\n                ],[\n                    ...c.call(prefix + \"_copy\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)), AUX),\n                    ...c.call(\n                        prefix+\"_mul\",\n                        c.getLocal(\"itAux\"),\n                        c.getLocal(\"itIn\"),\n                        c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    ),\n                    ...c.call(\n                        prefix+\"_mul\",\n                        c.getLocal(\"itAux\"),\n                        AUX,\n                        c.getLocal(\"itOut\")\n                    )\n                ]\n            ),\n            c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n            c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.getLocal(\"outStep\"))),\n            c.setLocal(\"itAux\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8))),\n            c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        ))\n\n    );\n\n\n    // Recover Old memory\n    f.addCode(\n        c.i32_store(\n            c.i32_const(0),\n            c.getLocal(\"itAux\")\n        )\n    );\n\n}\n","\n\nmodule.exports = buildBatchConvertion;\n\nfunction buildBatchConvertion(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {\n    if (typeof reverse === \"undefined\") {\n        // Set the reverse in a way that allows to use the same buffer as in/out.\n        if (sizeIn < sizeOut) {\n            reverse = true;\n        } else {\n            reverse = false;\n        }\n    }\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"itIn\", \"i32\");\n    f.addLocal(\"itOut\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    if (reverse) {\n        f.addCode(\n            c.setLocal(\"itIn\",\n                c.i32_add(\n                    c.getLocal(\"pIn\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itOut\",\n                c.i32_add(\n                    c.getLocal(\"pOut\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeOut)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    } else {\n        f.addCode(\n            c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    }\n}\n","\n\nmodule.exports = buildBatchConvertion;\n\nfunction buildBatchConvertion(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {\n    if (typeof reverse === \"undefined\") {\n        // Set the reverse in a way that allows to use the same buffer as in/out.\n        if (sizeIn < sizeOut) {\n            reverse = true;\n        } else {\n            reverse = false;\n        }\n    }\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn1\", \"i32\");\n    f.addParam(\"pIn2\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"itIn1\", \"i32\");\n    f.addLocal(\"itIn2\", \"i32\");\n    f.addLocal(\"itOut\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    if (reverse) {\n        f.addCode(\n            c.setLocal(\"itIn1\",\n                c.i32_add(\n                    c.getLocal(\"pIn1\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itIn2\",\n                c.i32_add(\n                    c.getLocal(\"pIn2\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itOut\",\n                c.i32_add(\n                    c.getLocal(\"pOut\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeOut)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn1\"), c.getLocal(\"itIn2\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn1\", c.i32_sub(c.getLocal(\"itIn1\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itIn2\", c.i32_sub(c.getLocal(\"itIn2\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    } else {\n        f.addCode(\n            c.setLocal(\"itIn1\", c.getLocal(\"pIn1\")),\n            c.setLocal(\"itIn2\", c.getLocal(\"pIn2\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn1\"), c.getLocal(\"itIn2\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn1\", c.i32_add(c.getLocal(\"itIn1\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itIn2\", c.i32_add(c.getLocal(\"itIn2\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    }\n}\n","// Many of these utilities are from the `big-integer` library,\n// but adjusted to only work with native BigInt type\n// Ref https://github.com/peterolson/BigInteger.js/blob/e5d2154d3c417069c51e7116bafc3b91d0b9fe41/BigInteger.js\n// Originally licensed The Unlicense\n\nfunction compare(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction square(n) {\n    return n * n;\n}\n\nfunction isOdd(n) {\n    return n % 2n !== 0n;\n}\n\nfunction isEven(n) {\n    return n % 2n === 0n;\n}\n\nfunction isNegative(n) {\n    return n < 0n;\n}\n\nfunction isPositive(n) {\n    return n > 0n;\n}\n\nfunction bitLength(n) {\n    if (isNegative(n)) {\n        return n.toString(2).length - 1; // discard the - sign\n    } else {\n        return n.toString(2).length;\n    }\n}\n\nfunction abs(n) {\n    return n < 0n ? -n : n;\n}\n\nfunction isUnit(n) {\n    return abs(n) === 1n;\n}\n\nfunction modInv(a, n) {\n    var t = 0n, newT = 1n, r = n, newR = abs(a), q, lastT, lastR;\n    while (newR !== 0n) {\n        q = r / newR;\n        lastT = t;\n        lastR = r;\n        t = newT;\n        r = newR;\n        newT = lastT - (q * newT);\n        newR = lastR - (q * newR);\n    }\n    if (!isUnit(r)) throw new Error(a.toString() + \" and \" + n.toString() + \" are not co-prime\");\n    if (compare(t, 0n) === -1) {\n        t = t + n;\n    }\n    if (isNegative(a)) {\n        return -t;\n    }\n    return t;\n}\n\nfunction modPow(n, exp, mod) {\n    if (mod === 0n) throw new Error(\"Cannot take modPow with modulus 0\");\n    var r = 1n,\n        base = n % mod;\n    if (isNegative(exp)) {\n        exp = exp * -1n;\n        base = modInv(base, mod);\n    }\n    while (isPositive(exp)) {\n        if (base === 0n) return 0n;\n        if (isOdd(exp)) r = r * base % mod;\n        exp = exp / 2n;\n        base = square(base) % mod;\n    }\n    return r;\n}\n\nfunction compareAbs(a, b) {\n    a = a >= 0n ? a : -a;\n    b = b >= 0n ? b : -b;\n    return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction isDivisibleBy(a, n) {\n    if (n === 0n) return false;\n    if (isUnit(n)) return true;\n    if (compareAbs(n, 2n) === 0) return isEven(a);\n    return a % n === 0n;\n}\n\nfunction isBasicPrime(v) {\n    var n = abs(v);\n    if (isUnit(n)) return false;\n    if (n === 2n || n === 3n || n === 5n) return true;\n    if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n)) return false;\n    if (n < 49n) return true;\n    // we don't know if it's prime: let the other functions figure it out\n}\n\nfunction prev(n) {\n    return n - 1n;\n}\n\nfunction millerRabinTest(n, a) {\n    var nPrev = prev(n),\n        b = nPrev,\n        r = 0,\n        d, i, x;\n    while (isEven(b)) b = b / 2n, r++;\n    next: for (i = 0; i < a.length; i++) {\n        if (n < a[i]) continue;\n        x = modPow(BigInt(a[i]), b, n);\n        if (isUnit(x) || x === nPrev) continue;\n        for (d = r - 1; d != 0; d--) {\n            x = square(x) % n;\n            if (isUnit(x)) return false;\n            if (x === nPrev) continue next;\n        }\n        return false;\n    }\n    return true;\n}\n\nfunction isPrime(p) {\n    var isPrime = isBasicPrime(p);\n    if (isPrime !== undefined) return isPrime;\n    var n = abs(p);\n    var bits = bitLength(n);\n    if (bits <= 64)\n        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\n    var logN = Math.log(2) * Number(bits);\n    var t = Math.ceil(logN);\n    for (var a = [], i = 0; i < t; i++) {\n        a.push(BigInt(i + 2));\n    }\n    return millerRabinTest(n, a);\n}\n\nmodule.exports.bitLength = bitLength;\nmodule.exports.isOdd = isOdd;\nmodule.exports.isNegative = isNegative;\nmodule.exports.abs = abs;\nmodule.exports.isUnit = isUnit;\nmodule.exports.compare = compare;\nmodule.exports.modInv = modInv;\nmodule.exports.modPow = modPow;\nmodule.exports.isPrime = isPrime;\nmodule.exports.square = square;\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildInt = require(\"./build_int.js\");\nconst utils = require(\"./utils.js\");\nconst buildExp = require(\"./build_timesscalar\");\nconst buildBatchInverse = require(\"./build_batchinverse\");\nconst buildBatchConvertion = require(\"./build_batchconvertion\");\nconst buildBatchOp = require(\"./build_batchop\");\nconst { bitLength, modInv, modPow, isPrime, isOdd, square } = require(\"./bigint.js\");\n\nmodule.exports = function buildF1m(module, _q, _prefix, _intPrefix) {\n    const q = BigInt(_q);\n    const n64 = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n32 = n64*2;\n    const n8 = n64*8;\n\n    const prefix = _prefix || \"f1m\";\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const intPrefix = buildInt(module, n64, _intPrefix);\n    const pq = module.alloc(n8, utils.bigInt2BytesLE(q, n8));\n\n    const pR2 = module.alloc(utils.bigInt2BytesLE(square(1n << BigInt(n64*64)) % q, n8));\n    const pOne = module.alloc(utils.bigInt2BytesLE((1n << BigInt(n64*64)) % q, n8));\n    const pZero = module.alloc(utils.bigInt2BytesLE(0n, n8));\n    const _minusOne = q - 1n;\n    const _e = _minusOne >> 1n; // e = (p-1)/2\n    const pe = module.alloc(n8, utils.bigInt2BytesLE(_e, n8));\n\n    const _ePlusOne = _e + 1n; // e = (p-1)/2\n    const pePlusOne = module.alloc(n8, utils.bigInt2BytesLE(_ePlusOne, n8));\n\n    module.modules[prefix] = {\n        pq: pq,\n        pR2: pR2,\n        n64: n64,\n        q: q,\n        pOne: pOne,\n        pZero: pZero,\n        pePlusOne: pePlusOne\n    };\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(intPrefix + \"_copy\", c.i32_const(pOne), c.getLocal(\"pr\")));\n    }\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.call(intPrefix+\"_add\", c.getLocal(\"x\"),  c.getLocal(\"y\"), c.getLocal(\"r\")),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.call(intPrefix+\"_sub\", c.getLocal(\"x\"),  c.getLocal(\"y\"), c.getLocal(\"r\")),\n                c.drop(c.call(intPrefix+\"_add\", c.getLocal(\"r\"),  c.i32_const(pq), c.getLocal(\"r\")))\n            )\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(prefix + \"_sub\", c.i32_const(pZero), c.getLocal(\"x\"), c.getLocal(\"r\"))\n        );\n    }\n\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), AUX),\n            c.call(intPrefix + \"_gte\", AUX, c.i32_const(pePlusOne) )\n        );\n    }\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if (\n                c.call(intPrefix + \"_isZero\", c.getLocal(\"x\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), AUX),\n            c.if(\n                c.call(intPrefix + \"_gte\", AUX, c.i32_const(pePlusOne)),\n                c.ret(c.i32_const(-1))\n            ),\n            c.ret(c.i32_const(1))\n        );\n    }\n\n\n    function buildMReduct() {\n        const carries = module.alloc(n32*n32*8);\n\n        const f = module.addFunction(prefix+\"_mReduct\");\n        f.addParam(\"t\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"np32\", \"i64\");\n        f.addLocal(\"c\", \"i64\");\n        f.addLocal(\"m\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n        for (let i=0; i<n32; i++) {\n            f.addCode(c.setLocal(\"c\", c.i64_const(0)));\n\n            f.addCode(\n                c.setLocal(\n                    \"m\",\n                    c.i64_and(\n                        c.i64_mul(\n                            c.i64_load32_u(c.getLocal(\"t\"), i*4),\n                            c.getLocal(\"np32\")\n                        ),\n                        c.i64_const(\"0xFFFFFFFF\")\n                    )\n                )\n            );\n\n            for (let j=0; j<n32; j++) {\n\n                f.addCode(\n                    c.setLocal(\"c\",\n                        c.i64_add(\n                            c.i64_add(\n                                c.i64_load32_u(c.getLocal(\"t\"), (i+j)*4),\n                                c.i64_shr_u(c.getLocal(\"c\"), c.i64_const(32))\n                            ),\n                            c.i64_mul(\n                                c.i64_load32_u(c.i32_const(pq), j*4),\n                                c.getLocal(\"m\")\n                            )\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"t\"),\n                        (i+j)*4,\n                        c.getLocal(\"c\")\n                    )\n                );\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.i32_const(carries),\n                    i*4,\n                    c.i64_shr_u(c.getLocal(\"c\"), c.i64_const(32))\n                )\n            );\n        }\n\n        f.addCode(\n            c.call(\n                prefix+\"_add\",\n                c.i32_const(carries),\n                c.i32_add(\n                    c.getLocal(\"t\"),\n                    c.i32_const(n32*4)\n                ),\n                c.getLocal(\"r\")\n            )\n        );\n    }\n\n\n\n    function buildMul() {\n\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"np32\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"y\"+i, \"i64\");\n            f.addLocal(\"m\"+i, \"i64\");\n            f.addLocal(\"q\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n\n        const loadX = [];\n        const loadY = [];\n        const loadQ = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadY[j]) {\n                Y = c.teeLocal(\"y\"+j, c.i64_load32_u( c.getLocal(\"y\"), j*4));\n                loadY[j] = true;\n            } else {\n                Y = c.getLocal(\"y\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        function mulqm(i, j) {\n            let Q,M;\n            if (!loadQ[i]) {\n                Q = c.teeLocal(\"q\"+i, c.i64_load32_u(c.i32_const(0), pq+i*4 ));\n                loadQ[i] = true;\n            } else {\n                Q = c.getLocal(\"q\"+i);\n            }\n            M = c.getLocal(\"m\"+j);\n\n            return c.i64_mul( Q, M );\n        }\n\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            for (let i=Math.max(0, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n\n            for (let i=Math.max(1, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n            if (k<n32) {\n                f.addCode(\n                    c.setLocal(\n                        \"m\"+k,\n                        c.i64_and(\n                            c.i64_mul(\n                                c.i64_and(\n                                    c.getLocal(c0),\n                                    c.i64_const(0xFFFFFFFF)\n                                ),\n                                c.getLocal(\"np32\")\n                            ),\n                            c.i64_const(\"0xFFFFFFFF\")\n                        )\n                    )\n                );\n\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(0,k)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n\n            if (k>=n32) {\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"r\"),\n                        (k-n32)*4,\n                        c.getLocal(c0)\n                    )\n                );\n            }\n            [c0, c1] = [c1, c0];\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_shr_u(\n                        c.getLocal(c0),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4-4,\n                c.getLocal(c0)\n            )\n        );\n\n        f.addCode(\n            c.if(\n                c.i32_wrap_i64(c.getLocal(c1)),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n\n    function buildSquare() {\n\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"c0_old\", \"i64\");\n        f.addLocal(\"c1_old\", \"i64\");\n        f.addLocal(\"np32\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"m\"+i, \"i64\");\n            f.addLocal(\"q\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n\n        const loadX = [];\n        const loadQ = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadX[j]) {\n                Y = c.teeLocal(\"x\"+j, c.i64_load32_u( c.getLocal(\"x\"), j*4));\n                loadX[j] = true;\n            } else {\n                Y = c.getLocal(\"x\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        function mulqm(i, j) {\n            let Q,M;\n            if (!loadQ[i]) {\n                Q = c.teeLocal(\"q\"+i, c.i64_load32_u(c.i32_const(0), pq+i*4 ));\n                loadQ[i] = true;\n            } else {\n                Q = c.getLocal(\"q\"+i);\n            }\n            M = c.getLocal(\"m\"+j);\n\n            return c.i64_mul( Q, M );\n        }\n\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n        let c0_old = \"c0_old\";\n        let c1_old = \"c1_old\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            f.addCode(\n                c.setLocal(c0, c.i64_const(0)),\n                c.setLocal(c1, c.i64_const(0)),\n            );\n            for (let i=Math.max(0, k-n32+1); (i<((k+1)>>1) )&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Multiply by 2\n            f.addCode(\n                c.setLocal(c0,\n                    c.i64_shl(\n                        c.i64_and(\n                            c.getLocal(c0),\n                            c.i64_const(0xFFFFFFFF)\n                        ),\n                        c.i64_const(1)\n                    )\n                )\n            );\n\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_add(\n                        c.i64_shl(\n                            c.getLocal(c1),\n                            c.i64_const(1)\n                        ),\n                        c.i64_shr_u(\n                            c.getLocal(c0),\n                            c.i64_const(32)\n                        )\n                    )\n                )\n            );\n\n            if (k%2 == 0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(k>>1, k>>1)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Add the old carry\n\n            if (k>0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            c.i64_and(\n                                c.getLocal(c0_old),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.i64_add(\n                                c.getLocal(c1),\n                                c.i64_shr_u(\n                                    c.getLocal(c0),\n                                    c.i64_const(32)\n                                )\n                            ),\n                            c.getLocal(c1_old)\n                        )\n                    )\n                );\n            }\n\n\n            for (let i=Math.max(1, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n            if (k<n32) {\n                f.addCode(\n                    c.setLocal(\n                        \"m\"+k,\n                        c.i64_and(\n                            c.i64_mul(\n                                c.i64_and(\n                                    c.getLocal(c0),\n                                    c.i64_const(0xFFFFFFFF)\n                                ),\n                                c.getLocal(\"np32\")\n                            ),\n                            c.i64_const(\"0xFFFFFFFF\")\n                        )\n                    )\n                );\n\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(0,k)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            if (k>=n32) {\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"r\"),\n                        (k-n32)*4,\n                        c.getLocal(c0)\n                    )\n                );\n            }\n            f.addCode(\n                c.setLocal(\n                    c0_old,\n                    c.getLocal(c1)\n                ),\n                c.setLocal(\n                    c1_old,\n                    c.i64_shr_u(\n                        c.getLocal(c0_old),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4-4,\n                c.getLocal(c0_old)\n            )\n        );\n\n        f.addCode(\n            c.if(\n                c.i32_wrap_i64(c.getLocal(c1_old)),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n\n    function buildSquareOld() {\n        const f = module.addFunction(prefix+\"_squareOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(prefix+\"_mul\", c.getLocal(\"x\"), c.i32_const(pR2), c.getLocal(\"r\")));\n    }\n\n    function buildFromMontgomery() {\n\n        const pAux2 = module.alloc(n8*2);\n\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(intPrefix + \"_copy\", c.getLocal(\"x\"), c.i32_const(pAux2) ));\n        f.addCode(c.call(intPrefix + \"_zero\", c.i32_const(pAux2 + n8) ));\n        f.addCode(c.call(prefix+\"_mReduct\", c.i32_const(pAux2), c.getLocal(\"r\")));\n    }\n\n    function buildInverse() {\n\n        const f = module.addFunction(prefix+ \"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), c.getLocal(\"r\")));\n        f.addCode(c.call(intPrefix + \"_inverseMod\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\")));\n        f.addCode(c.call(prefix + \"_toMontgomery\", c.getLocal(\"r\"), c.getLocal(\"r\")));\n    }\n\n    // Calculate various valuse needed for sqrt\n\n\n    let _nqr = 2n;\n    if (isPrime(q)) {\n        while (modPow(_nqr, _e, q) !== _minusOne) _nqr = _nqr + 1n;\n    }\n\n    let s2 = 0;\n    let _t = _minusOne;\n\n    while ((!isOdd(_t))&&(_t !== 0n)) {\n        s2++;\n        _t = _t >> 1n;\n    }\n    const pt = module.alloc(n8, utils.bigInt2BytesLE(_t, n8));\n\n    const _nqrToT = modPow(_nqr, _t, q);\n    const pNqrToT = module.alloc(utils.bigInt2BytesLE((_nqrToT << BigInt(n64*64)) % q, n8));\n\n    const _tPlusOneOver2 = (_t + 1n) >> 1n;\n    const ptPlusOneOver2 = module.alloc(n8, utils.bigInt2BytesLE(_tPlusOneOver2, n8));\n\n    function buildSqrt() {\n\n        const f = module.addFunction(prefix+ \"_sqrt\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const ONE = c.i32_const(pOne);\n        const C = c.i32_const(module.alloc(n8));\n        const T = c.i32_const(module.alloc(n8));\n        const R = c.i32_const(module.alloc(n8));\n        const SQ = c.i32_const(module.alloc(n8));\n        const B = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n\n            // If (n==0) return 0\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"n\")),\n                c.ret(\n                    c.call(prefix + \"_zero\", c.getLocal(\"r\"))\n                )\n            ),\n\n            c.setLocal(\"m\", c.i32_const(s2)),\n            c.call(prefix + \"_copy\", c.i32_const(pNqrToT), C),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(pt), c.i32_const(n8), T),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(ptPlusOneOver2), c.i32_const(n8), R),\n\n            c.block(c.loop(\n                c.br_if(1, c.call(prefix + \"_eq\", T, ONE)),\n\n                c.call(prefix + \"_square\", T, SQ),\n                c.setLocal(\"i\", c.i32_const(1)),\n                c.block(c.loop(\n                    c.br_if(1, c.call(prefix + \"_eq\", SQ, ONE)),\n                    c.call(prefix + \"_square\", SQ, SQ),\n                    c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.call(prefix + \"_copy\", C, B),\n                c.setLocal(\"j\", c.i32_sub(c.i32_sub( c.getLocal(\"m\"), c.getLocal(\"i\")), c.i32_const(1)) ),\n                c.block(c.loop(\n                    c.br_if(1, c.i32_eqz(c.getLocal(\"j\"))),\n                    c.call(prefix + \"_square\", B, B),\n                    c.setLocal(\"j\", c.i32_sub(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"m\", c.getLocal(\"i\")),\n                c.call(prefix + \"_square\", B, C),\n                c.call(prefix + \"_mul\", T, C, T),\n                c.call(prefix + \"_mul\", R, B, R),\n\n                c.br(0)\n            )),\n\n            c.if(\n                c.call(prefix + \"_isNegative\", R),\n                c.call(prefix + \"_neg\", R, c.getLocal(\"r\")),\n                c.call(prefix + \"_copy\", R, c.getLocal(\"r\")),\n            )\n        );\n    }\n\n    function buildIsSquare() {\n        const f = module.addFunction(prefix+\"_isSquare\");\n        f.addParam(\"n\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const ONE = c.i32_const(pOne);\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"n\")),\n                c.ret(c.i32_const(1))\n            ),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(pe), c.i32_const(n8), AUX),\n            c.call(prefix + \"_eq\", AUX, ONE)\n        );\n    }\n\n\n    function buildLoad() {\n        const f = module.addFunction(prefix+\"_load\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"p\", \"i32\");\n        f.addLocal(\"l\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        const c = f.getCodeBuilder();\n\n        const R = c.i32_const(module.alloc(n8));\n        const pAux = module.alloc(n8);\n        const AUX = c.i32_const(pAux);\n\n        f.addCode(\n            c.call(intPrefix + \"_zero\", c.getLocal(\"r\")),\n            c.setLocal(\"i\", c.i32_const(n8)),\n            c.setLocal(\"p\", c.getLocal(\"scalar\")),\n            c.block(c.loop(\n                c.br_if(1, c.i32_gt_u(c.getLocal(\"i\"), c.getLocal(\"scalarLen\"))),\n\n                c.if(\n                    c.i32_eq(c.getLocal(\"i\"), c.i32_const(n8)),\n                    c.call(prefix + \"_one\", R),\n                    c.call(prefix + \"_mul\", R, c.i32_const(pR2), R)\n                ),\n                c.call(prefix + \"_mul\", c.getLocal(\"p\"), R, AUX),\n                c.call(prefix + \"_add\", c.getLocal(\"r\"), AUX, c.getLocal(\"r\")),\n\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n            c.setLocal(\"l\", c.i32_rem_u( c.getLocal(\"scalarLen\"), c.i32_const(n8))),\n            c.if(c.i32_eqz(c.getLocal(\"l\")), c.ret([])),\n            c.call(intPrefix + \"_zero\", AUX),\n            c.setLocal(\"j\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq(c.getLocal(\"j\"), c.getLocal(\"l\"))),\n\n                c.i32_store8(\n                    c.getLocal(\"j\"),\n                    pAux,\n                    c.i32_load8_u(c.getLocal(\"p\")),\n                ),\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(1))),\n                c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.if(\n                c.i32_eq(c.getLocal(\"i\"), c.i32_const(n8)),\n                c.call(prefix + \"_one\", R),\n                c.call(prefix + \"_mul\", R, c.i32_const(pR2), R)\n            ),\n            c.call(prefix + \"_mul\", AUX, R, AUX),\n            c.call(prefix + \"_add\", c.getLocal(\"r\"), AUX, c.getLocal(\"r\")),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefix + \"_load\", c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), AUX),\n            c.call(prefix + \"_toMontgomery\", AUX, AUX),\n            c.call(prefix + \"_mul\", c.getLocal(\"x\"), AUX, c.getLocal(\"r\")),\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(\n            c.ret(c.call(intPrefix + \"_eq\", c.getLocal(\"x\"), c.i32_const(pOne)))\n        );\n    }\n\n\n    module.exportFunction(intPrefix + \"_copy\", prefix+\"_copy\");\n    module.exportFunction(intPrefix + \"_zero\", prefix+\"_zero\");\n    module.exportFunction(intPrefix + \"_isZero\", prefix+\"_isZero\");\n    module.exportFunction(intPrefix + \"_eq\", prefix+\"_eq\");\n\n    buildIsOne();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildMReduct();\n    buildMul();\n    buildSquare();\n    buildSquareOld();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildIsNegative();\n    buildSign();\n    buildInverse();\n    buildOne();\n    buildLoad();\n    buildTimesScalar();\n    buildBatchInverse(module, prefix);\n    buildBatchConvertion(module, prefix + \"_batchToMontgomery\", prefix + \"_toMontgomery\", n8, n8);\n    buildBatchConvertion(module, prefix + \"_batchFromMontgomery\", prefix + \"_fromMontgomery\", n8, n8);\n    buildBatchConvertion(module, prefix + \"_batchNeg\", prefix + \"_neg\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchAdd\", prefix + \"_add\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchSub\", prefix + \"_sub\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchMul\", prefix + \"_mul\", n8, n8);\n\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_isNegative\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_mReduct\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_squareOld\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_inverse\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_load\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    buildExp(\n        module,\n        prefix + \"_exp\",\n        n8,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        intPrefix + \"_copy\",\n        prefix + \"_one\",\n    );\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    if (isPrime(q)) {\n        buildSqrt();\n        buildIsSquare();\n        module.exportFunction(prefix + \"_sqrt\");\n        module.exportFunction(prefix + \"_isSquare\");\n    }\n    module.exportFunction(prefix + \"_batchToMontgomery\");\n    module.exportFunction(prefix + \"_batchFromMontgomery\");\n    // console.log(module.functionIdxByName);\n\n    return prefix;\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildF1m =require(\"./build_f1m.js\");\nconst { bitLength } = require(\"./bigint.js\");\n\nmodule.exports = function buildF1(module, _q, _prefix, _f1mPrefix, _intPrefix) {\n\n    const q = BigInt(_q);\n    const n64 = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n8 = n64*8;\n\n    const prefix = _prefix || \"f1\";\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {\n        n64: n64\n    };\n\n    const intPrefix = _intPrefix || \"int\";\n    const f1mPrefix = buildF1m(module, q, _f1mPrefix, intPrefix);\n\n\n    const pR2 =     module.modules[f1mPrefix].pR2;\n    const pq =     module.modules[f1mPrefix].pq;\n    const pePlusOne = module.modules[f1mPrefix].pePlusOne;\n\n    function buildMul() {\n        const pAux1 = module.alloc(n8);\n\n        const f = module.addFunction(prefix+ \"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(f1mPrefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"y\"), c.i32_const(pAux1)));\n        f.addCode(c.call(f1mPrefix + \"_mul\", c.i32_const(pAux1), c.i32_const(pR2), c.getLocal(\"r\")));\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n\n    function buildInverse() {\n\n        const f = module.addFunction(prefix+ \"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(intPrefix + \"_inverseMod\", c.getLocal(\"x\"), c.i32_const(pq), c.getLocal(\"r\")));\n    }\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(intPrefix + \"_gte\", c.getLocal(\"x\"), c.i32_const(pePlusOne) )\n        );\n    }\n\n\n    buildMul();\n    buildSquare();\n    buildInverse();\n    buildIsNegative();\n    module.exportFunction(f1mPrefix + \"_add\", prefix + \"_add\");\n    module.exportFunction(f1mPrefix + \"_sub\", prefix + \"_sub\");\n    module.exportFunction(f1mPrefix + \"_neg\", prefix + \"_neg\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_inverse\");\n    module.exportFunction(prefix + \"_isNegative\");\n    module.exportFunction(f1mPrefix + \"_copy\", prefix+\"_copy\");\n    module.exportFunction(f1mPrefix + \"_zero\", prefix+\"_zero\");\n    module.exportFunction(f1mPrefix + \"_one\", prefix+\"_one\");\n    module.exportFunction(f1mPrefix + \"_isZero\", prefix+\"_isZero\");\n    module.exportFunction(f1mPrefix + \"_eq\", prefix+\"_eq\");\n\n    return prefix;\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst buildExp = require(\"./build_timesscalar\");\nconst buildBatchInverse = require(\"./build_batchinverse\");\nconst utils = require(\"./utils.js\");\n\nmodule.exports = function buildF2m(module, mulNonResidueFn, prefix, f1mPrefix) {\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const f1n8 = module.modules[f1mPrefix].n64*8;\n    const q = module.modules[f1mPrefix].q;\n\n    module.modules[prefix] = {\n        n64: module.modules[f1mPrefix].n64*2\n    };\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_add\", x0, y0, r0),\n            c.call(f1mPrefix+\"_add\", x1, y1, r1),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_timesScalar\", x0, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r0),\n            c.call(f1mPrefix+\"_timesScalar\", x1, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r1),\n        );\n    }\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_sub\", x0, y0, r0),\n            c.call(f1mPrefix+\"_sub\", x1, y1, r1),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_neg\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n        );\n    }\n\n    function buildConjugate() {\n        const f = module.addFunction(prefix+\"_conjugate\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n        );\n    }\n\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.if(\n                c.call(f1mPrefix+\"_isZero\", x1),\n                c.ret(c.call(f1mPrefix+\"_isNegative\", x0))\n            ),\n            c.ret(c.call(f1mPrefix+\"_isNegative\", x1))\n        );\n    }\n\n    function buildMul() {\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const A = c.i32_const(module.alloc(f1n8));\n        const B = c.i32_const(module.alloc(f1n8));\n        const C = c.i32_const(module.alloc(f1n8));\n        const D = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            c.call(f1mPrefix + \"_mul\", x0, y0, A),             // A = x0*y0\n            c.call(f1mPrefix + \"_mul\", x1, y1, B),             // B = x1*y1\n\n            c.call(f1mPrefix + \"_add\", x0, x1, C),             // C = x0 + x1\n            c.call(f1mPrefix + \"_add\", y0, y1, D),             // D = y0 + y1\n            c.call(f1mPrefix + \"_mul\", C, D, C),               // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1\n\n            //  c.call(f1mPrefix + \"_mul\", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)\n            c.call(mulNonResidueFn, B, r0),  // r0 = nr*(x1*y1)\n            c.call(f1mPrefix + \"_add\", A, r0, r0),             // r0 = x0*y0 + nr*(x1*y1)\n            c.call(f1mPrefix + \"_add\", A, B, r1),             // r1 = x0*y0+x1*y1\n            c.call(f1mPrefix + \"_sub\", C, r1, r1)              // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0\n        );\n\n    }\n\n    function buildMul1() {\n        const f = module.addFunction(prefix+\"_mul1\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y = c.getLocal(\"y\");\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n\n        f.addCode(\n            c.call(f1mPrefix + \"_mul\", x0, y, r0),             // A = x0*y\n            c.call(f1mPrefix + \"_mul\", x1, y, r1),             // B = x1*y\n        );\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const AB = c.i32_const(module.alloc(f1n8));\n        const APB = c.i32_const(module.alloc(f1n8));\n        const APNB = c.i32_const(module.alloc(f1n8));\n        const ABPNAB = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            // AB = x0*y1\n            c.call(f1mPrefix + \"_mul\", x0, x1, AB),\n\n            // APB = x0+y1\n            c.call(f1mPrefix + \"_add\", x0, x1, APB),\n\n            // APBN0 = x0 + nr*x1\n            c.call(mulNonResidueFn, x1, APNB),\n            c.call(f1mPrefix + \"_add\", x0, APNB, APNB),\n\n            // ABPNAB = ab + nr*ab\n            c.call(mulNonResidueFn, AB, ABPNAB),\n            c.call(f1mPrefix + \"_add\", ABPNAB, AB, ABPNAB),\n\n            // r0 = APB * APNB - ABPNAB\n            c.call(f1mPrefix + \"_mul\", APB, APNB, r0),\n            c.call(f1mPrefix + \"_sub\", r0, ABPNAB, r0),\n\n            // r1 = AB + AB\n            c.call(f1mPrefix + \"_add\", AB, AB, r1),\n        );\n\n    }\n\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_toMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_toMontgomery\", x1, r1)\n        );\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_fromMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_fromMontgomery\", x1, r1)\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_copy\", x1, r1)\n        );\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_zero\", x0),\n            c.call(f1mPrefix+\"_zero\", x1)\n        );\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_one\", x0),\n            c.call(f1mPrefix+\"_zero\", x1)\n        );\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.call(f1mPrefix+\"_eq\", x0, y0),\n                c.call(f1mPrefix+\"_eq\", x1, y1)\n            )\n        );\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.call(f1mPrefix+\"_isZero\", x0),\n                c.call(f1mPrefix+\"_isZero\", x1)\n            )\n        );\n    }\n\n    function buildInverse() {\n        const f = module.addFunction(prefix+\"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const t0 = c.i32_const(module.alloc(f1n8));\n        const t1 = c.i32_const(module.alloc(f1n8));\n        const t2 = c.i32_const(module.alloc(f1n8));\n        const t3 = c.i32_const(module.alloc(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_square\", x0, t0),\n            c.call(f1mPrefix+\"_square\", x1, t1),\n            // c.call(f1mPrefix+\"_mul\", t1, c.i32_const(pNonResidue), t2),\n            c.call(mulNonResidueFn, t1, t2),\n\n            c.call(f1mPrefix+\"_sub\", t0, t2, t2),\n            c.call(f1mPrefix+\"_inverse\", t2, t3),\n\n            c.call(f1mPrefix+\"_mul\", x0, t3, r0),\n            c.call(f1mPrefix+\"_mul\", x1, t3, r1),\n            c.call(f1mPrefix+\"_neg\", r1, r1),\n        );\n    }\n\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x1)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.ret(c.call( f1mPrefix + \"_sign\", x0))\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.ret(c.i32_and(\n                c.call(f1mPrefix + \"_isOne\", x0),\n                c.call(f1mPrefix + \"_isZero\", x1),\n            ))\n        );\n    }\n\n\n    // Check here: https://eprint.iacr.org/2012/685.pdf\n    // Alg 9adj\n    function buildSqrt() {\n\n        const f = module.addFunction(prefix+\"_sqrt\");\n        f.addParam(\"a\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e34 = c.i32_const(module.alloc(utils.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8 )));\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e12 = c.i32_const(module.alloc(utils.bigInt2BytesLE((BigInt(q || 0) - 1n) / 2n, f1n8 )));\n\n        const a = c.getLocal(\"a\");\n        const a1 = c.i32_const(module.alloc(f1n8*2));\n        const alpha = c.i32_const(module.alloc(f1n8*2));\n        const a0 = c.i32_const(module.alloc(f1n8*2));\n        const pn1 = module.alloc(f1n8*2);\n        const n1 = c.i32_const(pn1);\n        const n1a = c.i32_const(pn1);\n        const n1b = c.i32_const(pn1+f1n8);\n        const x0 = c.i32_const(module.alloc(f1n8*2));\n        const b = c.i32_const(module.alloc(f1n8*2));\n\n        f.addCode(\n\n            c.call(prefix + \"_one\", n1),\n            c.call(prefix + \"_neg\", n1, n1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_exp\", a, e34, c.i32_const(f1n8), a1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_square\", a1, alpha),\n            c.call(prefix + \"_mul\", a, alpha, alpha),\n\n            // const a0 = F.mul(F.frobenius(1, alfa), alfa);\n            c.call(prefix + \"_conjugate\", alpha, a0),\n            c.call(prefix + \"_mul\", a0, alpha, a0),\n\n            // if (F.eq(a0, F.negone)) return null;\n            c.if(c.call(prefix + \"_eq\",a0,n1), c.unreachable() ),\n\n            // const x0 = F.mul(a1, a);\n            c.call(prefix + \"_mul\", a1, a, x0),\n\n            // if (F.eq(alfa, F.negone)) {\n            c.if(\n                c.call(prefix + \"_eq\", alpha, n1),\n                [\n                    // x = F.mul(x0, [F.F.zero, F.F.one]);\n                    ...c.call(f1mPrefix + \"_zero\", n1a),\n                    ...c.call(f1mPrefix + \"_one\", n1b),\n                    ...c.call(prefix + \"_mul\", n1, x0, c.getLocal(\"pr\")),\n                ],\n                [\n                    // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n                    ...c.call(prefix + \"_one\", b),\n                    ...c.call(prefix + \"_add\", b, alpha, b),\n                    ...c.call(prefix + \"_exp\", b, e12, c.i32_const(f1n8), b),\n\n                    // x = F.mul(b, x0);\n                    ...c.call(prefix + \"_mul\", b, x0, c.getLocal(\"pr\")),\n                ]\n            )\n        );\n\n    }\n\n\n    function buildIsSquare() {\n\n        const f = module.addFunction(prefix+\"_isSquare\");\n        f.addParam(\"a\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e34 = c.i32_const(module.alloc(utils.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8 )));\n\n        const a = c.getLocal(\"a\");\n        const a1 = c.i32_const(module.alloc(f1n8*2));\n        const alpha = c.i32_const(module.alloc(f1n8*2));\n        const a0 = c.i32_const(module.alloc(f1n8*2));\n        const pn1 = module.alloc(f1n8*2);\n        const n1 = c.i32_const(pn1);\n\n        f.addCode(\n\n            c.call(prefix + \"_one\", n1),\n            c.call(prefix + \"_neg\", n1, n1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_exp\", a, e34, c.i32_const(f1n8), a1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_square\", a1, alpha),\n            c.call(prefix + \"_mul\", a, alpha, alpha),\n\n            // const a0 = F.mul(F.frobenius(1, alfa), alfa);\n            c.call(prefix + \"_conjugate\", alpha, a0),\n            c.call(prefix + \"_mul\", a0, alpha, a0),\n\n            // if (F.eq(a0, F.negone)) return null;\n            c.if(\n                c.call(\n                    prefix + \"_eq\",\n                    a0,\n                    n1\n                ),\n                c.ret(c.i32_const(0))\n            ),\n            c.ret(c.i32_const(1))\n        );\n\n    }\n\n\n    buildIsZero();\n    buildIsOne();\n    buildZero();\n    buildOne();\n    buildCopy();\n    buildMul();\n    buildMul1();\n    buildSquare();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildConjugate();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildEq();\n    buildInverse();\n    buildTimesScalar();\n    buildSign();\n    buildIsNegative();\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_mul1\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_conjugate\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_inverse\");\n    buildBatchInverse(module, prefix);\n    buildExp(\n        module,\n        prefix + \"_exp\",\n        f1n8*2,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        prefix + \"_copy\",\n        prefix + \"_one\",\n    );\n    buildSqrt();\n    buildIsSquare();\n\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    module.exportFunction(prefix + \"_sqrt\");\n    module.exportFunction(prefix + \"_isSquare\");\n    module.exportFunction(prefix + \"_isNegative\");\n\n\n    return prefix;\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst buildExp = require(\"./build_timesscalar\");\nconst buildBatchInverse = require(\"./build_batchinverse\");\n\nmodule.exports = function buildF3m(module, mulNonResidueFn, prefix, f1mPrefix) {\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const f1n8 = module.modules[f1mPrefix].n64*8;\n    module.modules[prefix] = {\n        n64: module.modules[f1mPrefix].n64*3\n    };\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_add\", x0, y0, r0),\n            c.call(f1mPrefix+\"_add\", x1, y1, r1),\n            c.call(f1mPrefix+\"_add\", x2, y2, r2),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_timesScalar\", x0, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r0),\n            c.call(f1mPrefix+\"_timesScalar\", x1, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r1),\n            c.call(f1mPrefix+\"_timesScalar\", x2, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r2),\n        );\n    }\n\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_sub\", x0, y0, r0),\n            c.call(f1mPrefix+\"_sub\", x1, y1, r1),\n            c.call(f1mPrefix+\"_sub\", x2, y2, r2),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_neg\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n            c.call(f1mPrefix+\"_neg\", x2, r2),\n        );\n    }\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.if(\n                c.call(f1mPrefix+\"_isZero\", x2),\n                c.if(\n                    c.call(f1mPrefix+\"_isZero\", x1),\n                    c.ret(c.call(f1mPrefix+\"_isNegative\", x0)),\n                    c.ret(c.call(f1mPrefix+\"_isNegative\", x1))\n                )\n            ),\n            c.ret(c.call(f1mPrefix+\"_isNegative\", x2))\n        );\n    }\n\n\n    function buildMul() {\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const cd = f.getCodeBuilder();\n\n        const a = cd.getLocal(\"x\");\n        const b = cd.i32_add(cd.getLocal(\"x\"), cd.i32_const(f1n8));\n        const c = cd.i32_add(cd.getLocal(\"x\"), cd.i32_const(2*f1n8));\n        const A = cd.getLocal(\"y\");\n        const B = cd.i32_add(cd.getLocal(\"y\"), cd.i32_const(f1n8));\n        const C = cd.i32_add(cd.getLocal(\"y\"), cd.i32_const(2*f1n8));\n        const r0 = cd.getLocal(\"r\");\n        const r1 = cd.i32_add(cd.getLocal(\"r\"), cd.i32_const(f1n8));\n        const r2 = cd.i32_add(cd.getLocal(\"r\"), cd.i32_const(2*f1n8));\n\n        const aA = cd.i32_const(module.alloc(f1n8));\n        const bB = cd.i32_const(module.alloc(f1n8));\n        const cC = cd.i32_const(module.alloc(f1n8));\n        const a_b = cd.i32_const(module.alloc(f1n8));\n        const A_B = cd.i32_const(module.alloc(f1n8));\n        const a_c = cd.i32_const(module.alloc(f1n8));\n        const A_C = cd.i32_const(module.alloc(f1n8));\n        const b_c = cd.i32_const(module.alloc(f1n8));\n        const B_C = cd.i32_const(module.alloc(f1n8));\n        const aA_bB = cd.i32_const(module.alloc(f1n8));\n        const aA_cC = cd.i32_const(module.alloc(f1n8));\n        const bB_cC = cd.i32_const(module.alloc(f1n8));\n        const AUX = cd.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            cd.call(f1mPrefix + \"_mul\", a, A, aA),\n            cd.call(f1mPrefix + \"_mul\", b, B, bB),\n            cd.call(f1mPrefix + \"_mul\", c, C, cC),\n\n            cd.call(f1mPrefix + \"_add\", a, b, a_b),\n            cd.call(f1mPrefix + \"_add\", A, B, A_B),\n            cd.call(f1mPrefix + \"_add\", a, c, a_c),\n            cd.call(f1mPrefix + \"_add\", A, C, A_C),\n            cd.call(f1mPrefix + \"_add\", b, c, b_c),\n            cd.call(f1mPrefix + \"_add\", B, C, B_C),\n\n            cd.call(f1mPrefix + \"_add\", aA, bB, aA_bB),\n            cd.call(f1mPrefix + \"_add\", aA, cC, aA_cC),\n            cd.call(f1mPrefix + \"_add\", bB, cC, bB_cC),\n\n            cd.call(f1mPrefix + \"_mul\", b_c, B_C, r0),\n            cd.call(f1mPrefix + \"_sub\", r0, bB_cC, r0),\n            cd.call(mulNonResidueFn, r0, r0),\n            cd.call(f1mPrefix + \"_add\", aA, r0, r0),\n\n            cd.call(f1mPrefix + \"_mul\", a_b, A_B, r1),\n            cd.call(f1mPrefix + \"_sub\", r1, aA_bB, r1),\n            cd.call(mulNonResidueFn, cC, AUX),\n            cd.call(f1mPrefix + \"_add\", r1, AUX, r1),\n\n            cd.call(f1mPrefix + \"_mul\", a_c, A_C, r2),\n            cd.call(f1mPrefix + \"_sub\", r2, aA_cC, r2),\n            cd.call(f1mPrefix + \"_add\", r2, bB, r2),\n        );\n\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const A = c.getLocal(\"x\");\n        const B = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const C = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        const s0 = c.i32_const(module.alloc(f1n8));\n        const ab = c.i32_const(module.alloc(f1n8));\n        const s1 = c.i32_const(module.alloc(f1n8));\n        const s2 = c.i32_const(module.alloc(f1n8));\n        const bc = c.i32_const(module.alloc(f1n8));\n        const s3 = c.i32_const(module.alloc(f1n8));\n        const s4 = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n\n            c.call(f1mPrefix + \"_square\", A, s0),\n            c.call(f1mPrefix + \"_mul\", A, B, ab),\n            c.call(f1mPrefix + \"_add\", ab, ab, s1),\n\n            c.call(f1mPrefix + \"_sub\", A, B, s2),\n            c.call(f1mPrefix + \"_add\", s2, C, s2),\n            c.call(f1mPrefix + \"_square\", s2, s2),\n\n            c.call(f1mPrefix + \"_mul\", B, C, bc),\n            c.call(f1mPrefix + \"_add\", bc, bc, s3),\n\n            c.call(f1mPrefix + \"_square\", C, s4),\n\n            c.call(mulNonResidueFn, s3, r0),\n            c.call(f1mPrefix + \"_add\", s0, r0, r0),\n\n            c.call(mulNonResidueFn, s4, r1),\n            c.call(f1mPrefix + \"_add\", s1, r1, r1),\n\n            c.call(f1mPrefix + \"_add\", s0, s4, r2),\n            c.call(f1mPrefix + \"_sub\", s3, r2, r2),\n            c.call(f1mPrefix + \"_add\", s2, r2, r2),\n            c.call(f1mPrefix + \"_add\", s1, r2, r2),\n        );\n\n    }\n\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_toMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_toMontgomery\", x1, r1),\n            c.call(f1mPrefix+\"_toMontgomery\", x2, r2)\n        );\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_fromMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_fromMontgomery\", x1, r1),\n            c.call(f1mPrefix+\"_fromMontgomery\", x2, r2)\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_copy\", x1, r1),\n            c.call(f1mPrefix+\"_copy\", x2, r2),\n        );\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_zero\", x0),\n            c.call(f1mPrefix+\"_zero\", x1),\n            c.call(f1mPrefix+\"_zero\", x2),\n        );\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_one\", x0),\n            c.call(f1mPrefix+\"_zero\", x1),\n            c.call(f1mPrefix+\"_zero\", x2),\n        );\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.i32_and(\n                    c.call(f1mPrefix+\"_eq\", x0, y0),\n                    c.call(f1mPrefix+\"_eq\", x1, y1),\n                ),\n                c.call(f1mPrefix+\"_eq\", x2, y2)\n            )\n        );\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.i32_and(\n                    c.call(f1mPrefix+\"_isZero\", x0),\n                    c.call(f1mPrefix+\"_isZero\", x1)\n                ),\n                c.call(f1mPrefix+\"_isZero\", x2)\n            )\n        );\n    }\n\n    function buildInverse() {\n        const f = module.addFunction(prefix+\"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        const t0 = c.i32_const(module.alloc(f1n8));\n        const t1 = c.i32_const(module.alloc(f1n8));\n        const t2 = c.i32_const(module.alloc(f1n8));\n        const t3 = c.i32_const(module.alloc(f1n8));\n        const t4 = c.i32_const(module.alloc(f1n8));\n        const t5 = c.i32_const(module.alloc(f1n8));\n        const c0 = c.i32_const(module.alloc(f1n8));\n        const c1 = c.i32_const(module.alloc(f1n8));\n        const c2 = c.i32_const(module.alloc(f1n8));\n        const t6 = c.i32_const(module.alloc(f1n8));\n        const AUX = c.i32_const(module.alloc(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_square\", x0, t0),\n            c.call(f1mPrefix+\"_square\", x1, t1),\n            c.call(f1mPrefix+\"_square\", x2, t2),\n            c.call(f1mPrefix+\"_mul\", x0, x1, t3),\n            c.call(f1mPrefix+\"_mul\", x0, x2, t4),\n            c.call(f1mPrefix+\"_mul\", x1, x2, t5),\n\n            c.call(mulNonResidueFn, t5, c0),\n            c.call(f1mPrefix+\"_sub\", t0, c0, c0),\n\n            c.call(mulNonResidueFn, t2, c1),\n            c.call(f1mPrefix+\"_sub\", c1, t3, c1),\n\n            c.call(f1mPrefix+\"_sub\", t1, t4, c2),\n\n            c.call(f1mPrefix+\"_mul\", x2, c1, t6),\n            c.call(f1mPrefix+\"_mul\", x1, c2, AUX),\n            c.call(f1mPrefix+\"_add\", t6, AUX, t6),\n            c.call(mulNonResidueFn, t6, t6),\n            c.call(f1mPrefix+\"_mul\", x0, c0, AUX),\n            c.call(f1mPrefix+\"_add\", AUX, t6, t6),\n\n            c.call(f1mPrefix+\"_inverse\", t6, t6),\n\n            c.call(f1mPrefix+\"_mul\", t6, c0, r0),\n            c.call(f1mPrefix+\"_mul\", t6, c1, r1),\n            c.call(f1mPrefix+\"_mul\", t6, c2, r2)\n        );\n    }\n\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x2)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x1)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.ret(c.call( f1mPrefix + \"_sign\", x0))\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8*2));\n\n        f.addCode(\n            c.ret(\n                c.i32_and(\n                    c.i32_and(\n                        c.call(f1mPrefix + \"_isOne\", x0),\n                        c.call(f1mPrefix + \"_isZero\", x1)\n                    ),\n                    c.call(f1mPrefix + \"_isZero\", x2)\n                )\n            )\n        );\n    }\n\n    buildIsZero();\n    buildIsOne();\n    buildZero();\n    buildOne();\n    buildCopy();\n    buildMul();\n    buildSquare();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildSign();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildEq();\n    buildInverse();\n    buildTimesScalar();\n    buildIsNegative();\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_inverse\");\n    buildBatchInverse(module, prefix);\n    buildExp(\n        module,\n        prefix + \"_exp\",\n        f1n8*3,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        prefix + \"_copy\",\n        prefix + \"_one\"\n    );\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    module.exportFunction(prefix + \"_isNegative\");\n\n    return prefix;\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildTimesScalarNAF(module, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"base\", \"i32\");\n    f.addParam(\"scalar\", \"i32\");\n    f.addParam(\"scalarLength\", \"i32\");\n    f.addParam(\"r\", \"i32\");\n    f.addLocal(\"old0\", \"i32\");\n    f.addLocal(\"nbits\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"last\", \"i32\");\n    f.addLocal(\"cur\", \"i32\");\n    f.addLocal(\"carry\", \"i32\");\n    f.addLocal(\"p\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const aux = c.i32_const(module.alloc(elementLen));\n\n    function getBit(IDX) {\n        return c.i32_and(\n            c.i32_shr_u(\n                c.i32_load(\n                    c.i32_add(\n                        c.getLocal(\"scalar\"),\n                        c.i32_and(\n                            c.i32_shr_u(\n                                IDX,\n                                c.i32_const(3)\n                            ),\n                            c.i32_const(0xFFFFFFFC)\n                        )\n                    )\n                ),\n                c.i32_and(\n                    IDX,\n                    c.i32_const(0x1F)\n                )\n            ),\n            c.i32_const(1)\n        );\n    }\n\n    function pushBit(b) {\n        return [\n            ...c.i32_store8(\n                c.getLocal(\"p\"),\n                c.i32_const(b)\n            ),\n            ...c.setLocal(\n                \"p\",\n                c.i32_add(\n                    c.getLocal(\"p\"),\n                    c.i32_const(1)\n                )\n            )\n        ];\n    }\n\n    f.addCode(\n        c.if(\n            c.i32_eqz(c.getLocal(\"scalarLength\")),\n            [\n                ...c.call(opInit, c.getLocal(\"r\")),\n                ...c.ret([])\n            ]\n        ),\n        c.setLocal(\"nbits\", c.i32_shl(c.getLocal(\"scalarLength\"), c.i32_const(3))),\n        c.setLocal(\"old0\", c.i32_load(c.i32_const(0))),\n        c.setLocal(\"p\", c.getLocal(\"old0\")),\n        c.i32_store(\n            c.i32_const(0),\n            c.i32_and(\n                c.i32_add(\n                    c.i32_add(\n                        c.getLocal(\"old0\"),\n                        c.i32_const(32)\n                    ),\n                    c.getLocal(\"nbits\")\n                ),\n                c.i32_const(0xFFFFFFF8)\n            )\n        ),\n        c.setLocal(\"i\", c.i32_const(1)),\n\n        c.setLocal(\"last\",getBit(c.i32_const(0))),\n        c.setLocal(\"carry\",c.i32_const(0)),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq( c.getLocal(\"i\"), c.getLocal(\"nbits\"))),\n\n            c.setLocal(\"cur\", getBit(c.getLocal(\"i\"))),\n            c.if( c.getLocal(\"last\"),\n                c.if( c.getLocal(\"cur\"),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(1)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(255)\n                        ],\n                    ),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(255)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(1)\n                        ],\n                    ),\n                ),\n                c.if( c.getLocal(\"cur\"),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(0)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(1)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ],\n                    ),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(1)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ],\n                    ),\n                )\n            ),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        )),\n\n        c.if( c.getLocal(\"last\"),\n            c.if(c.getLocal(\"carry\"),\n                [\n                    ...pushBit(255),\n                    ...pushBit(0),\n                    ...pushBit(1)\n                ]\n                ,\n                [\n                    ...pushBit(1)\n                ],\n            ),\n            c.if(c.getLocal(\"carry\"),\n                [\n                    ...pushBit(0),\n                    ...pushBit(1)\n                ]\n            ),\n        ),\n\n        c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n\n        // p already points to the last bit\n\n        c.call(opCopy, c.getLocal(\"base\"), aux),\n\n        c.call(opInit, c.getLocal(\"r\")),\n\n        c.block(c.loop(\n\n\n            c.call(opAA, c.getLocal(\"r\"), c.getLocal(\"r\")),\n\n\n            c.setLocal(\"cur\",\n                c.i32_load8_u(\n                    c.getLocal(\"p\")\n                )\n            ),\n\n            c.if(\n                c.getLocal(\"cur\"),\n                c.if(\n                    c.i32_eq(c.getLocal(\"cur\"), c.i32_const(1)),\n                    c.call(opAB,  c.getLocal(\"r\"), aux, c.getLocal(\"r\")),\n                    c.call(opAmB, c.getLocal(\"r\"), aux, c.getLocal(\"r\")),\n                )\n            ),\n\n            c.br_if(1, c.i32_eq( c.getLocal(\"old0\"), c.getLocal(\"p\"))),\n            c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n            c.br(0)\n\n        )),\n\n        c.i32_store( c.i32_const(0), c.getLocal(\"old0\"))\n\n    );\n\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildMultiexp(module, prefix, fnName, opAdd, n8b) {\n\n    const n64g = module.modules[prefix].n64;\n    const n8g = n64g*8;\n\n    function buildGetChunk() {\n        const f = module.addFunction(fnName + \"_getChunk\");\n        f.addParam(\"pScalar\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of bytes of the scalar\n        f.addParam(\"startBit\", \"i32\");  // Bit to start extract\n        f.addParam(\"chunkSize\", \"i32\");  // Chunk size in bits\n        f.addLocal(\"bitsToEnd\", \"i32\");\n        f.addLocal(\"mask\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"bitsToEnd\",\n                c.i32_sub(\n                    c.i32_mul(\n                        c.getLocal(\"scalarSize\"),\n                        c.i32_const(8)\n                    ),\n                    c.getLocal(\"startBit\")\n                )\n            ),\n            c.if(\n                c.i32_gt_s(\n                    c.getLocal(\"chunkSize\"),\n                    c.getLocal(\"bitsToEnd\")\n                ),\n                c.setLocal(\n                    \"mask\",\n                    c.i32_sub(\n                        c.i32_shl(\n                            c.i32_const(1),\n                            c.getLocal(\"bitsToEnd\")\n                        ),\n                        c.i32_const(1)\n                    )\n                ),\n                c.setLocal(\n                    \"mask\",\n                    c.i32_sub(\n                        c.i32_shl(\n                            c.i32_const(1),\n                            c.getLocal(\"chunkSize\")\n                        ),\n                        c.i32_const(1)\n                    )\n                )\n            ),\n            c.i32_and(\n                c.i32_shr_u(\n                    c.i32_load(\n                        c.i32_add(\n                            c.getLocal(\"pScalar\"),\n                            c.i32_shr_u(\n                                c.getLocal(\"startBit\"),\n                                c.i32_const(3)\n                            )\n                        ),\n                        0,  // offset\n                        0   // align to byte.\n                    ),\n                    c.i32_and(\n                        c.getLocal(\"startBit\"),\n                        c.i32_const(0x7)\n                    )\n                ),\n                c.getLocal(\"mask\")\n            )\n        );\n    }\n\n    function buildMutiexpChunk() {\n        const f = module.addFunction(fnName + \"_chunk\");\n        f.addParam(\"pBases\", \"i32\");\n        f.addParam(\"pScalars\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of points\n        f.addParam(\"n\", \"i32\");  // Number of points\n        f.addParam(\"startBit\", \"i32\");  // bit where it starts the chunk\n        f.addParam(\"chunkSize\", \"i32\");  // bit where it starts the chunk\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"nChunks\", \"i32\");\n        f.addLocal(\"itScalar\", \"i32\");\n        f.addLocal(\"endScalar\", \"i32\");\n        f.addLocal(\"itBase\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"nTable\", \"i32\");\n        f.addLocal(\"pTable\", \"i32\");\n        f.addLocal(\"idx\", \"i32\");\n        f.addLocal(\"pIdxTable\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.i32_eqz(c.getLocal(\"n\")),\n                [\n                    ...c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            // Allocate memory\n\n            c.setLocal(\n                \"nTable\",\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.getLocal(\"chunkSize\")\n                )\n            ),\n            c.setLocal(\"pTable\", c.i32_load( c.i32_const(0) )),\n            c.i32_store(\n                c.i32_const(0),\n                c.i32_add(\n                    c.getLocal(\"pTable\"),\n                    c.i32_mul(\n                        c.getLocal(\"nTable\"),\n                        c.i32_const(n8g)\n                    )\n                )\n            ),\n\n            // Reset Table\n            c.setLocal(\"j\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"j\"),\n                        c.getLocal(\"nTable\")\n                    )\n                ),\n\n                c.call(\n                    prefix + \"_zero\",\n                    c.i32_add(\n                        c.getLocal(\"pTable\"),\n                        c.i32_mul(\n                            c.getLocal(\"j\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            // Distribute elements\n            c.setLocal(\"itBase\", c.getLocal(\"pBases\")),\n            c.setLocal(\"itScalar\", c.getLocal(\"pScalars\")),\n            c.setLocal(\"endScalar\",\n                c.i32_add(\n                    c.getLocal(\"pScalars\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.getLocal(\"scalarSize\")\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"itScalar\"),\n                        c.getLocal(\"endScalar\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx\",\n                    c.call(fnName + \"_getChunk\",\n                        c.getLocal(\"itScalar\"),\n                        c.getLocal(\"scalarSize\"),\n                        c.getLocal(\"startBit\"),\n                        c.getLocal(\"chunkSize\")\n                    )\n                ),\n\n                c.if(\n                    c.getLocal(\"idx\"),\n                    [\n                        ...c.setLocal(\n                            \"pIdxTable\",\n                            c.i32_add(\n                                c.getLocal(\"pTable\"),\n                                c.i32_mul(\n                                    c.i32_sub(\n                                        c.getLocal(\"idx\"),\n                                        c.i32_const(1)\n                                    ),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n                        ...c.call(\n                            opAdd,\n                            c.getLocal(\"pIdxTable\"),\n                            c.getLocal(\"itBase\"),\n                            c.getLocal(\"pIdxTable\"),\n                        )\n                    ]\n                ),\n\n                c.setLocal(\"itScalar\", c.i32_add(c.getLocal(\"itScalar\"), c.getLocal(\"scalarSize\"))),\n                c.setLocal(\"itBase\", c.i32_add(c.getLocal(\"itBase\"), c.i32_const(n8b))),\n                c.br(0)\n            )),\n\n            c.call(fnName + \"_reduceTable\", c.getLocal(\"pTable\"), c.getLocal(\"chunkSize\")),\n            c.call(\n                prefix + \"_copy\",\n                c.getLocal(\"pTable\"),\n                c.getLocal(\"pr\")\n            ),\n\n\n            c.i32_store(\n                c.i32_const(0),\n                c.getLocal(\"pTable\")\n            )\n\n        );\n    }\n\n    function buildMultiexp() {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pBases\", \"i32\");\n        f.addParam(\"pScalars\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of points\n        f.addParam(\"n\", \"i32\");  // Number of points\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"chunkSize\", \"i32\");\n        f.addLocal(\"nChunks\", \"i32\");\n        f.addLocal(\"itScalar\", \"i32\");\n        f.addLocal(\"endScalar\", \"i32\");\n        f.addLocal(\"itBase\", \"i32\");\n        f.addLocal(\"itBit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"nTable\", \"i32\");\n        f.addLocal(\"pTable\", \"i32\");\n        f.addLocal(\"idx\", \"i32\");\n        f.addLocal(\"pIdxTable\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8g));\n\n        const pTSizes = module.alloc([\n            17, 17, 17, 17,   17, 17, 17, 17,\n            17, 17, 16, 16,   15, 14, 13, 13,\n            12, 11, 10,  9,    8,  7,  7,  6,\n            5 ,  4,  3,  2,    1,  1,  1,  1\n        ]);\n\n        f.addCode(\n            c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n            c.if(\n                c.i32_eqz(c.getLocal(\"n\")),\n                c.ret([])\n            ),\n            c.setLocal(\"chunkSize\", c.i32_load8_u( c.i32_clz(c.getLocal(\"n\")),  pTSizes )),\n            c.setLocal(\n                \"nChunks\",\n                c.i32_add(\n                    c.i32_div_u(\n                        c.i32_sub(\n                            c.i32_shl(\n                                c.getLocal(\"scalarSize\"),\n                                c.i32_const(3)\n                            ),\n                            c.i32_const(1)\n                        ),\n                        c.getLocal(\"chunkSize\")\n                    ),\n                    c.i32_const(1)\n                )\n            ),\n\n\n            // Allocate memory\n\n            c.setLocal(\n                \"itBit\",\n                c.i32_mul(\n                    c.i32_sub(\n                        c.getLocal(\"nChunks\"),\n                        c.i32_const(1)\n                    ),\n                    c.getLocal(\"chunkSize\")\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_lt_s(\n                        c.getLocal(\"itBit\"),\n                        c.i32_const(0)\n                    )\n                ),\n\n                // Double nChunk times\n                c.if(\n                    c.i32_eqz(c.call(prefix + \"_isZero\", c.getLocal(\"pr\"))),\n                    [\n                        ...c.setLocal(\"j\", c.i32_const(0)),\n                        ...c.block(c.loop(\n                            c.br_if(\n                                1,\n                                c.i32_eq(\n                                    c.getLocal(\"j\"),\n                                    c.getLocal(\"chunkSize\")\n                                )\n                            ),\n\n                            c.call(prefix + \"_double\", c.getLocal(\"pr\"), c.getLocal(\"pr\")),\n\n                            c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                            c.br(0)\n                        ))\n                    ]\n                ),\n\n                c.call(\n                    fnName + \"_chunk\",\n                    c.getLocal(\"pBases\"),\n                    c.getLocal(\"pScalars\"),\n                    c.getLocal(\"scalarSize\"),\n                    c.getLocal(\"n\"),\n                    c.getLocal(\"itBit\"),\n                    c.getLocal(\"chunkSize\"),\n                    aux\n                ),\n\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"pr\"),\n                    aux,\n                    c.getLocal(\"pr\")\n                ),\n                c.setLocal(\"itBit\", c.i32_sub(c.getLocal(\"itBit\"), c.getLocal(\"chunkSize\"))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildReduceTable() {\n        const f = module.addFunction(fnName + \"_reduceTable\");\n        f.addParam(\"pTable\", \"i32\");\n        f.addParam(\"p\", \"i32\");  // Number of bits of the table\n        f.addLocal(\"half\", \"i32\");\n        f.addLocal(\"it1\", \"i32\");\n        f.addLocal(\"it2\", \"i32\");\n        f.addLocal(\"pAcc\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.i32_eq(c.getLocal(\"p\"), c.i32_const(1)),\n                c.ret([])\n            ),\n            c.setLocal(\n                \"half\",\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.i32_sub(\n                        c.getLocal(\"p\"),\n                        c.i32_const(1)\n                    )\n                )\n            ),\n\n            c.setLocal(\"it1\", c.getLocal(\"pTable\")),\n            c.setLocal(\n                \"it2\",\n                c.i32_add(\n                    c.getLocal(\"pTable\"),\n                    c.i32_mul(\n                        c.getLocal(\"half\"),\n                        c.i32_const(n8g)\n                    )\n                )\n            ),\n            c.setLocal(\"pAcc\",\n                c.i32_sub(\n                    c.getLocal(\"it2\"),\n                    c.i32_const(n8g)\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"it1\"),\n                        c.getLocal(\"pAcc\")\n                    )\n                ),\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"it1\"),\n                    c.getLocal(\"it2\"),\n                    c.getLocal(\"it1\")\n                ),\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"pAcc\"),\n                    c.getLocal(\"it2\"),\n                    c.getLocal(\"pAcc\")\n                ),\n                c.setLocal(\"it1\", c.i32_add(c.getLocal(\"it1\"), c.i32_const(n8g))),\n                c.setLocal(\"it2\", c.i32_add(c.getLocal(\"it2\"), c.i32_const(n8g))),\n                c.br(0)\n            )),\n\n            c.call(\n                fnName + \"_reduceTable\",\n                c.getLocal(\"pTable\"),\n                c.i32_sub(\n                    c.getLocal(\"p\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eqz(c.getLocal(\"p\"))),\n                c.call(prefix + \"_double\", c.getLocal(\"pAcc\"), c.getLocal(\"pAcc\")),\n                c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.call(prefix + \"_add\", c.getLocal(\"pTable\"), c.getLocal(\"pAcc\"), c.getLocal(\"pTable\"))\n        );\n    }\n\n    buildGetChunk();\n    buildReduceTable();\n    buildMutiexpChunk();\n    buildMultiexp();\n\n    module.exportFunction(fnName);\n    module.exportFunction(fnName +\"_chunk\");\n\n\n};\n\n\n\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildTimesScalarNAF = require(\"./build_timesscalarnaf\");\n//const buildTimesScalar = require(\"./build_timesscalar\");\nconst buildBatchConvertion = require(\"./build_batchconvertion\");\nconst buildMultiexp = require(\"./build_multiexp\");\n\nmodule.exports = function buildCurve(module, prefix, prefixField, pB) {\n\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {\n        n64: n64*3\n    };\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix + \"_isZero\");\n        f.addParam(\"p1\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_isZero\",\n            c.i32_add(\n                c.getLocal(\"p1\"),\n                c.i32_const(n8*2)\n            )\n        ));\n    }\n    function buildIsZeroAffine() {\n        const f = module.addFunction(prefix + \"_isZeroAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i32_and(\n                c.call(\n                    prefixField + \"_isZero\",\n                    c.getLocal(\"p1\")\n                ),\n                c.call(\n                    prefixField + \"_isZero\",\n                    c.i32_add(\n                        c.getLocal(\"p1\"),\n                        c.i32_const(n8)\n                    )\n                )\n            )\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix + \"_copy\");\n        f.addParam(\"ps\", \"i32\");\n        f.addParam(\"pd\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64*3; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pd\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"ps\"),\n                        i*8\n                    )\n                )\n            );\n        }\n    }\n\n\n    function buildCopyAffine() {\n        const f = module.addFunction(prefix + \"_copyAffine\");\n        f.addParam(\"ps\", \"i32\");\n        f.addParam(\"pd\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64*2; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pd\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"ps\"),\n                        i*8\n                    )\n                )\n            );\n        }\n\n    }\n\n\n    function buildZero() {\n        const f = module.addFunction(prefix + \"_zero\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.getLocal(\"pr\")\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_one\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8)\n            )\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8*2)\n            )\n        ));\n    }\n\n\n    function buildZeroAffine() {\n        const f = module.addFunction(prefix + \"_zeroAffine\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.getLocal(\"pr\")\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8)\n            )\n        ));\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix + \"_eq\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n        f.addLocal(\"z2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z2\", c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8*2))));\n        const z2 = c.getLocal(\"z2\");\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const Z2Z2 = c.i32_const(module.alloc(n8));\n        const U1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const Z2_cubed = c.i32_const(module.alloc(n8));\n        const S1 = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.ret( c.call(prefix + \"_isZero\", c.getLocal(\"p2\"))),\n            ),\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p2\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                c.ret(c.call(prefix + \"_eqMixed\", c.getLocal(\"p2\"), c.getLocal(\"p1\")))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z2),\n                c.ret(c.call(prefix + \"_eqMixed\", c.getLocal(\"p1\"), c.getLocal(\"p2\")))\n            ),\n\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_square\", z2, Z2Z2),\n            c.call(prefixField + \"_mul\", x1, Z2Z2, U1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", z2, Z2Z2, Z2_cubed),\n            c.call(prefixField + \"_mul\", y1, Z2_cubed, S1),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", U1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", S1, S2),\n                    c.ret(c.i32_const(1))\n                )\n            ),\n            c.ret(c.i32_const(0))\n        );\n    }\n\n\n    function buildEqMixed() {\n        const f = module.addFunction(prefix + \"_eqMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.ret( c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\"))),\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                c.ret(c.call(prefix + \"_eqAffine\", c.getLocal(\"p1\"), c.getLocal(\"p2\")))\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, S2),\n                    c.ret(c.i32_const(1))\n                )\n            ),\n            c.ret(c.i32_const(0))\n        );\n    }\n\n    function buildDouble() {\n        const f = module.addFunction(prefix + \"_double\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const A = c.i32_const(module.alloc(n8));\n        const B = c.i32_const(module.alloc(n8));\n        const C = c.i32_const(module.alloc(n8));\n        const D = c.i32_const(module.alloc(n8));\n        const E = c.i32_const(module.alloc(n8));\n        const F = c.i32_const(module.alloc(n8));\n        const G = c.i32_const(module.alloc(n8));\n        const eightC = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z),\n                [\n                    ...c.ret(c.call(prefix + \"_doubleAffine\", c.getLocal(\"p1\"), c.getLocal(\"pr\"))),\n                    ...c.ret([])\n                ]\n            ),\n\n            c.call(prefixField + \"_square\", x, A),\n            c.call(prefixField + \"_square\", y, B),\n            c.call(prefixField + \"_square\", B, C),\n\n            c.call(prefixField + \"_add\", x, B, D),\n            c.call(prefixField + \"_square\", D, D),\n            c.call(prefixField + \"_sub\", D, A, D),\n            c.call(prefixField + \"_sub\", D, C, D),\n            c.call(prefixField + \"_add\", D, D, D),\n\n            c.call(prefixField + \"_add\", A, A, E),\n            c.call(prefixField + \"_add\", E, A, E),\n            c.call(prefixField + \"_square\", E, F),\n\n            c.call(prefixField + \"_mul\", y, z, G),\n\n            c.call(prefixField + \"_add\", D, D, x3),\n            c.call(prefixField + \"_sub\", F, x3, x3),\n\n            c.call(prefixField + \"_add\", C, C, eightC),\n            c.call(prefixField + \"_add\", eightC, eightC, eightC),\n            c.call(prefixField + \"_add\", eightC, eightC, eightC),\n\n            c.call(prefixField + \"_sub\", D, x3, y3),\n            c.call(prefixField + \"_mul\", y3, E, y3),\n            c.call(prefixField + \"_sub\", y3, eightC, y3),\n\n            c.call(prefixField + \"_add\", G, G, z3),\n        );\n    }\n\n\n    function buildDoubleAffine() {\n        const f = module.addFunction(prefix + \"_doubleAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const XX = c.i32_const(module.alloc(n8));\n        const YY = c.i32_const(module.alloc(n8));\n        const YYYY = c.i32_const(module.alloc(n8));\n        const S = c.i32_const(module.alloc(n8));\n        const M = c.i32_const(module.alloc(n8));\n        const eightYYYY = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_toJacobian\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            // XX = X1^2\n            c.call(prefixField + \"_square\", x, XX),\n\n            // YY = Y1^2\n            c.call(prefixField + \"_square\", y, YY),\n\n            // YYYY = YY^2\n            c.call(prefixField + \"_square\", YY, YYYY),\n\n            // S = 2*((X1+YY)^2-XX-YYYY)\n            c.call(prefixField + \"_add\", x, YY, S),\n            c.call(prefixField + \"_square\", S, S),\n            c.call(prefixField + \"_sub\", S, XX, S),\n            c.call(prefixField + \"_sub\", S, YYYY, S),\n            c.call(prefixField + \"_add\", S, S, S),\n\n            // M = 3*XX+a  (Hera a=0)\n            c.call(prefixField + \"_add\", XX, XX, M),\n            c.call(prefixField + \"_add\", M, XX, M),\n\n            // Z3 = 2*Y1\n            c.call(prefixField + \"_add\", y, y, z3),\n\n            // T = M^2-2*S\n            // X3 = T\n            c.call(prefixField + \"_square\", M, x3),\n            c.call(prefixField + \"_sub\", x3, S, x3),\n            c.call(prefixField + \"_sub\", x3, S, x3),\n\n            // Y3 = M*(S-T)-8*YYYY\n            c.call(prefixField + \"_add\", YYYY, YYYY, eightYYYY),\n            c.call(prefixField + \"_add\", eightYYYY, eightYYYY, eightYYYY),\n            c.call(prefixField + \"_add\", eightYYYY, eightYYYY, eightYYYY),\n            c.call(prefixField + \"_sub\", S, x3, y3),\n            c.call(prefixField + \"_mul\", y3, M, y3),\n            c.call(prefixField + \"_sub\", y3, eightYYYY, y3),\n        );\n    }\n\n\n    function buildEqAffine() {\n        const f = module.addFunction(prefix + \"_eqAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.ret(c.i32_and(\n                c.call(\n                    prefixField + \"_eq\",\n                    c.getLocal(\"p1\"),\n                    c.getLocal(\"p2\")\n                ),\n                c.call(\n                    prefixField + \"_eq\",\n                    c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8)),\n                    c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8))\n                )\n            ))\n        );\n    }\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix + \"_toMontgomery\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_toMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<3; i++) {\n            f.addCode(c.call(\n                prefixField + \"_toMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildToMontgomeryAffine() {\n        const f = module.addFunction(prefix + \"_toMontgomeryAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_toMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<2; i++) {\n            f.addCode(c.call(\n                prefixField + \"_toMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix + \"_fromMontgomery\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_fromMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<3; i++) {\n            f.addCode(c.call(\n                prefixField + \"_fromMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n\n    function buildFromMontgomeryAffine() {\n        const f = module.addFunction(prefix + \"_fromMontgomeryAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_fromMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<2; i++) {\n            f.addCode(c.call(\n                prefixField + \"_fromMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildAdd() {\n\n        const f = module.addFunction(prefix + \"_add\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n        f.addLocal(\"z2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z2\", c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8*2))));\n        const z2 = c.getLocal(\"z2\");\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const Z2Z2 = c.i32_const(module.alloc(n8));\n        const U1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const Z2_cubed = c.i32_const(module.alloc(n8));\n        const S1 = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n        const H = c.i32_const(module.alloc(n8));\n        const S2_minus_S1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const S1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                [\n                    ...c.call(prefix + \"_addMixed\", x2, x1, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z2),\n                [\n                    ...c.call(prefix + \"_addMixed\", x1, x2, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_square\", z2, Z2Z2),\n            c.call(prefixField + \"_mul\", x1, Z2Z2, U1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", z2, Z2Z2, Z2_cubed),\n            c.call(prefixField + \"_mul\", y1, Z2_cubed, S1),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", U1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", S1, S2),\n                    [\n                        ...c.call(prefix + \"_double\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", U2, U1, H),\n            c.call(prefixField + \"_sub\", S2, S1, S2_minus_S1),\n            c.call(prefixField + \"_add\", H, H, I),\n            c.call(prefixField + \"_square\", I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", S2_minus_S1, S2_minus_S1, r),\n            c.call(prefixField + \"_mul\", U1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", S1, J, S1_J2),\n            c.call(prefixField + \"_add\", S1_J2, S1_J2, S1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, S1_J2, y3),\n\n            c.call(prefixField + \"_add\", z1, z2, z3),\n            c.call(prefixField + \"_square\", z3, z3),\n            c.call(prefixField + \"_sub\", z3, Z1Z1, z3),\n            c.call(prefixField + \"_sub\", z3, Z2Z2, z3),\n            c.call(prefixField + \"_mul\", z3, H, z3),\n        );\n\n    }\n\n\n    function buildAddMixed() {\n\n        const f = module.addFunction(prefix + \"_addMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n        const H = c.i32_const(module.alloc(n8));\n        const HH = c.i32_const(module.alloc(n8));\n        const S2_minus_y1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const y1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                [\n                    ...c.call(prefix + \"_addAffine\", x1, x2, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, S2),\n                    [\n                        ...c.call(prefix + \"_doubleAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", U2, x1, H),\n            c.call(prefixField + \"_sub\", S2, y1, S2_minus_y1),\n            c.call(prefixField + \"_square\", H, HH),\n            c.call(prefixField + \"_add\", HH , HH, I),\n            c.call(prefixField + \"_add\", I , I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", S2_minus_y1, S2_minus_y1, r),\n            c.call(prefixField + \"_mul\", x1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", y1, J, y1_J2),\n            c.call(prefixField + \"_add\", y1_J2, y1_J2, y1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, y1_J2, y3),\n\n            c.call(prefixField + \"_add\", z1, H, z3),\n            c.call(prefixField + \"_square\", z3, z3),\n            c.call(prefixField + \"_sub\", z3, Z1Z1, z3),\n            c.call(prefixField + \"_sub\", z3, HH, z3),\n        );\n    }\n\n\n    function buildAddAffine() {\n\n        const f = module.addFunction(prefix + \"_addAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const H = c.i32_const(module.alloc(n8));\n        const HH = c.i32_const(module.alloc(n8));\n        const y2_minus_y1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const y1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, x2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, y2),\n                    [\n                        ...c.call(prefix + \"_doubleAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", x2, x1, H),\n            c.call(prefixField + \"_sub\", y2, y1, y2_minus_y1),\n            c.call(prefixField + \"_square\", H, HH),\n            c.call(prefixField + \"_add\", HH , HH, I),\n            c.call(prefixField + \"_add\", I , I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", y2_minus_y1, y2_minus_y1, r),\n            c.call(prefixField + \"_mul\", x1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", y1, J, y1_J2),\n            c.call(prefixField + \"_add\", y1_J2, y1_J2, y1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, y1_J2, y3),\n\n            c.call(prefixField + \"_add\", H, H, z3),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix + \"_neg\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        f.addCode(\n            c.call(prefixField + \"_copy\", x, x3),\n            c.call(prefixField + \"_neg\", y, y3),\n            c.call(prefixField + \"_copy\", z, z3)\n        );\n    }\n\n\n    function buildNegAffine() {\n        const f = module.addFunction(prefix + \"_negAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n\n        f.addCode(\n            c.call(prefixField + \"_copy\", x, x3),\n            c.call(prefixField + \"_neg\", y, y3),\n        );\n    }\n\n\n    function buildSub() {\n        const f = module.addFunction(prefix + \"_sub\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_neg\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_add\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n    function buildSubMixed() {\n        const f = module.addFunction(prefix + \"_subMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_negAffine\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_addMixed\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n\n    function buildSubAffine() {\n        const f = module.addFunction(prefix + \"_subAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_negAffine\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_addAffine\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n    // This sets Z to One\n    function buildNormalize() {\n        const f = module.addFunction(prefix + \"_normalize\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n\n        const Z_inv = c.i32_const(module.alloc(n8));\n        const Z2_inv = c.i32_const(module.alloc(n8));\n        const Z3_inv = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                [\n                    ...c.call(prefixField + \"_inverse\", z, Z_inv),\n                    ...c.call(prefixField + \"_square\", Z_inv, Z2_inv),\n                    ...c.call(prefixField + \"_mul\", Z_inv, Z2_inv, Z3_inv),\n                    ...c.call(prefixField + \"_mul\", x, Z2_inv, x3),\n                    ...c.call(prefixField + \"_mul\", y, Z3_inv, y3),\n                    ...c.call(prefixField + \"_one\", z3),\n                ]\n            )\n        );\n    }\n\n\n    // Does not set Z.\n    function buildToAffine() {\n        const f = module.addFunction(prefix + \"_toAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n\n\n        const Z_inv = c.i32_const(module.alloc(n8));\n        const Z2_inv = c.i32_const(module.alloc(n8));\n        const Z3_inv = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefixField + \"_zero\", x3),\n                    ...c.call(prefixField + \"_zero\", y3),\n                ],\n                [\n                    ...c.call(prefixField + \"_inverse\", z, Z_inv),\n                    ...c.call(prefixField + \"_square\", Z_inv, Z2_inv),\n                    ...c.call(prefixField + \"_mul\", Z_inv, Z2_inv, Z3_inv),\n                    ...c.call(prefixField + \"_mul\", x, Z2_inv, x3),\n                    ...c.call(prefixField + \"_mul\", y, Z3_inv, y3),\n                ]\n            )\n        );\n    }\n\n\n    function buildToJacobian() {\n        const f = module.addFunction(prefix + \"_toJacobian\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                [\n                    ...c.call(prefixField + \"_one\", z3),\n                    ...c.call(prefixField + \"_copy\", y, y3),\n                    ...c.call(prefixField + \"_copy\", x, x3)\n                ]\n            )\n        );\n    }\n\n    function buildBatchToAffine() {\n        const f = module.addFunction(prefix + \"_batchToAffine\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"pAux\", \"i32\");\n        f.addLocal(\"itIn\", \"i32\");\n        f.addLocal(\"itAux\", \"i32\");\n        f.addLocal(\"itOut\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const tmp = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"pAux\", c.i32_load( c.i32_const(0) )),\n            c.i32_store(\n                c.i32_const(0),\n                c.i32_add(\n                    c.getLocal(\"pAux\"),\n                    c.i32_mul(c.getLocal(\"n\"), c.i32_const(n8))\n                )\n            ),\n\n            c.call(\n                prefixField + \"_batchInverse\",\n                c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8*2)),\n                c.i32_const(n8*3),\n                c.getLocal(\"n\"),\n                c.getLocal(\"pAux\"),\n                c.i32_const(n8)\n            ),\n\n            c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n            c.setLocal(\"itAux\", c.getLocal(\"pAux\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.if(\n                    c.call(prefixField + \"_isZero\", c.getLocal(\"itAux\")),\n                    [\n                        ...c.call(prefixField + \"_zero\", c.getLocal(\"itOut\")),\n                        ...c.call(prefixField + \"_zero\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8)))\n                    ],\n                    [\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            c.i32_add(c.getLocal(\"itIn\"), c.i32_const(n8)),\n                            tmp,\n                        ),\n                        ...c.call(\n                            prefixField+\"_square\",\n                            c.getLocal(\"itAux\"),\n                            c.getLocal(\"itAux\")\n                        ),\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            c.getLocal(\"itIn\"),\n                            c.getLocal(\"itOut\"),\n                        ),\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            tmp,\n                            c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8)),\n                        ),\n                    ]\n                ),\n\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(n8*3))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8*2))),\n                c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.i32_store(\n                c.i32_const(0),\n                c.getLocal(\"pAux\")\n            )\n        );\n    }\n\n\n    // This function is private and does not allow to OVERLAP buffers.\n    function buildReverseBytes() {\n        const f = module.addFunction(prefix + \"__reverseBytes\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"itOut\", \"i32\");\n        f.addLocal(\"itIn\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"itOut\",\n                c.i32_sub(\n                    c.i32_add(\n                        c.getLocal(\"pOut\"),\n                        c.getLocal(\"n\")\n                    ),\n                    c.i32_const(1)\n                )\n            ),\n            c.setLocal(\n                \"itIn\",\n                c.getLocal(\"pIn\")\n            ),\n            c.block(c.loop(\n                c.br_if(1, c.i32_lt_s( c.getLocal(\"itOut\"), c.getLocal(\"pOut\") )),\n                c.i32_store8(\n                    c.getLocal(\"itOut\"),\n                    c.i32_load8_u(c.getLocal(\"itIn\")),\n                ),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(1))),\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n\n    }\n\n    function buildLEMtoC() {\n        const f = module.addFunction(prefix + \"_LEMtoC\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const tmp = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"pIn\")),\n                [\n                    ...c.call(prefixField + \"_zero\", c.getLocal(\"pOut\")),\n                    ...c.i32_store8(\n                        c.getLocal(\"pOut\"),\n                        c.i32_const(0x40)\n                    ),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_fromMontgomery\", c.getLocal(\"pIn\"), tmp),\n            c.call(prefix + \"__reverseBytes\", tmp, c.i32_const(n8), c.getLocal(\"pOut\")),\n            c.if(\n                c.i32_eq(\n                    c.call(prefixField + \"_sign\", c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8))),\n                    c.i32_const(-1)\n                ),\n                c.i32_store8(\n                    c.getLocal(\"pOut\"),\n                    c.i32_or(\n                        c.i32_load8_u(c.getLocal(\"pOut\")),\n                        c.i32_const(0x80)\n                    )\n                )\n            ),\n        );\n    }\n\n    function buildLEMtoU() {\n        const f = module.addFunction(prefix + \"_LEMtoU\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmp = c.i32_const(pTmp);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"pIn\")),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            c.call(prefix + \"_fromMontgomeryAffine\", c.getLocal(\"pIn\"), tmp),\n\n            c.call(prefix + \"__reverseBytes\", tmpX, c.i32_const(n8), c.getLocal(\"pOut\")),\n            c.call(prefix + \"__reverseBytes\", tmpY, c.i32_const(n8), c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n        );\n    }\n\n    function buildUtoLEM() {\n        const f = module.addFunction(prefix + \"_UtoLEM\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmp = c.i32_const(pTmp);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.if(\n                c.i32_and(c.i32_load8_u(c.getLocal(\"pIn\")), c.i32_const(0x40)),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefix + \"__reverseBytes\", c.getLocal(\"pIn\"), c.i32_const(n8), tmpX),\n            c.call(prefix + \"__reverseBytes\", c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8)), c.i32_const(n8), tmpY),\n            c.call(prefix + \"_toMontgomeryAffine\", tmp,  c.getLocal(\"pOut\"))\n        );\n    }\n\n    function buildCtoLEM() {\n        const f = module.addFunction(prefix + \"_CtoLEM\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"firstByte\", \"i32\");\n        f.addLocal(\"greatest\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.setLocal(\"firstByte\", c.i32_load8_u(c.getLocal(\"pIn\"))),\n            c.if(\n                c.i32_and(\n                    c.getLocal(\"firstByte\"),\n                    c.i32_const(0x40)\n                ),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.setLocal(\n                \"greatest\",\n                c.i32_and(\n                    c.getLocal(\"firstByte\"),\n                    c.i32_const(0x80)\n                )\n            ),\n\n            c.call(prefixField + \"_copy\", c.getLocal(\"pIn\"), tmpY),\n            c.i32_store8(tmpY, c.i32_and(c.getLocal(\"firstByte\"), c.i32_const(0x3F))),\n            c.call(prefix + \"__reverseBytes\", tmpY, c.i32_const(n8), tmpX),\n            c.call(prefixField + \"_toMontgomery\", tmpX, c.getLocal(\"pOut\")),\n\n            c.call(prefixField + \"_square\", c.getLocal(\"pOut\"), tmpY),\n            c.call(prefixField + \"_mul\", c.getLocal(\"pOut\"), tmpY,  tmpY),\n            c.call(prefixField + \"_add\", tmpY, c.i32_const(pB),  tmpY),\n\n            c.call(prefixField + \"_sqrt\", tmpY, tmpY),\n            c.call(prefixField + \"_neg\", tmpY, tmpX),\n\n            c.if(\n                c.i32_eq(\n                    c.call(prefixField + \"_sign\", tmpY),\n                    c.i32_const(-1)\n                ),\n                c.if(\n                    c.getLocal(\"greatest\"),\n                    c.call(prefixField + \"_copy\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n                    c.call(prefixField + \"_neg\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8)))\n                ),\n                c.if(\n                    c.getLocal(\"greatest\"),\n                    c.call(prefixField + \"_neg\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n                    c.call(prefixField + \"_copy\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8)))\n                ),\n            )\n\n        );\n    }\n\n    function buildInCurveAffine() {\n        const f = module.addFunction(prefix + \"_inCurveAffine\");\n        f.addParam(\"pIn\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"pIn\");\n        const y = c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8));\n\n        const y2 = c.i32_const(module.alloc(n8));\n        const x3b = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefixField + \"_square\", y, y2),\n            c.call(prefixField + \"_square\", x, x3b),\n            c.call(prefixField + \"_mul\", x, x3b, x3b),\n            c.call(prefixField + \"_add\", x3b, c.i32_const(pB), x3b),\n\n            c.ret(\n                c.call(prefixField + \"_eq\", y2, x3b)\n            )\n        );\n    }\n\n    function buildInCurve() {\n        const f = module.addFunction(prefix + \"_inCurve\");\n        f.addParam(\"pIn\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8*2));\n\n        f.addCode(\n            c.call(prefix + \"_toAffine\", c.getLocal(\"pIn\"), aux),\n\n            c.ret(\n                c.call(prefix + \"_inCurveAffine\", aux),\n            )\n        );\n    }\n\n    buildIsZeroAffine();\n    buildIsZero();\n    buildZeroAffine();\n    buildZero();\n    buildCopyAffine();\n    buildCopy();\n    buildToJacobian();\n    buildEqAffine();\n    buildEqMixed();\n    buildEq();\n    buildDoubleAffine();\n    buildDouble();\n    buildAddAffine();\n    buildAddMixed();\n    buildAdd();\n    buildNegAffine();\n    buildNeg();\n    buildSubAffine();\n    buildSubMixed();\n    buildSub();\n    buildFromMontgomeryAffine();\n    buildFromMontgomery();\n    buildToMontgomeryAffine();\n    buildToMontgomery();\n    buildToAffine();\n    buildInCurveAffine();\n    buildInCurve();\n\n    buildBatchToAffine();\n\n    buildNormalize();\n\n\n    buildReverseBytes();\n\n    buildLEMtoU();\n    buildLEMtoC();\n    buildUtoLEM();\n    buildCtoLEM();\n\n    buildBatchConvertion(module, prefix + \"_batchLEMtoU\", prefix + \"_LEMtoU\", n8*2, n8*2);\n    buildBatchConvertion(module, prefix + \"_batchLEMtoC\", prefix + \"_LEMtoC\", n8*2, n8);\n    buildBatchConvertion(module, prefix + \"_batchUtoLEM\", prefix + \"_UtoLEM\", n8*2, n8*2);\n    buildBatchConvertion(module, prefix + \"_batchCtoLEM\", prefix + \"_CtoLEM\", n8, n8*2, true);\n\n    buildBatchConvertion(module, prefix + \"_batchToJacobian\", prefix + \"_toJacobian\", n8*2, n8*3, true);\n\n    buildMultiexp(module, prefix, prefix + \"_multiexp\", prefix + \"_add\", n8*3);\n    buildMultiexp(module, prefix, prefix + \"_multiexpAffine\", prefix + \"_addMixed\", n8*2);\n\n    /*\n    buildTimesScalar(\n        module,\n        prefix + \"_timesScalarOld\",\n        n8*3,\n        prefix + \"_add\",\n        prefix + \"_double\",\n        prefix + \"_copy\",\n        prefix + \"_zero\",\n    );\n    */\n    buildTimesScalarNAF(\n        module,\n        prefix + \"_timesScalar\",\n        n8*3,\n        prefix + \"_add\",\n        prefix + \"_double\",\n        prefix + \"_sub\",\n        prefix + \"_copy\",\n        prefix + \"_zero\"\n    );\n\n    buildTimesScalarNAF(\n        module,\n        prefix + \"_timesScalarAffine\",\n        n8*2,\n        prefix + \"_addMixed\",\n        prefix + \"_double\",\n        prefix + \"_subMixed\",\n        prefix + \"_copyAffine\",\n        prefix + \"_zero\"\n    );\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isZeroAffine\");\n\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_eqMixed\");\n    module.exportFunction(prefix + \"_eqAffine\");\n\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_copyAffine\");\n\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_zeroAffine\");\n\n    module.exportFunction(prefix + \"_double\");\n    module.exportFunction(prefix + \"_doubleAffine\");\n\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_addMixed\");\n    module.exportFunction(prefix + \"_addAffine\");\n\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_negAffine\");\n\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_subMixed\");\n    module.exportFunction(prefix + \"_subAffine\");\n\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_fromMontgomeryAffine\");\n\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomeryAffine\");\n\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_timesScalarAffine\");\n\n    module.exportFunction(prefix + \"_normalize\");\n\n    // Convertion functions\n    module.exportFunction(prefix + \"_LEMtoU\");\n    module.exportFunction(prefix + \"_LEMtoC\");\n    module.exportFunction(prefix + \"_UtoLEM\");\n    module.exportFunction(prefix + \"_CtoLEM\");\n\n    module.exportFunction(prefix + \"_batchLEMtoU\");\n    module.exportFunction(prefix + \"_batchLEMtoC\");\n    module.exportFunction(prefix + \"_batchUtoLEM\");\n    module.exportFunction(prefix + \"_batchCtoLEM\");\n\n    module.exportFunction(prefix + \"_toAffine\");\n    module.exportFunction(prefix + \"_toJacobian\");\n\n    module.exportFunction(prefix + \"_batchToAffine\");\n    module.exportFunction(prefix + \"_batchToJacobian\");\n\n    module.exportFunction(prefix + \"_inCurve\");\n    module.exportFunction(prefix + \"_inCurveAffine\");\n\n    /*\n    buildG1MulScalar(module, zq);\n    module.exportFunction(\"g1MulScalar\");\n    */\n\n    return prefix;\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { isOdd, modInv, modPow } = require(\"./bigint.js\");\nconst utils = require(\"./utils.js\");\n\nmodule.exports = function buildFFT(module, prefix, gPrefix, fPrefix, opGtimesF) {\n\n    const n64f = module.modules[fPrefix].n64;\n    const n8f = n64f*8;\n\n    const n64g = module.modules[gPrefix].n64;\n    const n8g = n64g*8;\n\n    const q = module.modules[fPrefix].q;\n\n    let rem = q - 1n;\n    let maxBits = 0;\n    while (!isOdd(rem)) {\n        maxBits ++;\n        rem = rem >> 1n;\n    }\n\n    let nr = 2n;\n\n    while ( modPow(nr, q >> 1n, q) === 1n ) nr = nr + 1n;\n\n    // console.log(nr);\n\n    const w = new Array(maxBits+1);\n    w[maxBits] = modPow(nr, rem, q);\n\n    let n=maxBits-1;\n    while (n>=0) {\n        w[n] = modPow(w[n+1], 2n, q);\n        n--;\n    }\n\n    const bytes = [];\n    const R = (1n << BigInt(n8f*8)) % q;\n\n    for (let i=0; i<w.length; i++) {\n        const m = w[i] * R % q;\n        bytes.push(...utils.bigInt2BytesLE(m, n8f));\n    }\n\n    const ROOTs = module.alloc(bytes);\n\n    const i2 = new Array(maxBits+1);\n    i2[0] = 1n;\n\n    for (let i=1; i<=maxBits; i++) {\n        i2[i] = i2[i-1] * 2n;\n    }\n\n    const bytesi2 =[];\n    for (let i=0; i<=maxBits; i++) {\n        const m = modInv(i2[i], q) * R % q;\n        bytesi2.push(...utils.bigInt2BytesLE(m, n8f));\n    }\n\n    const INV2 = module.alloc(bytesi2);\n\n    const shift = modPow(nr, 2n, q);\n    const bytesShiftToSmallM =[];\n    const bytesSConst =[];\n    for (let i=0; i<=maxBits; i++) {\n        const shiftToSmallM = modPow(shift, 2n ** BigInt(i), q);\n        const sConst = modInv(q + 1n - shiftToSmallM, q);\n        bytesShiftToSmallM.push(...utils.bigInt2BytesLE(shiftToSmallM * R % q, n8f));\n        bytesSConst.push(...utils.bigInt2BytesLE(sConst * R % q, n8f));\n    }\n\n    const SHIFT_TO_M = module.alloc( bytesShiftToSmallM  );\n    const SCONST = module.alloc( bytesSConst  );\n\n    function rev(x) {\n        let r=0;\n        for (let i=0; i<8; i++) {\n            if (x & (1 << i)) {\n                r = r | (0x80 >> i);\n            }\n        }\n        return r;\n    }\n\n    const rtable = Array(256);\n    for (let i=0; i<256; i++) {\n        rtable[i] = rev(i);\n    }\n\n    const REVTABLE = module.alloc(rtable);\n\n\n    function buildLog2() {\n        const f = module.addFunction(prefix+\"__log2\");\n        f.addParam(\"n\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"bits\", \"i32\");\n        f.addLocal(\"aux\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"aux\",\n                c.i32_shr_u(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                )\n            )\n        );\n        f.addCode(c.setLocal(\"bits\", c.i32_const(0)));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i32_eqz(c.getLocal(\"aux\"))\n            ),\n\n            c.setLocal(\n                \"aux\",\n                c.i32_shr_u(\n                    c.getLocal(\"aux\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.setLocal(\n                \"bits\",\n                c.i32_add(\n                    c.getLocal(\"bits\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.br(0)\n        )));\n\n        f.addCode(c.if(\n            c.i32_ne(\n                c.getLocal(\"n\"),\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.getLocal(\"bits\")\n                )\n            ),\n            c.unreachable()\n        ));\n\n        f.addCode(c.if(\n            c.i32_gt_u(\n                c.getLocal(\"bits\"),\n                c.i32_const(maxBits)\n            ),\n            c.unreachable()\n        ));\n\n        f.addCode(c.getLocal(\"bits\"));\n    }\n\n    function buildFFT() {\n        const f = module.addFunction(prefix+\"_fft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n\n        f.addLocal(\"bits\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const One = c.i32_const(module.alloc(n8f));\n\n        f.addCode(\n            c.setLocal(\n                \"bits\",\n                c.call(\n                    prefix + \"__log2\",\n                    c.getLocal(\"n\")\n                )\n            ),\n            c.call(fPrefix + \"_one\", One),\n            c.call(\n                prefix+\"_rawfft\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.i32_const(0),\n                One\n            )\n        );\n\n    }\n\n    function buildIFFT() {\n        const f = module.addFunction(prefix+\"_ifft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addLocal(\"bits\", \"i32\");\n        f.addLocal(\"pInv2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"bits\",\n                c.call(\n                    prefix + \"__log2\",\n                    c.getLocal(\"n\")\n                )\n            ),\n            c.setLocal(\n                \"pInv2\",\n                c.i32_add(\n                    c.i32_const(INV2),\n                    c.i32_mul(\n                        c.getLocal(\"bits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n            c.call(\n                prefix+\"_rawfft\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.i32_const(1),\n                c.getLocal(\"pInv2\")\n            ),\n        );\n    }\n\n    function buildRawFFT() {\n        const f = module.addFunction(prefix+\"_rawfft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\"); // 2 power\n        f.addParam(\"reverse\", \"i32\");\n        f.addParam(\"mulFactor\", \"i32\");\n\n        f.addLocal(\"s\", \"i32\");\n        f.addLocal(\"k\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"mdiv2\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"pwm\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.call(prefix + \"__reversePermutation\", c.getLocal(\"px\"), c.getLocal(\"bits\")),\n            c.setLocal(\"n\", c.i32_shl(c.i32_const(1), c.getLocal(\"bits\"))),\n            c.setLocal(\"s\", c.i32_const(1)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_gt_u(\n                        c.getLocal(\"s\"),\n                        c.getLocal(\"bits\")\n                    )\n                ),\n                c.setLocal(\"m\", c.i32_shl(c.i32_const(1), c.getLocal(\"s\"))),\n                c.setLocal(\"pwm\",\n                    c.i32_add(\n                        c.i32_const(ROOTs),\n                        c.i32_mul(\n                            c.getLocal(\"s\"),\n                            c.i32_const(n8f)\n                        )\n                    )\n                ),\n                c.setLocal(\"k\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_ge_u(\n                            c.getLocal(\"k\"),\n                            c.getLocal(\"n\")\n                        )\n                    ),\n\n                    c.call(fPrefix + \"_one\", W),\n\n                    c.setLocal(\"mdiv2\", c.i32_shr_u(c.getLocal(\"m\"), c.i32_const(1)) ),\n                    c.setLocal(\"j\", c.i32_const(0)),\n                    c.block(c.loop(\n                        c.br_if(\n                            1,\n                            c.i32_ge_u(\n                                c.getLocal(\"j\"),\n                                c.getLocal(\"mdiv2\")\n                            )\n                        ),\n\n                        c.setLocal(\n                            \"idx1\",\n                            c.i32_add(\n                                c.getLocal(\"px\"),\n                                c.i32_mul(\n                                    c.i32_add(\n                                        c.getLocal(\"k\"),\n                                        c.getLocal(\"j\")\n                                    ),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n\n                        c.setLocal(\n                            \"idx2\",\n                            c.i32_add(\n                                c.getLocal(\"idx1\"),\n                                c.i32_mul(\n                                    c.getLocal(\"mdiv2\"),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n\n                        c.call(\n                            opGtimesF,\n                            c.getLocal(\"idx2\"),\n                            W,\n                            T\n                        ),\n\n                        c.call(\n                            gPrefix + \"_copy\",\n                            c.getLocal(\"idx1\"),\n                            U\n                        ),\n\n                        c.call(\n                            gPrefix + \"_add\",\n                            U,\n                            T,\n                            c.getLocal(\"idx1\"),\n                        ),\n\n                        c.call(\n                            gPrefix + \"_sub\",\n                            U,\n                            T,\n                            c.getLocal(\"idx2\"),\n                        ),\n\n                        c.call(\n                            fPrefix + \"_mul\",\n                            W,\n                            c.getLocal(\"pwm\"),\n                            W,\n                        ),\n\n                        c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                        c.br(0)\n                    )),\n\n                    c.setLocal(\"k\", c.i32_add(c.getLocal(\"k\"), c.getLocal(\"m\"))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"s\", c.i32_add(c.getLocal(\"s\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.call(\n                prefix + \"__fftFinal\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.getLocal(\"reverse\"),\n                c.getLocal(\"mulFactor\")\n            )\n        );\n    }\n\n\n    function buildFinalInverse() {\n        const f = module.addFunction(prefix+\"__fftFinal\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.addParam(\"reverse\", \"i32\");\n        f.addParam(\"mulFactor\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"ndiv2\", \"i32\");\n        f.addLocal(\"pInv2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"mask\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.if(\n                c.i32_and(\n                    c.i32_eqz(c.getLocal(\"reverse\")),\n                    c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\"))\n                ),\n                c.ret([])\n            ),\n            c.setLocal(\"n\", c.i32_shl( c.i32_const(1), c.getLocal(\"bits\"))),\n\n            c.setLocal(\"mask\", c.i32_sub( c.getLocal(\"n\") , c.i32_const(1))),\n            c.setLocal(\"i\", c.i32_const(1)),\n            c.setLocal(\n                \"ndiv2\",\n                c.i32_shr_u(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_ge_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ndiv2\")\n                    )\n                ),\n\n                c.setLocal(\"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.getLocal(\"n\"),\n                                c.getLocal(\"i\")\n                            ),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.if(\n                    c.getLocal(\"reverse\"),\n                    c.if(\n                        c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                        [\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx2\") , c.getLocal(\"idx1\") ),\n                            ...c.call(gPrefix + \"_copy\", T , c.getLocal(\"idx2\")),\n                        ],\n                        [\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                            ...c.call(opGtimesF , c.getLocal(\"idx2\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx1\") ),\n                            ...c.call(opGtimesF , T , c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\")),\n                        ]\n                    ),\n                    c.if(\n                        c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                        [\n                            // Do nothing (It should not be here)\n                        ],\n                        [\n                            ...c.call(opGtimesF , c.getLocal(\"idx1\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx1\") ),\n                            ...c.call(opGtimesF , c.getLocal(\"idx2\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\")),\n                        ]\n                    )\n                ),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n\n                c.br(0)\n            )),\n\n            c.if(\n                c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                [\n                    // Do nothing (It should not be here)\n                ],\n                [\n                    ...c.call(opGtimesF, c.getLocal(\"px\") , c.getLocal(\"mulFactor\"), c.getLocal(\"px\")),\n                    ...c.setLocal(\"idx2\",\n                        c.i32_add(\n                            c.getLocal(\"px\"),\n                            c.i32_mul(\n                                c.getLocal(\"ndiv2\"),\n                                c.i32_const(n8g)\n                            )\n                        )\n                    ),\n                    ...c.call(opGtimesF, c.getLocal(\"idx2\"),c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\"))\n                ]\n            )\n        );\n    }\n\n    function buildReversePermutation() {\n        const f = module.addFunction(prefix+\"__reversePermutation\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"ri\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"n\", c.i32_shl( c.i32_const(1), c.getLocal(\"bits\"))),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"ri\", c.call(prefix + \"__rev\", c.getLocal(\"i\"), c.getLocal(\"bits\"))),\n\n                c.setLocal(\"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"ri\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.if(\n                    c.i32_lt_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ri\")\n                    ),\n                    [\n                        ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                        ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx2\") , c.getLocal(\"idx1\")),\n                        ...c.call(gPrefix + \"_copy\", T , c.getLocal(\"idx2\"))\n                    ]\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildRev() {\n        const f = module.addFunction(prefix+\"__rev\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i32_rotl(\n                c.i32_add(\n                    c.i32_add(\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.getLocal(\"x\"),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(24)\n                        ),\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.i32_shr_u(\n                                        c.getLocal(\"x\"),\n                                        c.i32_const(8)\n                                    ),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(16)\n                        ),\n                    ),\n                    c.i32_add(\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.i32_shr_u(\n                                        c.getLocal(\"x\"),\n                                        c.i32_const(16)\n                                    ),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(8)\n                        ),\n                        c.i32_load8_u(\n                            c.i32_and(\n                                c.i32_shr_u(\n                                    c.getLocal(\"x\"),\n                                    c.i32_const(24)\n                                ),\n                                c.i32_const(0xFF)\n                            ),\n                            REVTABLE,\n                            0\n                        ),\n                    )\n                ),\n                c.getLocal(\"bits\")\n            )\n        );\n    }\n\n\n    function buildFFTJoin() {\n        const f = module.addFunction(prefix+\"_fftJoin\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    T\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    c.getLocal(\"idx1\"),\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    U,\n                    T,\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    U,\n                    T,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W,\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    function buildFFTJoinExt() {\n        const f = module.addFunction(prefix+\"_fftJoinExt\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    U\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"pShiftToM\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    U,\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildFFTJoinExtInv() {\n        const f = module.addFunction(prefix+\"_fftJoinExtInv\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n        f.addLocal(\"pSConst\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"pSConst\",\n                c.i32_add(\n                    c.i32_const(SCONST),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx1\"),\n                    U,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pShiftToM\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    U,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n\n    function buildPrepareLagrangeEvaluation() {\n        const f = module.addFunction(prefix+\"_prepareLagrangeEvaluation\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n        f.addLocal(\"pSConst\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"pSConst\",\n                c.i32_add(\n                    c.i32_const(SCONST),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pShiftToM\"),\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx2\"),\n                    U,\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    U,\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildFFTMix() {\n        const f = module.addFunction(prefix+\"_fftMix\");\n        f.addParam(\"pBuff\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"exp\", \"i32\");\n        f.addLocal(\"nGroups\", \"i32\");\n        f.addLocal(\"nPerGroup\", \"i32\");\n        f.addLocal(\"nPerGroupDiv2\", \"i32\");\n        f.addLocal(\"pairOffset\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"pwm\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"nPerGroup\", c.i32_shl(c.i32_const(1), c.getLocal(\"exp\"))),\n            c.setLocal(\"nPerGroupDiv2\", c.i32_shr_u(c.getLocal(\"nPerGroup\"), c.i32_const(1))),\n            c.setLocal(\"nGroups\", c.i32_shr_u(c.getLocal(\"n\"), c.getLocal(\"exp\"))),\n            c.setLocal(\"pairOffset\", c.i32_mul(c.getLocal(\"nPerGroupDiv2\"), c.i32_const(n8g))),\n            c.setLocal(\"pwm\",\n                c.i32_add(\n                    c.i32_const(ROOTs),\n                    c.i32_mul(\n                        c.getLocal(\"exp\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"nGroups\")\n                    )\n                ),\n                c.call( fPrefix + \"_one\", W),\n                c.setLocal(\"j\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_eq(\n                            c.getLocal(\"j\"),\n                            c.getLocal(\"nPerGroupDiv2\")\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"idx1\",\n                        c.i32_add(\n                            c.getLocal(\"pBuff\"),\n                            c.i32_mul(\n                                c.i32_add(\n                                    c.i32_mul(\n                                        c.getLocal(\"i\"),\n                                        c.getLocal(\"nPerGroup\")\n                                    ),\n                                    c.getLocal(\"j\")\n                                ),\n                                c.i32_const(n8g)\n                            )\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"idx2\",\n                        c.i32_add(\n                            c.getLocal(\"idx1\"),\n                            c.getLocal(\"pairOffset\")\n                        )\n                    ),\n\n                    c.call(\n                        opGtimesF,\n                        c.getLocal(\"idx2\"),\n                        W,\n                        T\n                    ),\n\n                    c.call(\n                        gPrefix + \"_copy\",\n                        c.getLocal(\"idx1\"),\n                        U\n                    ),\n\n                    c.call(\n                        gPrefix + \"_add\",\n                        U,\n                        T,\n                        c.getLocal(\"idx1\"),\n                    ),\n\n                    c.call(\n                        gPrefix + \"_sub\",\n                        U,\n                        T,\n                        c.getLocal(\"idx2\"),\n                    ),\n\n                    c.call(\n                        fPrefix + \"_mul\",\n                        W,\n                        c.getLocal(\"pwm\"),\n                        W,\n                    ),\n                    c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    // Reverse all and multiply by factor\n    function buildFFTFinal() {\n        const f = module.addFunction(prefix+\"_fftFinal\");\n        f.addParam(\"pBuff\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"factor\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"ndiv2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"ndiv2\", c.i32_shr_u(c.getLocal(\"n\"), c.i32_const(1))),\n            c.if(\n                c.i32_and(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                ),\n                c.call(\n                    opGtimesF,\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"ndiv2\"),\n                            c.i32_const(n8g)\n                        )\n                    ),\n                    c.getLocal(\"factor\"),\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"ndiv2\"),\n                            c.i32_const(n8g)\n                        )\n                    ),\n                ),\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_ge_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ndiv2\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.i32_sub(\n                                    c.getLocal(\"n\"),\n                                    c.i32_const(1)\n                                ),\n                                c.getLocal(\"i\")\n                            ),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"factor\"),\n                    T\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"factor\"),\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    T,\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    buildRev();\n    buildReversePermutation();\n    buildFinalInverse();\n    buildRawFFT();\n    buildLog2();\n    buildFFT();\n    buildIFFT();\n    buildFFTJoin();\n    buildFFTJoinExt();\n    buildFFTJoinExtInv();\n    buildFFTMix();\n    buildFFTFinal();\n    buildPrepareLagrangeEvaluation();\n\n    module.exportFunction(prefix+\"_fft\");\n    module.exportFunction(prefix+\"_ifft\");\n    module.exportFunction(prefix+\"_rawfft\");\n    module.exportFunction(prefix+\"_fftJoin\");\n    module.exportFunction(prefix+\"_fftJoinExt\");\n    module.exportFunction(prefix+\"_fftJoinExtInv\");\n    module.exportFunction(prefix+\"_fftMix\");\n    module.exportFunction(prefix+\"_fftFinal\");\n    module.exportFunction(prefix+\"_prepareLagrangeEvaluation\");\n\n};\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildPol(module, prefix, prefixField) {\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addLocal(\"lastp\", \"i32\");\n        f.addLocal(\"p\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"p\", c.getLocal(\"px\")),\n            c.setLocal(\n                \"lastp\",\n                c.i32_add(\n                    c.getLocal(\"px\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"p\"),\n                        c.getLocal(\"lastp\")\n                    )\n                ),\n                c.call(prefixField + \"_zero\", c.getLocal(\"p\")),\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildConstructLC() {\n        const f = module.addFunction(prefix+\"_constructLC\");\n        f.addParam(\"ppolynomials\", \"i32\");\n        f.addParam(\"psignals\", \"i32\");\n        f.addParam(\"nSignals\", \"i32\");\n        f.addParam(\"pres\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"pp\", \"i32\");\n        f.addLocal(\"ps\", \"i32\");\n        f.addLocal(\"pd\", \"i32\");\n        f.addLocal(\"ncoefs\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.setLocal(\"pp\", c.getLocal(\"ppolynomials\")),\n            c.setLocal(\"ps\", c.getLocal(\"psignals\")),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"nSignals\")\n                    )\n                ),\n\n                c.setLocal(\"ncoefs\", c.i32_load(c.getLocal(\"pp\"))),\n                c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(4))),\n\n                c.setLocal(\"j\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_eq(\n                            c.getLocal(\"j\"),\n                            c.getLocal(\"ncoefs\")\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"pd\",\n                        c.i32_add(\n                            c.getLocal(\"pres\"),\n                            c.i32_mul(\n                                c.i32_load(c.getLocal(\"pp\")),\n                                c.i32_const(n8)\n                            )\n                        )\n                    ),\n\n                    c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(4))),\n\n\n                    c.call(\n                        prefixField + \"_mul\",\n                        c.getLocal(\"ps\"),\n                        c.getLocal(\"pp\"),\n                        aux\n                    ),\n\n                    c.call(\n                        prefixField + \"_add\",\n                        aux,\n                        c.getLocal(\"pd\"),\n                        c.getLocal(\"pd\")\n                    ),\n\n                    c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(n8))),\n                    c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"ps\", c.i32_add(c.getLocal(\"ps\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n    }\n\n    buildZero();\n    buildConstructLC();\n\n\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_constructLC\");\n\n    return prefix;\n\n\n\n\n};\n","\nmodule.exports = function buildQAP(module, prefix, prefixField) {\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n\n    function buildBuildABC() {\n        const f = module.addFunction(prefix+\"_buildABC\");\n        f.addParam(\"pCoefs\", \"i32\");\n        f.addParam(\"nCoefs\", \"i32\");\n        f.addParam(\"pWitness\", \"i32\");\n        f.addParam(\"pA\", \"i32\");\n        f.addParam(\"pB\", \"i32\");\n        f.addParam(\"pC\", \"i32\");\n        f.addParam(\"offsetOut\", \"i32\");\n        f.addParam(\"nOut\", \"i32\");\n        f.addParam(\"offsetWitness\", \"i32\");\n        f.addParam(\"nWitness\", \"i32\");\n        f.addLocal(\"it\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"c\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.addLocal(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n\n            // Set output a and b to 0\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"nOut\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(prefixField + \"_zero\", c.getLocal(\"ita\")),\n                c.call(prefixField + \"_zero\", c.getLocal(\"itb\")),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n\n            c.setLocal(\"it\", c.getLocal(\"pCoefs\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pCoefs\"),\n                    c.i32_mul(\n                        c.getLocal(\"nCoefs\"),\n                        c.i32_const(n8+12)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"it\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.setLocal(\n                    \"s\",\n                    c.i32_load(c.getLocal(\"it\"), 8)\n                ),\n                c.if(\n                    c.i32_or(\n                        c.i32_lt_u(\n                            c.getLocal(\"s\"),\n                            c.getLocal(\"offsetWitness\"),\n                        ),\n                        c.i32_ge_u(\n                            c.getLocal(\"s\"),\n                            c.i32_add(\n                                c.getLocal(\"offsetWitness\"),\n                                c.getLocal(\"nWitness\"),\n                            )\n                        )\n                    ),\n                    [\n                        ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                        ...c.br(1)\n                    ]\n                ),\n\n                c.setLocal(\n                    \"m\",\n                    c.i32_load(c.getLocal(\"it\"))\n                ),\n                c.if(\n                    c.i32_eq(c.getLocal(\"m\"), c.i32_const(0)),\n                    c.setLocal(\"pOut\", c.getLocal(\"pA\")),\n                    c.if(\n                        c.i32_eq(c.getLocal(\"m\"), c.i32_const(1)),\n                        c.setLocal(\"pOut\", c.getLocal(\"pB\")),\n                        [\n                            ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                            ...c.br(1)\n                        ]\n                    )\n                ),\n                c.setLocal(\n                    \"c\",\n                    c.i32_load(c.getLocal(\"it\"), 4)\n                ),\n                c.if(\n                    c.i32_or(\n                        c.i32_lt_u(\n                            c.getLocal(\"c\"),\n                            c.getLocal(\"offsetOut\"),\n                        ),\n                        c.i32_ge_u(\n                            c.getLocal(\"c\"),\n                            c.i32_add(\n                                c.getLocal(\"offsetOut\"),\n                                c.getLocal(\"nOut\"),\n                            )\n                        )\n                    ),\n                    [\n                        ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                        ...c.br(1)\n                    ]\n                ),\n                c.setLocal(\n                    \"pOut\",\n                    c.i32_add(\n                        c.getLocal(\"pOut\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.getLocal(\"c\"),\n                                c.getLocal(\"offsetOut\")\n                            ),\n                            c.i32_const(n8)\n                        )\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.i32_add(\n                        c.getLocal(\"pWitness\"),\n                        c.i32_mul(\n                            c.i32_sub(c.getLocal(\"s\"), c.getLocal(\"offsetWitness\")),\n                            c.i32_const(n8)\n                        )\n                    ),\n                    c.i32_add( c.getLocal(\"it\"), c.i32_const(12)),\n                    aux\n                ),\n                c.call(\n                    prefixField + \"_add\",\n                    c.getLocal(\"pOut\"),\n                    aux,\n                    c.getLocal(\"pOut\"),\n                ),\n                c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                c.br(0)\n            )),\n\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\"it\", c.getLocal(\"pC\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"nOut\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    c.getLocal(\"it\")\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n        );\n    }\n\n    function buildJoinABC() {\n        const f = module.addFunction(prefix+\"_joinABC\");\n        f.addParam(\"pA\", \"i32\");\n        f.addParam(\"pB\", \"i32\");\n        f.addParam(\"pC\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pP\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"itc\", \"i32\");\n        f.addLocal(\"itp\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\"itc\", c.getLocal(\"pC\")),\n            c.setLocal(\"itp\", c.getLocal(\"pP\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    aux\n                ),\n                c.call(\n                    prefixField + \"_sub\",\n                    aux,\n                    c.getLocal(\"itc\"),\n                    c.getLocal(\"itp\"),\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"itc\", c.i32_add(c.getLocal(\"itc\"), c.i32_const(n8))),\n                c.setLocal(\"itp\", c.i32_add(c.getLocal(\"itp\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildBatchAdd() {\n        const f = module.addFunction(prefix+\"_batchAdd\");\n        f.addParam(\"pa\", \"i32\");\n        f.addParam(\"pb\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"itr\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"ita\", c.getLocal(\"pa\")),\n            c.setLocal(\"itb\", c.getLocal(\"pb\")),\n            c.setLocal(\"itr\", c.getLocal(\"pr\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pa\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_add\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    c.getLocal(\"itr\"),\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"itr\", c.i32_add(c.getLocal(\"itr\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    buildBuildABC();\n    buildJoinABC();\n    buildBatchAdd();\n\n    module.exportFunction(prefix + \"_buildABC\");\n    module.exportFunction(prefix + \"_joinABC\");\n    module.exportFunction(prefix + \"_batchAdd\");\n\n    return prefix;\n\n};\n\n","\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = function buildApplyKey(module, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pFirst\", \"i32\");\n    f.addParam(\"pInc\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"pOldFree\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"pFrom\", \"i32\");\n    f.addLocal(\"pTo\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const t = c.i32_const(module.alloc(sizeF));\n\n    f.addCode(\n        c.setLocal(\"pFrom\", c.getLocal(\"pIn\")),\n        c.setLocal(\"pTo\", c.getLocal(\"pOut\")),\n    );\n\n    // t = first\n    f.addCode(\n        c.call(\n            frPrefix + \"_copy\",\n            c.getLocal(\"pFirst\"),\n            t\n        )\n    );\n    f.addCode(\n        c.setLocal(\"i\", c.i32_const(0)),\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n            c.call(\n                opGtimesF,\n                c.getLocal(\"pFrom\"),\n                t,\n                c.getLocal(\"pTo\")\n            ),\n            c.setLocal(\"pFrom\", c.i32_add(c.getLocal(\"pFrom\"), c.i32_const(sizeGIn))),\n            c.setLocal(\"pTo\", c.i32_add(c.getLocal(\"pTo\"), c.i32_const(sizeGOut))),\n\n            // t = t* inc\n            c.call(\n                frPrefix + \"_mul\",\n                t,\n                c.getLocal(\"pInc\"),\n                t\n            ),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        ))\n    );\n\n    module.exportFunction(fnName);\n\n};\n","const utils = require(\"../utils\");\n\nconst buildF1m =require(\"../build_f1m.js\");\nconst buildF1 =require(\"../build_f1.js\");\nconst buildF2m =require(\"../build_f2m.js\");\nconst buildF3m =require(\"../build_f3m.js\");\nconst buildCurve =require(\"../build_curve_jacobian_a0.js\");\nconst buildFFT = require(\"../build_fft\");\nconst buildPol = require(\"../build_pol\");\nconst buildQAP = require(\"../build_qap\");\nconst buildApplyKey = require(\"../build_applykey\");\nconst { bitLength, modInv, isOdd, isNegative } = require(\"../bigint.js\");\n\nmodule.exports = function buildBN128(module, _prefix) {\n\n    const prefix = _prefix || \"bn128\";\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;\n    const r = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;\n\n\n    const n64 = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n8 = n64*8;\n    const frsize = n8;\n    const f1size = n8;\n    const f2size = f1size * 2;\n    const ftsize = f1size * 12;\n\n    const pr = module.alloc(utils.bigInt2BytesLE( r, frsize ));\n\n    const f1mPrefix = buildF1m(module, q, \"f1m\");\n    buildF1(module, r, \"fr\", \"frm\");\n\n    const pG1b = module.alloc(utils.bigInt2BytesLE( toMontgomery(3n), f1size ));\n    const g1mPrefix = buildCurve(module, \"g1m\", \"f1m\", pG1b);\n\n    buildFFT(module, \"frm\", \"frm\", \"frm\", \"frm_mul\");\n\n    buildPol(module, \"pol\", \"frm\");\n    buildQAP(module, \"qap\", \"frm\");\n\n    const f2mPrefix = buildF2m(module, \"f1m_neg\", \"f2m\", \"f1m\");\n    const pG2b = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size )\n    ]);\n    const g2mPrefix = buildCurve(module, \"g2m\", \"f2m\", pG2b);\n\n\n    function buildGTimesFr(fnName, opMul) {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pG\", \"i32\");\n        f.addParam(\"pFr\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(\"frm_fromMontgomery\", c.getLocal(\"pFr\"), AUX),\n            c.call(\n                opMul,\n                c.getLocal(\"pG\"),\n                AUX,\n                c.i32_const(n8),\n                c.getLocal(\"pr\")\n            )\n        );\n\n        module.exportFunction(fnName);\n    }\n    buildGTimesFr(\"g1m_timesFr\", \"g1m_timesScalar\");\n    buildFFT(module, \"g1m\", \"g1m\", \"frm\", \"g1m_timesFr\");\n\n    buildGTimesFr(\"g2m_timesFr\", \"g2m_timesScalar\");\n    buildFFT(module, \"g2m\", \"g2m\", \"frm\", \"g2m_timesFr\");\n\n    buildGTimesFr(\"g1m_timesFrAffine\", \"g1m_timesScalarAffine\");\n    buildGTimesFr(\"g2m_timesFrAffine\", \"g2m_timesScalarAffine\");\n\n    buildApplyKey(module, \"frm_batchApplyKey\", \"fmr\", \"frm\", n8, n8, n8, \"frm_mul\");\n    buildApplyKey(module, \"g1m_batchApplyKey\", \"g1m\", \"frm\", n8*3, n8*3, n8, \"g1m_timesFr\");\n    buildApplyKey(module, \"g1m_batchApplyKeyMixed\", \"g1m\", \"frm\", n8*2, n8*3, n8, \"g1m_timesFrAffine\");\n    buildApplyKey(module, \"g2m_batchApplyKey\", \"g2m\", \"frm\", n8*2*3, n8*3*2, n8, \"g2m_timesFr\");\n    buildApplyKey(module, \"g2m_batchApplyKeyMixed\", \"g2m\", \"frm\", n8*2*2, n8*3*2, n8, \"g2m_timesFrAffine\");\n\n    function toMontgomery(a) {\n        return BigInt(a) * ( 1n << BigInt(f1size*8)) % q;\n    }\n\n    const G1gen = [\n        1n,\n        2n,\n        1n\n    ];\n\n    const pG1gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[2]), f1size ),\n        ]\n    );\n\n    const G1zero = [\n        0n,\n        1n,\n        0n\n    ];\n\n    const pG1zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[2]), f1size )\n        ]\n    );\n\n    const G2gen = [\n        [\n            10857046999023057135944570762232829481370756359578518086990519993285655852781n,\n            11559732032986387107991004021392285783925812861821192530917403151452391805634n,\n        ],[\n            8495653923123431417604973247489272438418190587263600148770280649306958101930n,\n            4082367875863433681332203403145435568316851327593401208105741076214120093531n,\n        ],[\n            1n,\n            0n,\n        ]\n    ];\n\n    const pG2gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][1]), f1size ),\n        ]\n    );\n\n    const G2zero = [\n        [\n            0n,\n            0n,\n        ],[\n            1n,\n            0n,\n        ],[\n            0n,\n            0n,\n        ]\n    ];\n\n    const pG2zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][1]), f1size ),\n        ]\n    );\n\n    const pOneT = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(1), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0), f1size ),\n    ]);\n\n    const pNonResidueF6 = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(9), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(1), f1size ),\n    ]);\n\n    const pTwoInv = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(  modInv(2n, q)), f1size ),\n        ...utils.bigInt2BytesLE( 0n, f1size )\n    ]);\n\n    const pAltBn128Twist = pNonResidueF6;\n\n    const pTwistCoefB = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size ),\n    ]);\n\n    function build_mulNR6() {\n        const f = module.addFunction(prefix + \"_mulNR6\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_mul\",\n                c.i32_const(pNonResidueF6),\n                c.getLocal(\"x\"),\n                c.getLocal(\"pr\")\n            )\n        );\n    }\n    build_mulNR6();\n\n    const f6mPrefix = buildF3m(module, prefix+\"_mulNR6\", \"f6m\", \"f2m\");\n\n    function build_mulNR12() {\n        const f = module.addFunction(prefix + \"_mulNR12\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_mul\",\n                c.i32_const(pNonResidueF6),\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8*4)),\n                c.getLocal(\"pr\")\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.getLocal(\"x\"),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2)),\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8*2)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*4)),\n            )\n        );\n    }\n    build_mulNR12();\n\n    const ftmPrefix = buildF2m(module, prefix+\"_mulNR12\", \"ftm\", f6mPrefix);\n\n\n    const ateLoopCount = 29793968203157093288n;\n    const ateLoopBitBytes = bits(ateLoopCount);\n    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);\n    const isLoopNegative = false;\n\n    const ateCoefSize = 3 * f2size;\n    const ateNDblCoefs = ateLoopBitBytes.length-1;\n    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) =>  acc + ( b!=0 ? 1 : 0)   ,0);\n    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;\n    const prePSize = 3*2*n8;\n    const preQSize = 3*n8*2 + ateNCoefs*ateCoefSize;\n    const finalExpIsNegative = false;\n\n\n    module.modules[prefix] = {\n        n64: n64,\n        pG1gen: pG1gen,\n        pG1zero: pG1zero,\n        pG1b: pG1b,\n        pG2gen: pG2gen,\n        pG2zero: pG2zero,\n        pG2b: pG2b,\n        pq: module.modules[\"f1m\"].pq,\n        pr: pr,\n        pOneT: pOneT,\n        prePSize: prePSize,\n        preQSize: preQSize,\n        r: r.toString(),\n        q: q.toString()\n    };\n\n    // console.log(\"PrePSize: \" +prePSize);\n    // console.log(\"PreQSize: \" +preQSize);\n\n    const finalExpZ = 4965661367192848881n;\n\n    function naf(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                const z = 2 - Number(E % 4n);\n                res.push( z );\n                E = E - BigInt(z);\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function bits(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                res.push( 1 );\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function buildPrepareG1() {\n        const f = module.addFunction(prefix+ \"_prepareG1\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"ppreP\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(g1mPrefix + \"_normalize\", c.getLocal(\"pP\"), c.getLocal(\"ppreP\")),  // TODO Remove if already in affine\n        );\n    }\n\n    function buildPrepAddStep() {\n        const f = module.addFunction(prefix+ \"_prepAddStep\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"pR\", \"i32\");\n        f.addParam(\"pCoef\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const X2  = c.getLocal(\"pQ\");\n        const Y2  = c.i32_add(c.getLocal(\"pQ\"), c.i32_const(f2size));\n\n        const X1  = c.getLocal(\"pR\");\n        const Y1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f2size));\n        const Z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*f2size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n        const D = ELL_VW;\n        const E = c.i32_const(module.alloc(f2size));\n        const F = c.i32_const(module.alloc(f2size));\n        const G = c.i32_const(module.alloc(f2size));\n        const H = c.i32_const(module.alloc(f2size));\n        const I = c.i32_const(module.alloc(f2size));\n        const J = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n            // D = X1 - X2*Z1\n            c.call(f2mPrefix + \"_mul\", X2, Z1, D),\n            c.call(f2mPrefix + \"_sub\", X1, D, D),\n\n            // E = Y1 - Y2*Z1\n            c.call(f2mPrefix + \"_mul\", Y2, Z1, E),\n            c.call(f2mPrefix + \"_sub\", Y1, E, E),\n\n            // F = D^2\n            c.call(f2mPrefix + \"_square\", D, F),\n\n            // G = E^2\n            c.call(f2mPrefix + \"_square\", E, G),\n\n            // H = D*F\n            c.call(f2mPrefix + \"_mul\", D, F, H),\n\n            // I = X1 * F\n            c.call(f2mPrefix + \"_mul\", X1, F, I),\n\n            // J = H + Z1*G - (I+I)\n            c.call(f2mPrefix + \"_add\", I, I, AUX),\n            c.call(f2mPrefix + \"_mul\", Z1, G, J),\n            c.call(f2mPrefix + \"_add\", H, J, J),\n            c.call(f2mPrefix + \"_sub\", J, AUX, J),\n\n\n            // X3 (X1) = D*J\n            c.call(f2mPrefix + \"_mul\", D, J, X1),\n\n            // Y3 (Y1) = E*(I-J)-(H*Y1)\n            c.call(f2mPrefix + \"_mul\", H, Y1, Y1),\n            c.call(f2mPrefix + \"_sub\", I, J, AUX),\n            c.call(f2mPrefix + \"_mul\", E, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", AUX, Y1, Y1),\n\n            // Z3 (Z1) = Z1*H\n            c.call(f2mPrefix + \"_mul\", Z1, H, Z1),\n\n            // ell_0 = xi * (E * X2 - D * Y2)\n            c.call(f2mPrefix + \"_mul\", D, Y2, AUX),\n            c.call(f2mPrefix + \"_mul\", E, X2, ELL_0),\n            c.call(f2mPrefix + \"_sub\", ELL_0, AUX, ELL_0),\n            c.call(f2mPrefix + \"_mul\", ELL_0, c.i32_const(pAltBn128Twist), ELL_0),\n\n\n            // ell_VV = - E (later: * xP)\n            c.call(f2mPrefix + \"_neg\", E, ELL_VV),\n\n            // ell_VW = D (later: * yP    )\n            // Already assigned\n\n        );\n    }\n\n\n\n    function buildPrepDoubleStep() {\n        const f = module.addFunction(prefix+ \"_prepDblStep\");\n        f.addParam(\"pR\", \"i32\");\n        f.addParam(\"pCoef\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const X1  = c.getLocal(\"pR\");\n        const Y1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f2size));\n        const Z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*f2size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n        const A = c.i32_const(module.alloc(f2size));\n        const B = c.i32_const(module.alloc(f2size));\n        const C = c.i32_const(module.alloc(f2size));\n        const D = c.i32_const(module.alloc(f2size));\n        const E = c.i32_const(module.alloc(f2size));\n        const F = c.i32_const(module.alloc(f2size));\n        const G = c.i32_const(module.alloc(f2size));\n        const H = c.i32_const(module.alloc(f2size));\n        const I = c.i32_const(module.alloc(f2size));\n        const J = c.i32_const(module.alloc(f2size));\n        const E2 = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // A = X1 * Y1 / 2\n            c.call(f2mPrefix + \"_mul\", Y1, c.i32_const(pTwoInv), A),\n            c.call(f2mPrefix + \"_mul\", X1, A, A),\n\n            // B = Y1^2\n            c.call(f2mPrefix + \"_square\", Y1, B),\n\n            // C = Z1^2\n            c.call(f2mPrefix + \"_square\", Z1, C),\n\n            // D = 3 * C\n            c.call(f2mPrefix + \"_add\", C, C, D),\n            c.call(f2mPrefix + \"_add\", D, C, D),\n\n            // E = twist_b * D\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pTwistCoefB), D, E),\n\n            // F = 3 * E\n            c.call(f2mPrefix + \"_add\", E, E, F),\n            c.call(f2mPrefix + \"_add\", E, F, F),\n\n            // G = (B+F)/2\n            c.call(f2mPrefix + \"_add\", B, F, G),\n            c.call(f2mPrefix + \"_mul\", G, c.i32_const(pTwoInv), G),\n\n            // H = (Y1+Z1)^2-(B+C)\n            c.call(f2mPrefix + \"_add\", B, C, AUX),\n            c.call(f2mPrefix + \"_add\", Y1, Z1, H),\n            c.call(f2mPrefix + \"_square\", H, H),\n            c.call(f2mPrefix + \"_sub\", H, AUX, H),\n\n            // I = E-B\n            c.call(f2mPrefix + \"_sub\", E, B, I),\n\n            // J = X1^2\n            c.call(f2mPrefix + \"_square\", X1, J),\n\n            // E_squared = E^2\n            c.call(f2mPrefix + \"_square\", E, E2),\n\n            // X3 (X1) = A * (B-F)\n            c.call(f2mPrefix + \"_sub\", B, F, AUX),\n            c.call(f2mPrefix + \"_mul\", A, AUX, X1),\n\n            // Y3 (Y1) = G^2 - 3*E^2\n            c.call(f2mPrefix + \"_add\", E2, E2, AUX),\n            c.call(f2mPrefix + \"_add\", E2, AUX, AUX),\n            c.call(f2mPrefix + \"_square\", G, Y1),\n            c.call(f2mPrefix + \"_sub\", Y1, AUX, Y1),\n\n            // Z3 (Z1) = B * H\n            c.call(f2mPrefix + \"_mul\", B, H, Z1),\n\n            // ell_0 = xi * I\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pAltBn128Twist), I, ELL_0),\n\n            // ell_VW = - H (later: * yP)\n            c.call(f2mPrefix + \"_neg\", H, ELL_VW),\n\n            // ell_VV = 3*J (later: * xP)\n            c.call(f2mPrefix + \"_add\", J, J, ELL_VV),\n            c.call(f2mPrefix + \"_add\", J, ELL_VV, ELL_VV),\n\n        );\n    }\n\n    function buildMulByQ() {\n        const f = module.addFunction(prefix + \"_mulByQ\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(f2size));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(f2size*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f2size));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f2size*2));\n\n        const MulByQX = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE( toMontgomery(\"21575463638280843010398324269430826099269044274347216827212613867836435027261\"), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(\"10307601595873709700152284273816112264069230130616436755625194854815875713954\"), f1size ),\n        ]));\n\n        const MulByQY = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE( toMontgomery(\"2821565182194536844548159561693502659359617185244120367078079554186484126554\"), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(\"3505843767911556378687030309984248845540243509899259641013678093033130930403\"), f1size ),\n        ]));\n\n        f.addCode(\n            // The frobeniusMap(1) in this field, is the conjugate\n            c.call(f2mPrefix + \"_conjugate\", x, x3),\n            c.call(f2mPrefix + \"_mul\", MulByQX, x3, x3),\n            c.call(f2mPrefix + \"_conjugate\", y, y3),\n            c.call(f2mPrefix + \"_mul\", MulByQY, y3, y3),\n            c.call(f2mPrefix + \"_conjugate\", z, z3),\n        );\n    }\n\n\n    function buildPrepareG2() {\n        buildMulByQ();\n        const f = module.addFunction(prefix+ \"_prepareG2\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const QX = c.getLocal(\"pQ\");\n\n        const pR = module.alloc(f2size*3);\n        const R = c.i32_const(pR);\n        const RX = c.i32_const(pR);\n        const RY = c.i32_const(pR+f2size);\n        const RZ = c.i32_const(pR+2*f2size);\n\n        const cQX = c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(0));\n        const cQY = c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size));\n\n        const pQ1 = module.alloc(f2size*3);\n        const Q1 = c.i32_const(pQ1);\n\n        const pQ2 = module.alloc(f2size*3);\n        const Q2 = c.i32_const(pQ2);\n        const Q2Y = c.i32_const(pQ2 + f2size);\n\n        f.addCode(\n            c.call(g2mPrefix + \"_normalize\", QX, cQX),  // TODO Remove if already in affine\n            c.call(f2mPrefix + \"_copy\", cQX, RX),\n            c.call(f2mPrefix + \"_copy\", cQY, RY),\n            c.call(f2mPrefix + \"_one\", RZ),\n        );\n\n        f.addCode(\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n                c.call(prefix + \"_prepDblStep\", R, c.getLocal(\"pCoef\")),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_prepAddStep\", cQX, R, c.getLocal(\"pCoef\")),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n        f.addCode(\n            c.call(prefix + \"_mulByQ\", cQX, Q1),\n            c.call(prefix + \"_mulByQ\", Q1, Q2)\n        );\n\n        if (isLoopNegative) {\n            f.addCode(\n                c.call(f2mPrefix + \"_neg\", RY, RY),\n            );\n        }\n\n        f.addCode(\n            c.call(f2mPrefix + \"_neg\", Q2Y, Q2Y),\n\n            c.call(prefix + \"_prepAddStep\", Q1, R, c.getLocal(\"pCoef\")),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n            c.call(prefix + \"_prepAddStep\", Q2, R, c.getLocal(\"pCoef\")),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n        );\n    }\n\n    function buildMulBy024Old() {\n        const f = module.addFunction(prefix+ \"__mulBy024Old\");\n        f.addParam(\"pEll0\", \"i32\");\n        f.addParam(\"pEllVW\", \"i32\");\n        f.addParam(\"pEllVV\", \"i32\");\n        f.addParam(\"pR\", \"i32\");            // Result in F12\n\n        const c = f.getCodeBuilder();\n\n        const x0  = c.getLocal(\"pEll0\");\n        const x2  = c.getLocal(\"pEllVV\");\n        const x4  = c.getLocal(\"pEllVW\");\n\n        const z0  = c.getLocal(\"pR\");\n\n        const pAUX12 = module.alloc(ftsize);\n        const AUX12 = c.i32_const(pAUX12);\n        const AUX12_0 = c.i32_const(pAUX12);\n        const AUX12_2 = c.i32_const(pAUX12+f2size);\n        const AUX12_4 = c.i32_const(pAUX12+f2size*2);\n        const AUX12_6 = c.i32_const(pAUX12+f2size*3);\n        const AUX12_8 = c.i32_const(pAUX12+f2size*4);\n        const AUX12_10 = c.i32_const(pAUX12+f2size*5);\n\n        f.addCode(\n\n            c.call(f2mPrefix + \"_copy\", x0, AUX12_0),\n            c.call(f2mPrefix + \"_zero\", AUX12_2),\n            c.call(f2mPrefix + \"_copy\", x2, AUX12_4),\n            c.call(f2mPrefix + \"_zero\", AUX12_6),\n            c.call(f2mPrefix + \"_copy\", x4, AUX12_8),\n            c.call(f2mPrefix + \"_zero\", AUX12_10),\n            c.call(ftmPrefix + \"_mul\", AUX12, z0, z0),\n        );\n    }\n\n    function buildMulBy024() {\n        const f = module.addFunction(prefix+ \"__mulBy024\");\n        f.addParam(\"pEll0\", \"i32\");\n        f.addParam(\"pEllVW\", \"i32\");\n        f.addParam(\"pEllVV\", \"i32\");\n        f.addParam(\"pR\", \"i32\");            // Result in F12\n\n        const c = f.getCodeBuilder();\n\n        const x0  = c.getLocal(\"pEll0\");\n        const x2  = c.getLocal(\"pEllVV\");\n        const x4  = c.getLocal(\"pEllVW\");\n\n        const z0  = c.getLocal(\"pR\");\n        const z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*n8));\n        const z2  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(4*n8));\n        const z3  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(6*n8));\n        const z4  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(8*n8));\n        const z5  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(10*n8));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const s0 = c.i32_const(module.alloc(f2size));\n        const T3 = c.i32_const(module.alloc(f2size));\n        const T4 = c.i32_const(module.alloc(f2size));\n        const D0 = c.i32_const(module.alloc(f2size));\n        const D2 = c.i32_const(module.alloc(f2size));\n        const D4 = c.i32_const(module.alloc(f2size));\n        const S1 = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // D0 = z0 * x0;\n            c.call(f2mPrefix + \"_mul\", z0, x0, D0),\n            // D2 = z2 * x2;\n            c.call(f2mPrefix + \"_mul\", z2, x2, D2),\n            // D4 = z4 * x4;\n            c.call(f2mPrefix + \"_mul\", z4, x4, D4),\n            // t2 = z0 + z4;\n            c.call(f2mPrefix + \"_add\", z0, z4, t2),\n            // t1 = z0 + z2;\n            c.call(f2mPrefix + \"_add\", z0, z2, t1),\n            // s0 = z1 + z3 + z5;\n            c.call(f2mPrefix + \"_add\", z1, z3, s0),\n            c.call(f2mPrefix + \"_add\", s0, z5, s0),\n\n\n            // For z.a_.a_ = z0.\n            // S1 = z1 * x2;\n            c.call(f2mPrefix + \"_mul\", z1, x2, S1),\n            // T3 = S1 + D4;\n            c.call(f2mPrefix + \"_add\", S1, D4, T3),\n            // T4 = my_Fp6::non_residue * T3 + D0;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            c.call(f2mPrefix + \"_add\", T4, D0, z0),\n            // z0 = T4;\n\n            // For z.a_.b_ = z1\n            // T3 = z5 * x4;\n            c.call(f2mPrefix + \"_mul\", z5, x4, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T3 = T3 + D2;\n            c.call(f2mPrefix + \"_add\", T3, D2, T3),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // T3 = z1 * x0;\n            c.call(f2mPrefix + \"_mul\", z1, x0, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z1),\n            // z1 = T4;\n\n\n\n            // For z.a_.c_ = z2\n            // t0 = x0 + x2;\n            c.call(f2mPrefix + \"_add\", x0, x2, t0),\n            // T3 = t1 * t0 - D0 - D2;\n            c.call(f2mPrefix + \"_mul\", t1, t0, T3),\n            c.call(f2mPrefix + \"_add\", D0, D2, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = z3 * x4;\n            c.call(f2mPrefix + \"_mul\", z3, x4, T4),\n            // S1 = S1 + T4;\n            c.call(f2mPrefix + \"_add\", S1, T4, S1),\n\n\n            // For z.b_.a_ = z3 (z3 needs z2)\n            // t0 = z2 + z4;\n            c.call(f2mPrefix + \"_add\", z2, z4, t0),\n            // T3 = T3 + T4;\n            // z2 = T3;\n            c.call(f2mPrefix + \"_add\", T3, T4, z2),\n            // t1 = x2 + x4;\n            c.call(f2mPrefix + \"_add\", x2, x4, t1),\n            // T3 = t0 * t1 - D2 - D4;\n            c.call(f2mPrefix + \"_mul\", t1, t0, T3),\n            c.call(f2mPrefix + \"_add\", D2, D4, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // T3 = z3 * x0;\n            c.call(f2mPrefix + \"_mul\", z3, x0, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z3),\n            // z3 = T4;\n\n            // For z.b_.b_ = z4\n            // T3 = z5 * x2;\n            c.call(f2mPrefix + \"_mul\", z5, x2, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // t0 = x0 + x4;\n            c.call(f2mPrefix + \"_add\", x0, x4, t0),\n            // T3 = t2 * t0 - D0 - D4;\n            c.call(f2mPrefix + \"_mul\", t2, t0, T3),\n            c.call(f2mPrefix + \"_add\", D0, D4, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z4),\n            // z4 = T4;\n\n            // For z.b_.c_ = z5.\n            // t0 = x0 + x2 + x4;\n            c.call(f2mPrefix + \"_add\", x0, x2, t0),\n            c.call(f2mPrefix + \"_add\", t0, x4, t0),\n            // T3 = s0 * t0 - S1;\n            c.call(f2mPrefix + \"_mul\", s0, t0, T3),\n            c.call(f2mPrefix + \"_sub\", T3, S1, z5),\n            // z5 = T3;\n\n        );\n    }\n\n\n    function buildMillerLoop() {\n        const f = module.addFunction(prefix+ \"_millerLoop\");\n        f.addParam(\"ppreP\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const preP_PX = c.getLocal(\"ppreP\");\n        const preP_PY = c.i32_add(c.getLocal(\"ppreP\"), c.i32_const(f1size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n\n        const pVW = module.alloc(f2size);\n        const VW = c.i32_const(pVW);\n        const pVV = module.alloc(f2size);\n        const VV = c.i32_const(pVV);\n\n        const F = c.getLocal(\"r\");\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_one\", F),\n\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n\n                c.call(ftmPrefix + \"_square\", F, F),\n\n                c.call(f2mPrefix + \"_mul1\", ELL_VW,preP_PY, VW),\n                c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n                c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n                        ...c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n\n                        ...c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n\n        );\n\n        if (isLoopNegative) {\n            f.addCode(\n                c.call(ftmPrefix + \"_inverse\", F, F),\n            );\n        }\n\n        f.addCode(\n            c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n            c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n            c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n            c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n            c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n            c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n        );\n\n    }\n\n\n    function buildFrobeniusMap(n) {\n        const F12 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],\n                [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],\n                [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],\n                [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],\n                [2203960485148121921418603742825762020974279258880205651967n, 0n],\n                [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n],\n            ]\n        ];\n\n        const F6 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n],\n            ],\n            [\n                [1n, 0n],\n                [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n],\n            ]\n        ];\n\n        const f = module.addFunction(prefix+ \"__frobeniusMap\"+n);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<6; i++) {\n            const X = (i==0) ? c.getLocal(\"x\") : c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size));\n            const Xc0 = X;\n            const Xc1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size + f1size));\n            const R = (i==0) ? c.getLocal(\"r\") : c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size));\n            const Rc0 = R;\n            const Rc1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size + f1size));\n            const coef = mul2(F12[Math.floor(i/3)][n%12] , F6[i%3][n%6]);\n            const pCoef = module.alloc([\n                ...utils.bigInt2BytesLE(toMontgomery(coef[0]), 32),\n                ...utils.bigInt2BytesLE(toMontgomery(coef[1]), 32),\n            ]);\n            if (n%2 == 1) {\n                f.addCode(\n                    c.call(f1mPrefix + \"_copy\", Xc0, Rc0),\n                    c.call(f1mPrefix + \"_neg\", Xc1, Rc1),\n                    c.call(f2mPrefix + \"_mul\", R, c.i32_const(pCoef), R),\n                );\n            } else {\n                f.addCode(c.call(f2mPrefix + \"_mul\", X, c.i32_const(pCoef), R));\n            }\n        }\n\n        function mul2(a, b) {\n            const ac0 = BigInt(a[0]);\n            const ac1 = BigInt(a[1]);\n            const bc0 = BigInt(b[0]);\n            const bc1 = BigInt(b[1]);\n            const res = [\n                (ac0 * bc0 - (  ac1 * bc1)  ) % q,\n                (ac0 * bc1 + (  ac1 * bc0)  ) % q,\n            ];\n            if (isNegative(res[0])) res[0] = res[0] + q;\n            return res;\n        }\n\n    }\n\n\n\n    function buildFinalExponentiationFirstChunk() {\n\n        const f = module.addFunction(prefix+ \"__finalExponentiationFirstChunk\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const eltC0 = elt;\n        const eltC1 = c.i32_add(elt, c.i32_const(n8*6));\n        const r = c.getLocal(\"r\");\n        const pA = module.alloc(ftsize);\n        const A = c.i32_const(pA);\n        const Ac0 = A;\n        const Ac1 = c.i32_const(pA + n8*6);\n        const B = c.i32_const(module.alloc(ftsize));\n        const C = c.i32_const(module.alloc(ftsize));\n        const D = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n            // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);\n            c.call(f6mPrefix + \"_copy\", eltC0, Ac0),\n            c.call(f6mPrefix + \"_neg\", eltC1, Ac1),\n\n            // const alt_bn128_Fq12 B = elt.inverse();\n            c.call(ftmPrefix + \"_inverse\", elt, B),\n\n            // const alt_bn128_Fq12 C = A * B;\n            c.call(ftmPrefix + \"_mul\", A, B, C),\n            // const alt_bn128_Fq12 D = C.Frobenius_map(2);\n            c.call(prefix + \"__frobeniusMap2\", C, D),\n            // const alt_bn128_Fq12 result = D * C;\n            c.call(ftmPrefix + \"_mul\", C, D, r),\n        );\n    }\n\n    function buildCyclotomicSquare() {\n        const f = module.addFunction(prefix+ \"__cyclotomicSquare\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x4 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f2size));\n        const x3 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f2size));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(3*f2size));\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(4*f2size));\n        const x5 = c.i32_add(c.getLocal(\"x\"), c.i32_const(5*f2size));\n\n        const r0 = c.getLocal(\"r\");\n        const r4 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f2size));\n        const r3 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f2size));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(3*f2size));\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*f2size));\n        const r5 = c.i32_add(c.getLocal(\"r\"), c.i32_const(5*f2size));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const tmp = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n\n        f.addCode(\n            //    // t0 + t1*y = (z0 + z1*y)^2 = a^2\n            //    tmp = z0 * z1;\n            //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;\n            //    t1 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x0, x1, tmp),\n            c.call(f2mPrefix + \"_mul\", x1, c.i32_const(pNonResidueF6), t0),\n            c.call(f2mPrefix + \"_add\", x0, t0, t0),\n            c.call(f2mPrefix + \"_add\", x0, x1, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t0, t0),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t0, AUX, t0),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t1),\n\n            //  // t2 + t3*y = (z2 + z3*y)^2 = b^2\n            //  tmp = z2 * z3;\n            //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;\n            //  t3 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x2, x3, tmp),\n            c.call(f2mPrefix + \"_mul\", x3, c.i32_const(pNonResidueF6), t2),\n            c.call(f2mPrefix + \"_add\", x2, t2, t2),\n            c.call(f2mPrefix + \"_add\", x2, x3, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t2, t2),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t2, AUX, t2),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t3),\n\n            //  // t4 + t5*y = (z4 + z5*y)^2 = c^2\n            //  tmp = z4 * z5;\n            //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;\n            //  t5 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x4, x5, tmp),\n            c.call(f2mPrefix + \"_mul\", x5, c.i32_const(pNonResidueF6), t4),\n            c.call(f2mPrefix + \"_add\", x4, t4, t4),\n            c.call(f2mPrefix + \"_add\", x4, x5, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t4, t4),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t4, AUX, t4),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t5),\n\n            // For A\n            // z0 = 3 * t0 - 2 * z0\n            c.call(f2mPrefix + \"_sub\", t0, x0, r0),\n            c.call(f2mPrefix + \"_add\", r0, r0, r0),\n            c.call(f2mPrefix + \"_add\", t0, r0, r0),\n            // z1 = 3 * t1 + 2 * z1\n            c.call(f2mPrefix + \"_add\", t1, x1, r1),\n            c.call(f2mPrefix + \"_add\", r1, r1, r1),\n            c.call(f2mPrefix + \"_add\", t1, r1, r1),\n\n            // For B\n            // z2 = 3 * (xi * t5) + 2 * z2\n            c.call(f2mPrefix + \"_mul\", t5, c.i32_const(pAltBn128Twist), AUX),\n            c.call(f2mPrefix + \"_add\", AUX, x2, r2),\n            c.call(f2mPrefix + \"_add\", r2, r2, r2),\n            c.call(f2mPrefix + \"_add\", AUX, r2, r2),\n            // z3 = 3 * t4 - 2 * z3\n            c.call(f2mPrefix + \"_sub\", t4, x3, r3),\n            c.call(f2mPrefix + \"_add\", r3, r3, r3),\n            c.call(f2mPrefix + \"_add\", t4, r3, r3),\n\n            // For C\n            // z4 = 3 * t2 - 2 * z4\n            c.call(f2mPrefix + \"_sub\", t2, x4, r4),\n            c.call(f2mPrefix + \"_add\", r4, r4, r4),\n            c.call(f2mPrefix + \"_add\", t2, r4, r4),\n            // z5 = 3 * t3 + 2 * z5\n            c.call(f2mPrefix + \"_add\", t3, x5, r5),\n            c.call(f2mPrefix + \"_add\", r5, r5, r5),\n            c.call(f2mPrefix + \"_add\", t3, r5, r5),\n\n        );\n    }\n\n\n    function buildCyclotomicExp(exponent, fnName) {\n        const exponentNafBytes = naf(exponent).map( (b) => (b==-1 ? 0xFF: b) );\n        const pExponentNafBytes = module.alloc(exponentNafBytes);\n\n        const f = module.addFunction(prefix+ \"__cyclotomicExp_\"+fnName);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"bit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"x\");\n\n        const res = c.getLocal(\"r\");\n\n        const inverse = c.i32_const(module.alloc(ftsize));\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_conjugate\", x, inverse),\n            c.call(ftmPrefix + \"_one\", res),\n\n            c.if(\n                c.teeLocal(\"bit\", c.i32_load8_s(c.i32_const(exponentNafBytes.length-1), pExponentNafBytes)),\n                c.if(\n                    c.i32_eq(\n                        c.getLocal(\"bit\"),\n                        c.i32_const(1)\n                    ),\n                    c.call(ftmPrefix + \"_mul\", res, x, res),\n                    c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                )\n            ),\n\n            c.setLocal(\"i\", c.i32_const(exponentNafBytes.length-2)),\n            c.block(c.loop(\n                c.call(prefix + \"__cyclotomicSquare\", res, res),\n                c.if(\n                    c.teeLocal(\"bit\", c.i32_load8_s(c.getLocal(\"i\"), pExponentNafBytes)),\n                    c.if(\n                        c.i32_eq(\n                            c.getLocal(\"bit\"),\n                            c.i32_const(1)\n                        ),\n                        c.call(ftmPrefix + \"_mul\", res, x, res),\n                        c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                    )\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n\n    function buildFinalExponentiationLastChunk() {\n        buildCyclotomicSquare();\n        buildCyclotomicExp(finalExpZ, \"w0\");\n\n        const f = module.addFunction(prefix+ \"__finalExponentiationLastChunk\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const result = c.getLocal(\"r\");\n        const A = c.i32_const(module.alloc(ftsize));\n        const B = c.i32_const(module.alloc(ftsize));\n        const C = c.i32_const(module.alloc(ftsize));\n        const D = c.i32_const(module.alloc(ftsize));\n        const E = c.i32_const(module.alloc(ftsize));\n        const F = c.i32_const(module.alloc(ftsize));\n        const G = c.i32_const(module.alloc(ftsize));\n        const H = c.i32_const(module.alloc(ftsize));\n        const I = c.i32_const(module.alloc(ftsize));\n        const J = c.i32_const(module.alloc(ftsize));\n        const K = c.i32_const(module.alloc(ftsize));\n        const L = c.i32_const(module.alloc(ftsize));\n        const M = c.i32_const(module.alloc(ftsize));\n        const N = c.i32_const(module.alloc(ftsize));\n        const O = c.i32_const(module.alloc(ftsize));\n        const P = c.i32_const(module.alloc(ftsize));\n        const Q = c.i32_const(module.alloc(ftsize));\n        const R = c.i32_const(module.alloc(ftsize));\n        const S = c.i32_const(module.alloc(ftsize));\n        const T = c.i32_const(module.alloc(ftsize));\n        const U = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n\n\n            // A = exp_by_neg_z(elt)  // = elt^(-z)\n            c.call(prefix + \"__cyclotomicExp_w0\", elt, A),\n            finalExpIsNegative ? [] : c.call(ftmPrefix + \"_conjugate\", A, A),\n            // B = A^2                // = elt^(-2*z)\n            c.call(prefix + \"__cyclotomicSquare\", A, B),\n            // C = B^2                // = elt^(-4*z)\n            c.call(prefix + \"__cyclotomicSquare\", B, C),\n            // D = C * B              // = elt^(-6*z)\n            c.call(ftmPrefix + \"_mul\", C, B, D),\n            // E = exp_by_neg_z(D)    // = elt^(6*z^2)\n            c.call(prefix + \"__cyclotomicExp_w0\", D, E),\n            finalExpIsNegative ? [] : c.call(ftmPrefix + \"_conjugate\", E, E),\n            // F = E^2                // = elt^(12*z^2)\n            c.call(prefix + \"__cyclotomicSquare\", E, F),\n            // G = epx_by_neg_z(F)    // = elt^(-12*z^3)\n            c.call(prefix + \"__cyclotomicExp_w0\", F, G),\n            finalExpIsNegative ? [] : c.call(ftmPrefix + \"_conjugate\", G, G),\n            // H = conj(D)            // = elt^(6*z)\n            c.call(ftmPrefix + \"_conjugate\", D, H),\n            // I = conj(G)            // = elt^(12*z^3)\n            c.call(ftmPrefix + \"_conjugate\", G, I),\n            // J = I * E              // = elt^(12*z^3 + 6*z^2)\n            c.call(ftmPrefix + \"_mul\", I, E, J),\n            // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)\n            c.call(ftmPrefix + \"_mul\", J, H, K),\n            // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)\n            c.call(ftmPrefix + \"_mul\", K, B, L),\n            // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)\n            c.call(ftmPrefix + \"_mul\", K, E, M),\n\n            // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)\n            c.call(ftmPrefix + \"_mul\", M, elt, N),\n\n            // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))\n            c.call(prefix + \"__frobeniusMap1\", L, O),\n            // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", O, N, P),\n            // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))\n            c.call(prefix + \"__frobeniusMap2\", K, Q),\n            // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", Q, P, R),\n            // S = conj(elt)          // = elt^(-1)\n            c.call(ftmPrefix + \"_conjugate\", elt, S),\n            // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)\n            c.call(ftmPrefix + \"_mul\", S, L, T),\n            // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))\n            c.call(prefix + \"__frobeniusMap3\", T, U),\n            // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", U, R, result),\n            // result = V\n        );\n    }\n\n\n    function buildFinalExponentiation() {\n        buildFinalExponentiationFirstChunk();\n        buildFinalExponentiationLastChunk();\n        const f = module.addFunction(prefix+ \"_finalExponentiation\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const result = c.getLocal(\"r\");\n        const eltToFirstChunk = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n            c.call(prefix + \"__finalExponentiationFirstChunk\", elt, eltToFirstChunk ),\n            c.call(prefix + \"__finalExponentiationLastChunk\", eltToFirstChunk, result )\n        );\n    }\n\n\n    function buildFinalExponentiationOld() {\n        const f = module.addFunction(prefix+ \"_finalExponentiationOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;\n\n        const pExponent = module.alloc(utils.bigInt2BytesLE( exponent, 352 ));\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(ftmPrefix + \"_exp\", c.getLocal(\"x\"), c.i32_const(pExponent), c.i32_const(352), c.getLocal(\"r\")),\n        );\n    }\n\n\n\n\n    const pPreP = module.alloc(prePSize);\n    const pPreQ = module.alloc(preQSize);\n\n    function buildPairingEquation(nPairings) {\n\n        const f = module.addFunction(prefix+ \"_pairingEq\"+nPairings);\n        for (let i=0; i<nPairings; i++) {\n            f.addParam(\"p_\"+i, \"i32\");\n            f.addParam(\"q_\"+i, \"i32\");\n        }\n        f.addParam(\"c\", \"i32\");\n        f.setReturnType(\"i32\");\n\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n        const auxT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(ftmPrefix + \"_one\", resT ));\n\n        for (let i=0; i<nPairings; i++) {\n\n            f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p_\"+i), c.i32_const(pPreP) ));\n            f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q_\"+i), c.i32_const(pPreQ) ));\n            f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), auxT ));\n\n            f.addCode(c.call(ftmPrefix + \"_mul\", resT, auxT, resT ));\n        }\n\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, resT ));\n\n        f.addCode(c.call(ftmPrefix + \"_eq\", resT, c.getLocal(\"c\")));\n    }\n\n\n    function buildPairing() {\n\n        const f = module.addFunction(prefix+ \"_pairing\");\n        f.addParam(\"p\", \"i32\");\n        f.addParam(\"q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p\"), c.i32_const(pPreP) ));\n        f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q\"), c.i32_const(pPreQ) ));\n        f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), resT ));\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, c.getLocal(\"r\") ));\n    }\n\n\n    buildPrepAddStep();\n    buildPrepDoubleStep();\n\n    buildPrepareG1();\n    buildPrepareG2();\n\n    buildMulBy024();\n    buildMulBy024Old();\n    buildMillerLoop();\n\n\n    for (let i=0; i<10; i++) {\n        buildFrobeniusMap(i);\n        module.exportFunction(prefix + \"__frobeniusMap\"+i);\n    }\n\n    buildFinalExponentiationOld();\n    buildFinalExponentiation();\n\n    for (let i=1; i<=5; i++) {\n        buildPairingEquation(i);\n        module.exportFunction(prefix + \"_pairingEq\"+i);\n    }\n\n    buildPairing();\n\n    module.exportFunction(prefix + \"_pairing\");\n\n    module.exportFunction(prefix + \"_prepareG1\");\n    module.exportFunction(prefix + \"_prepareG2\");\n    module.exportFunction(prefix + \"_millerLoop\");\n    module.exportFunction(prefix + \"_finalExponentiation\");\n    module.exportFunction(prefix + \"_finalExponentiationOld\");\n    module.exportFunction(prefix + \"__mulBy024\");\n    module.exportFunction(prefix + \"__mulBy024Old\");\n    module.exportFunction(prefix + \"__cyclotomicSquare\");\n    module.exportFunction(prefix + \"__cyclotomicExp_w0\");\n\n    // console.log(module.functionIdxByName);\n\n};\n\n","const utils = require(\"../utils\");\n\nconst buildF1m =require(\"../build_f1m.js\");\nconst buildF1 =require(\"../build_f1.js\");\nconst buildF2m =require(\"../build_f2m.js\");\nconst buildF3m =require(\"../build_f3m.js\");\nconst buildCurve =require(\"../build_curve_jacobian_a0.js\");\nconst buildFFT = require(\"../build_fft\");\nconst buildPol = require(\"../build_pol\");\nconst buildQAP = require(\"../build_qap\");\nconst buildApplyKey = require(\"../build_applykey\");\nconst { bitLength, isOdd, isNegative } = require(\"../bigint.js\");\n\n// Definition here: https://electriccoin.co/blog/new-snark-curve/\n\nmodule.exports = function buildBLS12381(module, _prefix) {\n\n    const prefix = _prefix || \"bls12381\";\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;\n\n    const n64q = Math.floor((bitLength(q - 1n) - 1)/64) +1;\n    const n8q = n64q*8;\n    const f1size = n8q;\n    const f2size = f1size * 2;\n    const ftsize = f1size * 12;\n\n    const n64r = Math.floor((bitLength(r - 1n) - 1)/64) +1;\n    const n8r = n64r*8;\n    const frsize = n8r;\n\n\n    const pr = module.alloc(utils.bigInt2BytesLE( r, frsize ));\n\n    const f1mPrefix = buildF1m(module, q, \"f1m\", \"intq\");\n    buildF1(module, r, \"fr\", \"frm\", \"intr\");\n    const pG1b = module.alloc(utils.bigInt2BytesLE( toMontgomery(4n), f1size ));\n    const g1mPrefix = buildCurve(module, \"g1m\", \"f1m\", pG1b);\n\n    buildFFT(module, \"frm\", \"frm\", \"frm\", \"frm_mul\");\n\n    buildPol(module, \"pol\", \"frm\");\n    buildQAP(module, \"qap\", \"frm\");\n\n    const f2mPrefix = buildF2m(module, \"f1m_neg\", \"f2m\", \"f1m\");\n    const pG2b = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(4n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(4n), f1size )\n    ]);\n    const g2mPrefix = buildCurve(module, \"g2m\", \"f2m\", pG2b);\n\n\n    function buildGTimesFr(fnName, opMul) {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pG\", \"i32\");\n        f.addParam(\"pFr\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8r));\n\n        f.addCode(\n            c.call(\"frm_fromMontgomery\", c.getLocal(\"pFr\"), AUX),\n            c.call(\n                opMul,\n                c.getLocal(\"pG\"),\n                AUX,\n                c.i32_const(n8r),\n                c.getLocal(\"pr\")\n            )\n        );\n\n        module.exportFunction(fnName);\n    }\n    buildGTimesFr(\"g1m_timesFr\", \"g1m_timesScalar\");\n    buildFFT(module, \"g1m\", \"g1m\", \"frm\", \"g1m_timesFr\");\n\n    buildGTimesFr(\"g2m_timesFr\", \"g2m_timesScalar\");\n    buildFFT(module, \"g2m\", \"g2m\", \"frm\", \"g2m_timesFr\");\n\n    buildGTimesFr(\"g1m_timesFrAffine\", \"g1m_timesScalarAffine\");\n    buildGTimesFr(\"g2m_timesFrAffine\", \"g2m_timesScalarAffine\");\n\n    buildApplyKey(module, \"frm_batchApplyKey\", \"fmr\", \"frm\", n8r, n8r, n8r, \"frm_mul\");\n    buildApplyKey(module, \"g1m_batchApplyKey\", \"g1m\", \"frm\", n8q*3, n8q*3, n8r, \"g1m_timesFr\");\n    buildApplyKey(module, \"g1m_batchApplyKeyMixed\", \"g1m\", \"frm\", n8q*2, n8q*3, n8r, \"g1m_timesFrAffine\");\n    buildApplyKey(module, \"g2m_batchApplyKey\", \"g2m\", \"frm\", n8q*2*3, n8q*3*2, n8r, \"g2m_timesFr\");\n    buildApplyKey(module, \"g2m_batchApplyKeyMixed\", \"g2m\", \"frm\", n8q*2*2, n8q*3*2, n8r, \"g2m_timesFrAffine\");\n\n\n    function toMontgomery(a) {\n        return BigInt(a) * (1n << BigInt(f1size*8)) % q;\n    }\n\n    const G1gen = [\n        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,\n        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,\n        1n\n    ];\n\n    const pG1gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1gen[2]), f1size ),\n        ]\n    );\n\n    const G1zero = [\n        0n,\n        1n,\n        0n\n    ];\n\n    const pG1zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G1zero[2]), f1size )\n        ]\n    );\n\n    const G2gen = [\n        [\n            352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,\n            3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n,\n        ],[\n            1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,\n            927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n,\n        ],[\n            1n,\n            0n,\n        ]\n    ];\n\n    const pG2gen = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2gen[2][1]), f1size ),\n        ]\n    );\n\n    const G2zero = [\n        [\n            0n,\n            0n,\n        ],[\n            1n,\n            0n,\n        ],[\n            0n,\n            0n,\n        ]\n    ];\n\n    const pG2zero = module.alloc(\n        [\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[0][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[1][1]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][0]), f1size ),\n            ...utils.bigInt2BytesLE( toMontgomery(G2zero[2][1]), f1size ),\n        ]\n    );\n\n    const pOneT = module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(1n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(0n), f1size ),\n    ]);\n\n    const pBls12381Twist =  module.alloc([\n        ...utils.bigInt2BytesLE( toMontgomery(1n), f1size ),\n        ...utils.bigInt2BytesLE( toMontgomery(1n), f1size ),\n    ]);\n\n    function build_mulNR2() {\n        const f = module.addFunction(f2mPrefix + \"_mulNR\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0c = c.i32_const(module.alloc(f1size));\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1size));\n        const r0 = c.getLocal(\"pr\");\n        const r1 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f1size));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, x0c),\n            c.call(f1mPrefix+\"_sub\", x0, x1, r0),\n            c.call(f1mPrefix+\"_add\", x0c, x1, r1),\n        );\n    }\n    build_mulNR2();\n\n    const f6mPrefix = buildF3m(module, f2mPrefix+\"_mulNR\", \"f6m\", \"f2m\");\n\n    function build_mulNR6() {\n        const f = module.addFunction(f6mPrefix + \"_mulNR\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const c0copy = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.getLocal(\"x\"),\n                c0copy\n            ),\n            c.call(\n                f2mPrefix + \"_mulNR\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8q*4)),\n                c.getLocal(\"pr\")\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8q*2)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8q*4)),\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c0copy,\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8q*2)),\n            ),\n        );\n    }\n    build_mulNR6();\n\n    const ftmPrefix = buildF2m(module, f6mPrefix+\"_mulNR\", \"ftm\", f6mPrefix);\n\n    const ateLoopCount = 0xd201000000010000n;\n    const ateLoopBitBytes = bits(ateLoopCount);\n    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);\n    const isLoopNegative = true;\n\n    const ateCoefSize = 3 * f2size;\n    const ateNDblCoefs = ateLoopBitBytes.length-1;\n    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) =>  acc + ( b!=0 ? 1 : 0)   ,0);\n    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;\n    const prePSize = 3*2*n8q;\n    const preQSize = 3*n8q*2 + ateNCoefs*ateCoefSize;\n    const finalExpIsNegative = true;\n\n    const finalExpZ = 15132376222941642752n;\n\n\n    module.modules[prefix] = {\n        n64q: n64q,\n        n64r: n64r,\n        n8q: n8q,\n        n8r: n8r,\n        pG1gen: pG1gen,\n        pG1zero: pG1zero,\n        pG1b: pG1b,\n        pG2gen: pG2gen,\n        pG2zero: pG2zero,\n        pG2b: pG2b,\n        pq: module.modules[\"f1m\"].pq,\n        pr: pr,\n        pOneT: pOneT,\n        r: r,\n        q: q,\n        prePSize: prePSize,\n        preQSize: preQSize\n    };\n\n\n    function naf(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                const z = 2 - Number(E % 4n);\n                res.push( z );\n                E = E - BigInt(z);\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function bits(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                res.push( 1 );\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function buildPrepareG1() {\n        const f = module.addFunction(prefix+ \"_prepareG1\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"ppreP\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(g1mPrefix + \"_normalize\", c.getLocal(\"pP\"), c.getLocal(\"ppreP\")),  // TODO Remove if already in affine\n        );\n    }\n\n\n\n    function buildPrepDoubleStep() {\n        const f = module.addFunction(prefix+ \"_prepDblStep\");\n        f.addParam(\"R\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Rx  = c.getLocal(\"R\");\n        const Ry  = c.i32_add(c.getLocal(\"R\"), c.i32_const(2*n8q));\n        const Rz  = c.i32_add(c.getLocal(\"R\"), c.i32_const(4*n8q));\n\n        const t0  = c.getLocal(\"r\");\n        const t3  = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*n8q));\n        const t6  = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*n8q));\n\n\n        const zsquared = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // tmp0 = r.x.square();\n            c.call(f2mPrefix + \"_square\", Rx, t0),\n\n            // tmp1 = r.y.square();\n            c.call(f2mPrefix + \"_square\", Ry, t1),\n\n            // tmp2 = tmp1.square();\n            c.call(f2mPrefix + \"_square\", t1, t2),\n\n            // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;\n            c.call(f2mPrefix + \"_add\", t1, Rx, t3),\n            c.call(f2mPrefix + \"_square\", t3, t3),\n            c.call(f2mPrefix + \"_sub\", t3, t0, t3),\n            c.call(f2mPrefix + \"_sub\", t3, t2, t3),\n\n            // tmp3 = tmp3 + tmp3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t3),\n\n            // tmp4 = tmp0 + tmp0 + tmp0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t4),\n            c.call(f2mPrefix + \"_add\", t4, t0, t4),\n\n            // tmp6 = r.x + tmp4;\n            c.call(f2mPrefix + \"_add\", Rx, t4, t6),\n\n            // tmp5 = tmp4.square();\n            c.call(f2mPrefix + \"_square\", t4, t5),\n\n            // zsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, zsquared),\n\n            // r.x = tmp5 - tmp3 - tmp3;\n            c.call(f2mPrefix + \"_sub\", t5, t3, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t3, Rx),\n\n            // r.z = (r.z + r.y).square() - tmp1 - zsquared;\n            c.call(f2mPrefix + \"_add\", Rz, Ry, Rz),\n            c.call(f2mPrefix + \"_square\", Rz, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, t1, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, zsquared, Rz),\n\n            // r.y = (tmp3 - r.x) * tmp4;\n            c.call(f2mPrefix + \"_sub\", t3, Rx, Ry),\n            c.call(f2mPrefix + \"_mul\", Ry, t4, Ry),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // r.y -= tmp2;\n            c.call(f2mPrefix + \"_sub\", Ry, t2, Ry),\n\n            // tmp3 = tmp4 * zsquared;\n            c.call(f2mPrefix + \"_mul\", t4, zsquared, t3),\n\n            // tmp3 = tmp3 + tmp3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t3),\n\n            // tmp3 = -tmp3;\n            c.call(f2mPrefix + \"_neg\", t3, t3),\n\n            // tmp6 = tmp6.square() - tmp0 - tmp5;\n            c.call(f2mPrefix + \"_square\", t6, t6),\n            c.call(f2mPrefix + \"_sub\", t6, t0, t6),\n            c.call(f2mPrefix + \"_sub\", t6, t5, t6),\n\n            // tmp1 = tmp1 + tmp1;\n            c.call(f2mPrefix + \"_add\", t1, t1, t1),\n\n            // tmp1 = tmp1 + tmp1;\n            c.call(f2mPrefix + \"_add\", t1, t1, t1),\n\n            // tmp6 = tmp6 - tmp1;\n            c.call(f2mPrefix + \"_sub\", t6, t1, t6),\n\n            // tmp0 = r.z * zsquared;\n            c.call(f2mPrefix + \"_mul\", Rz, zsquared, t0),\n\n            // tmp0 = tmp0 + tmp0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t0),\n\n        );\n    }\n\n    function buildPrepAddStep() {\n        const f = module.addFunction(prefix+ \"_prepAddStep\");\n        f.addParam(\"R\", \"i32\");\n        f.addParam(\"Q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Rx  = c.getLocal(\"R\");\n        const Ry  = c.i32_add(c.getLocal(\"R\"), c.i32_const(2*n8q));\n        const Rz  = c.i32_add(c.getLocal(\"R\"), c.i32_const(4*n8q));\n\n        const Qx  = c.getLocal(\"Q\");\n        const Qy  = c.i32_add(c.getLocal(\"Q\"), c.i32_const(2*n8q));\n\n        const t10  = c.getLocal(\"r\");\n        const t1  = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*n8q));\n        const t9  = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*n8q));\n\n        const zsquared = c.i32_const(module.alloc(f2size));\n        const ysquared = c.i32_const(module.alloc(f2size));\n        const ztsquared = c.i32_const(module.alloc(f2size));\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const t6 = c.i32_const(module.alloc(f2size));\n        const t7 = c.i32_const(module.alloc(f2size));\n        const t8 = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // zsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, zsquared),\n\n            // ysquared = q.y.square();\n            c.call(f2mPrefix + \"_square\", Qy, ysquared),\n\n            // t0 = zsquared * q.x;\n            c.call(f2mPrefix + \"_mul\", zsquared, Qx, t0),\n\n            // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;\n            c.call(f2mPrefix + \"_add\", Qy, Rz, t1),\n            c.call(f2mPrefix + \"_square\", t1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, ysquared, t1),\n            c.call(f2mPrefix + \"_sub\", t1, zsquared, t1),\n            c.call(f2mPrefix + \"_mul\", t1, zsquared, t1),\n\n            // t2 = t0 - r.x;\n            c.call(f2mPrefix + \"_sub\", t0, Rx, t2),\n\n            // t3 = t2.square();\n            c.call(f2mPrefix + \"_square\", t2, t3),\n\n            // t4 = t3 + t3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t4),\n\n            // t4 = t4 + t4;\n            c.call(f2mPrefix + \"_add\", t4, t4, t4),\n\n            // t5 = t4 * t2;\n            c.call(f2mPrefix + \"_mul\", t4, t2, t5),\n\n            // t6 = t1 - r.y - r.y;\n            c.call(f2mPrefix + \"_sub\", t1, Ry, t6),\n            c.call(f2mPrefix + \"_sub\", t6, Ry, t6),\n\n            // t9 = t6 * q.x;\n            c.call(f2mPrefix + \"_mul\", t6, Qx, t9),\n\n            // t7 = t4 * r.x;\n            c.call(f2mPrefix + \"_mul\", t4, Rx, t7),\n\n            // r.x = t6.square() - t5 - t7 - t7;\n            c.call(f2mPrefix + \"_square\", t6, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t5, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t7, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t7, Rx),\n\n            // r.z = (r.z + t2).square() - zsquared - t3;\n            c.call(f2mPrefix + \"_add\", Rz, t2, Rz),\n            c.call(f2mPrefix + \"_square\", Rz, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, zsquared, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, t3, Rz),\n\n            // t10 = q.y + r.z;\n            c.call(f2mPrefix + \"_add\", Qy, Rz, t10),\n\n            // t8 = (t7 - r.x) * t6;\n            c.call(f2mPrefix + \"_sub\", t7, Rx, t8),\n            c.call(f2mPrefix + \"_mul\", t8, t6, t8),\n\n            // t0 = r.y * t5;\n            c.call(f2mPrefix + \"_mul\", Ry, t5, t0),\n\n            // t0 = t0 + t0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t0),\n\n            // r.y = t8 - t0;\n            c.call(f2mPrefix + \"_sub\", t8, t0, Ry),\n\n            // t10 = t10.square() - ysquared;\n            c.call(f2mPrefix + \"_square\", t10, t10),\n            c.call(f2mPrefix + \"_sub\", t10, ysquared, t10),\n\n            // ztsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, ztsquared),\n\n            // t10 = t10 - ztsquared;\n            c.call(f2mPrefix + \"_sub\", t10, ztsquared, t10),\n\n            // t9 = t9 + t9 - t10;\n            c.call(f2mPrefix + \"_add\", t9, t9, t9),\n            c.call(f2mPrefix + \"_sub\", t9, t10, t9),\n\n            // t10 = r.z + r.z;\n            c.call(f2mPrefix + \"_add\", Rz, Rz, t10),\n\n            // t6 = -t6;\n            c.call(f2mPrefix + \"_neg\", t6, t6),\n\n            // t1 = t6 + t6;\n            c.call(f2mPrefix + \"_add\", t6, t6, t1),\n        );\n    }\n\n\n    function buildPrepareG2() {\n        const f = module.addFunction(prefix+ \"_prepareG2\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n\n        const Q = c.getLocal(\"pQ\");\n\n        const pR = module.alloc(f2size*3);\n        const R = c.i32_const(pR);\n\n        const base = c.getLocal(\"ppreQ\");\n\n        f.addCode(\n            c.call(g2mPrefix + \"_normalize\", Q, base),\n            c.if(\n                c.call(g2mPrefix + \"_isZero\", base),\n                c.ret([])\n            ),\n            c.call(g2mPrefix + \"_copy\", base, R),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n        );\n\n        f.addCode(\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n                c.call(prefix + \"_prepDblStep\", R, c.getLocal(\"pCoef\")),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_prepAddStep\", R, base, c.getLocal(\"pCoef\")),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    function buildF6Mul1() {\n        const f = module.addFunction(f6mPrefix+ \"_mul1\");\n        f.addParam(\"pA\", \"i32\");    // F6\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F6\n\n        const c = f.getCodeBuilder();\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*2));\n        const A_c2 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*4));\n\n        const c1  = c.getLocal(\"pC1\");\n\n        const t1 = c.getLocal(\"pR\");\n        const t2 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*2));\n        const b_b = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*4));\n\n        const Ac0_Ac1 = c.i32_const(module.alloc(f1size*2));\n        const Ac1_Ac2 = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n\n            c.call(f2mPrefix + \"_add\", A_c0, A_c1, Ac0_Ac1),\n            c.call(f2mPrefix + \"_add\", A_c1, A_c2, Ac1_Ac2),\n\n            // let b_b = self.c1 * c1;\n            c.call(f2mPrefix + \"_mul\", A_c1, c1, b_b),\n\n            // let t1 = (self.c1 + self.c2) * c1 - b_b;\n            c.call(f2mPrefix + \"_mul\", Ac1_Ac2, c1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, b_b, t1),\n\n            // let t1 = t1.mul_by_nonresidue();\n            c.call(f2mPrefix + \"_mulNR\", t1, t1),\n\n            // let t2 = (self.c0 + self.c1) * c1 - b_b;\n            c.call(f2mPrefix + \"_mul\", Ac0_Ac1, c1, t2),\n            c.call(f2mPrefix + \"_sub\", t2, b_b, t2),\n        );\n    }\n    buildF6Mul1();\n\n    function buildF6Mul01() {\n        const f = module.addFunction(f6mPrefix+ \"_mul01\");\n        f.addParam(\"pA\", \"i32\");    // F6\n        f.addParam(\"pC0\", \"i32\");   // F2\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F6\n\n        const c = f.getCodeBuilder();\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*2));\n        const A_c2 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*4));\n\n        const c0  = c.getLocal(\"pC0\");\n        const c1  = c.getLocal(\"pC1\");\n\n        const t1 = c.getLocal(\"pR\");\n        const t2 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*2));\n        const t3 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*4));\n\n        const a_a = c.i32_const(module.alloc(f1size*2));\n        const b_b = c.i32_const(module.alloc(f1size*2));\n        const Ac0_Ac1 = c.i32_const(module.alloc(f1size*2));\n        const Ac0_Ac2 = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n            // let a_a = self.c0 * c0;\n            c.call(f2mPrefix + \"_mul\", A_c0, c0, a_a),\n\n            // let b_b = self.c1 * c1;\n            c.call(f2mPrefix + \"_mul\", A_c1, c1, b_b),\n\n\n            c.call(f2mPrefix + \"_add\", A_c0, A_c1, Ac0_Ac1),\n            c.call(f2mPrefix + \"_add\", A_c0, A_c2, Ac0_Ac2),\n\n            // let t1 = (self.c1 + self.c2) * c1 - b_b;\n            c.call(f2mPrefix + \"_add\", A_c1, A_c2, t1),\n            c.call(f2mPrefix + \"_mul\", t1, c1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, b_b, t1),\n\n            // let t1 = t1.mul_by_nonresidue() + a_a;\n            c.call(f2mPrefix + \"_mulNR\", t1, t1),\n            c.call(f2mPrefix + \"_add\", t1, a_a, t1),\n\n            // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;\n            c.call(f2mPrefix + \"_add\", c0, c1, t2),\n            c.call(f2mPrefix + \"_mul\", t2, Ac0_Ac1, t2),\n            c.call(f2mPrefix + \"_sub\", t2, a_a, t2),\n            c.call(f2mPrefix + \"_sub\", t2, b_b, t2),\n\n            // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;\n            c.call(f2mPrefix + \"_mul\", Ac0_Ac2, c0, t3),\n            c.call(f2mPrefix + \"_sub\", t3, a_a, t3),\n            c.call(f2mPrefix + \"_add\", t3, b_b, t3),\n\n\n        );\n    }\n    buildF6Mul01();\n\n\n    function buildF12Mul014() {\n\n        const f = module.addFunction(ftmPrefix+ \"_mul014\");\n        f.addParam(\"pA\", \"i32\");    // F12\n        f.addParam(\"pC0\", \"i32\");   // F2\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pC4\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F12\n\n        const c = f.getCodeBuilder();\n\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*6));\n\n        const c0  = c.getLocal(\"pC0\");\n        const c1  = c.getLocal(\"pC1\");\n        const c4  = c.getLocal(\"pC4\");\n\n        const aa = c.i32_const(module.alloc(f1size*6));\n        const bb = c.i32_const(module.alloc(f1size*6));\n        const o = c.i32_const(module.alloc(f1size*2));\n\n        const R_c0 = c.getLocal(\"pR\");\n        const R_c1 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*6));\n\n        f.addCode(\n            // let aa = self.c0.mul_by_01(c0, c1);\n            c.call(f6mPrefix + \"_mul01\", A_c0, c0, c1, aa),\n\n            // let bb = self.c1.mul_by_1(c4);\n            c.call(f6mPrefix + \"_mul1\", A_c1, c4, bb),\n\n            // let o = c1 + c4;\n            c.call(f2mPrefix + \"_add\", c1, c4, o),\n\n            // let c1 = self.c1 + self.c0;\n            c.call(f6mPrefix + \"_add\", A_c1, A_c0, R_c1),\n\n            // let c1 = c1.mul_by_01(c0, &o);\n            c.call(f6mPrefix + \"_mul01\", R_c1, c0, o, R_c1),\n\n            // let c1 = c1 - aa - bb;\n            c.call(f6mPrefix + \"_sub\", R_c1, aa, R_c1),\n            c.call(f6mPrefix + \"_sub\", R_c1, bb, R_c1),\n\n            // let c0 = bb;\n            c.call(f6mPrefix + \"_copy\", bb, R_c0),\n\n            // let c0 = c0.mul_by_nonresidue();\n            c.call(f6mPrefix + \"_mulNR\", R_c0, R_c0),\n\n            // let c0 = c0 + aa;\n            c.call(f6mPrefix + \"_add\", R_c0, aa, R_c0),\n        );\n    }\n    buildF12Mul014();\n\n\n    function buildELL() {\n        const f = module.addFunction(prefix+ \"_ell\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"pCoefs\", \"i32\");\n        f.addParam(\"pF\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Px  = c.getLocal(\"pP\");\n        const Py  = c.i32_add(c.getLocal(\"pP\"), c.i32_const(n8q));\n\n        const F  = c.getLocal(\"pF\");\n\n        const coef0_0  = c.getLocal(\"pCoefs\");\n        const coef0_1  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size));\n        const coef1_0  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*2));\n        const coef1_1  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*3));\n        const coef2  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*4));\n\n        const pc0 = module.alloc(f1size*2);\n        const c0  = c.i32_const(pc0);\n        const c0_c0 = c.i32_const(pc0);\n        const c0_c1 = c.i32_const(pc0+f1size);\n\n        const pc1 = module.alloc(f1size*2);\n        const c1  = c.i32_const(pc1);\n        const c1_c0 = c.i32_const(pc1);\n        const c1_c1 = c.i32_const(pc1+f1size);\n        f.addCode(\n            //     let mut c0 = coeffs.0;\n            //     let mut c1 = coeffs.1;\n            //\n            //    c0.c0 *= p.y;\n            //    c0.c1 *= p.y;\n            //\n            //    c1.c0 *= p.x;\n            //    c1.c1 *= p.x;\n            //\n            //     f.mul_by_014(&coeffs.2, &c1, &c0)\n\n            c.call(f1mPrefix + \"_mul\", coef0_0, Py, c0_c0),\n            c.call(f1mPrefix + \"_mul\", coef0_1, Py, c0_c1),\n            c.call(f1mPrefix + \"_mul\", coef1_0, Px, c1_c0),\n            c.call(f1mPrefix + \"_mul\", coef1_1, Px, c1_c1),\n\n            c.call(ftmPrefix + \"_mul014\", F, coef2, c1, c0, F),\n\n        );\n\n    }\n    buildELL();\n\n    function buildMillerLoop() {\n        const f = module.addFunction(prefix+ \"_millerLoop\");\n        f.addParam(\"ppreP\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const preP = c.getLocal(\"ppreP\");\n\n        const coefs  = c.getLocal(\"pCoef\");\n\n        const F = c.getLocal(\"r\");\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_one\", F),\n\n            c.if(\n                c.call(g1mPrefix + \"_isZero\", preP),\n                c.ret([])\n            ),\n            c.if(\n                c.call(g1mPrefix + \"_isZero\", c.getLocal(\"ppreQ\")),\n                c.ret([])\n            ),\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n\n                c.call(prefix + \"_ell\", preP, coefs,  F),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_ell\", preP, coefs,  F),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.call(ftmPrefix + \"_square\", F, F),\n\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.i32_const(1) )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.call(prefix + \"_ell\", preP, coefs,  F),\n\n        );\n\n\n        if (isLoopNegative) {\n            f.addCode(\n                c.call(ftmPrefix + \"_conjugate\", F, F),\n            );\n        }\n    }\n\n\n    function buildFrobeniusMap(n) {\n        const F12 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],\n                [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],\n                [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],\n                [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],\n                [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n],\n            ]\n        ];\n\n        const F6 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [0n, 1n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n],\n            ],\n            [\n                [1n, 0n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],\n            ]\n        ];\n\n        const f = module.addFunction(ftmPrefix + \"_frobeniusMap\"+n);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<6; i++) {\n            const X = (i==0) ? c.getLocal(\"x\") : c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size));\n            const Xc0 = X;\n            const Xc1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size + f1size));\n            const R = (i==0) ? c.getLocal(\"r\") : c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size));\n            const Rc0 = R;\n            const Rc1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size + f1size));\n            const coef = mul2(F12[Math.floor(i/3)][n%12] , F6[i%3][n%6]);\n            const pCoef = module.alloc([\n                ...utils.bigInt2BytesLE(toMontgomery(coef[0]), n8q),\n                ...utils.bigInt2BytesLE(toMontgomery(coef[1]), n8q),\n            ]);\n            if (n%2 == 1) {\n                f.addCode(\n                    c.call(f1mPrefix + \"_copy\", Xc0, Rc0),\n                    c.call(f1mPrefix + \"_neg\", Xc1, Rc1),\n                    c.call(f2mPrefix + \"_mul\", R, c.i32_const(pCoef), R),\n                );\n            } else {\n                f.addCode(c.call(f2mPrefix + \"_mul\", X, c.i32_const(pCoef), R));\n            }\n        }\n\n        function mul2(a, b) {\n            const ac0 = a[0];\n            const ac1 = a[1];\n            const bc0 = b[0];\n            const bc1 = b[1];\n            const res = [\n                (ac0 * bc0 - (ac1 * bc1)) % q,\n                (ac0 * bc1 + (ac1 * bc0)) % q,\n            ];\n            if (isNegative(res[0])) res[0] = res[0] + q;\n            return res;\n        }\n\n    }\n\n\n    function buildCyclotomicSquare() {\n        const f = module.addFunction(prefix+ \"__cyclotomicSquare\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x4 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f2size));\n        const x3 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f2size));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(3*f2size));\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(4*f2size));\n        const x5 = c.i32_add(c.getLocal(\"x\"), c.i32_const(5*f2size));\n\n        const r0 = c.getLocal(\"r\");\n        const r4 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f2size));\n        const r3 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f2size));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(3*f2size));\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*f2size));\n        const r5 = c.i32_add(c.getLocal(\"r\"), c.i32_const(5*f2size));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const tmp = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n\n        f.addCode(\n            //    // t0 + t1*y = (z0 + z1*y)^2 = a^2\n            //    tmp = z0 * z1;\n            //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;\n            //    t1 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x0, x1, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x1, t0),\n            c.call(f2mPrefix + \"_add\", x0, t0, t0),\n            c.call(f2mPrefix + \"_add\", x0, x1, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t0, t0),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t0, AUX, t0),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t1),\n\n            //  // t2 + t3*y = (z2 + z3*y)^2 = b^2\n            //  tmp = z2 * z3;\n            //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;\n            //  t3 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x2, x3, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x3, t2),\n            c.call(f2mPrefix + \"_add\", x2, t2, t2),\n            c.call(f2mPrefix + \"_add\", x2, x3, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t2, t2),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t2, AUX, t2),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t3),\n\n            //  // t4 + t5*y = (z4 + z5*y)^2 = c^2\n            //  tmp = z4 * z5;\n            //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;\n            //  t5 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x4, x5, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x5, t4),\n            c.call(f2mPrefix + \"_add\", x4, t4, t4),\n            c.call(f2mPrefix + \"_add\", x4, x5, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t4, t4),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t4, AUX, t4),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t5),\n\n            // For A\n            // z0 = 3 * t0 - 2 * z0\n            c.call(f2mPrefix + \"_sub\", t0, x0, r0),\n            c.call(f2mPrefix + \"_add\", r0, r0, r0),\n            c.call(f2mPrefix + \"_add\", t0, r0, r0),\n            // z1 = 3 * t1 + 2 * z1\n            c.call(f2mPrefix + \"_add\", t1, x1, r1),\n            c.call(f2mPrefix + \"_add\", r1, r1, r1),\n            c.call(f2mPrefix + \"_add\", t1, r1, r1),\n\n            // For B\n            // z2 = 3 * (xi * t5) + 2 * z2\n            c.call(f2mPrefix + \"_mul\", t5, c.i32_const(pBls12381Twist), AUX),\n            c.call(f2mPrefix + \"_add\", AUX, x2, r2),\n            c.call(f2mPrefix + \"_add\", r2, r2, r2),\n            c.call(f2mPrefix + \"_add\", AUX, r2, r2),\n            // z3 = 3 * t4 - 2 * z3\n            c.call(f2mPrefix + \"_sub\", t4, x3, r3),\n            c.call(f2mPrefix + \"_add\", r3, r3, r3),\n            c.call(f2mPrefix + \"_add\", t4, r3, r3),\n\n            // For C\n            // z4 = 3 * t2 - 2 * z4\n            c.call(f2mPrefix + \"_sub\", t2, x4, r4),\n            c.call(f2mPrefix + \"_add\", r4, r4, r4),\n            c.call(f2mPrefix + \"_add\", t2, r4, r4),\n            // z5 = 3 * t3 + 2 * z5\n            c.call(f2mPrefix + \"_add\", t3, x5, r5),\n            c.call(f2mPrefix + \"_add\", r5, r5, r5),\n            c.call(f2mPrefix + \"_add\", t3, r5, r5),\n\n        );\n    }\n\n\n    function buildCyclotomicExp(exponent, isExpNegative, fnName) {\n        const exponentNafBytes = naf(exponent).map( (b) => (b==-1 ? 0xFF: b) );\n        const pExponentNafBytes = module.alloc(exponentNafBytes);\n        // const pExponent = module.alloc(utils.bigInt2BytesLE(exponent, n8));\n\n        const f = module.addFunction(prefix+ \"__cyclotomicExp_\"+fnName);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"bit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"x\");\n\n        const res = c.getLocal(\"r\");\n\n        const inverse = c.i32_const(module.alloc(ftsize));\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_conjugate\", x, inverse),\n            c.call(ftmPrefix + \"_one\", res),\n\n            c.if(\n                c.teeLocal(\"bit\", c.i32_load8_s(c.i32_const(exponentNafBytes.length-1), pExponentNafBytes)),\n                c.if(\n                    c.i32_eq(\n                        c.getLocal(\"bit\"),\n                        c.i32_const(1)\n                    ),\n                    c.call(ftmPrefix + \"_mul\", res, x, res),\n                    c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                )\n            ),\n\n            c.setLocal(\"i\", c.i32_const(exponentNafBytes.length-2)),\n            c.block(c.loop(\n                c.call(prefix + \"__cyclotomicSquare\", res, res),\n                c.if(\n                    c.teeLocal(\"bit\", c.i32_load8_s(c.getLocal(\"i\"), pExponentNafBytes)),\n                    c.if(\n                        c.i32_eq(\n                            c.getLocal(\"bit\"),\n                            c.i32_const(1)\n                        ),\n                        c.call(ftmPrefix + \"_mul\", res, x, res),\n                        c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                    )\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n        if (isExpNegative) {\n            f.addCode(\n                c.call(ftmPrefix + \"_conjugate\", res, res),\n            );\n        }\n\n    }\n\n    function buildFinalExponentiation() {\n        buildCyclotomicSquare();\n        buildCyclotomicExp(finalExpZ, finalExpIsNegative, \"w0\");\n\n        const f = module.addFunction(prefix+ \"_finalExponentiation\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const res = c.getLocal(\"r\");\n        const t0 = c.i32_const(module.alloc(ftsize));\n        const t1 = c.i32_const(module.alloc(ftsize));\n        const t2 = c.i32_const(module.alloc(ftsize));\n        const t3 = c.i32_const(module.alloc(ftsize));\n        const t4 = c.i32_const(module.alloc(ftsize));\n        const t5 = c.i32_const(module.alloc(ftsize));\n        const t6 = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n\n            // let mut t0 = f.frobenius_map(6)\n            c.call(ftmPrefix + \"_frobeniusMap6\", elt, t0),\n\n            // let t1 = f.invert()\n            c.call(ftmPrefix + \"_inverse\", elt, t1),\n\n            // let mut t2 = t0 * t1;\n            c.call(ftmPrefix + \"_mul\", t0, t1, t2),\n\n            // t1 = t2.clone();\n            c.call(ftmPrefix + \"_copy\", t2, t1),\n\n            // t2 = t2.frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap2\", t2, t2),\n\n            // t2 *= t1;\n            c.call(ftmPrefix + \"_mul\", t2, t1, t2),\n\n\n            // t1 = cyclotomic_square(t2).conjugate();\n            c.call(prefix + \"__cyclotomicSquare\", t2, t1),\n            c.call(ftmPrefix + \"_conjugate\", t1, t1),\n\n            // let mut t3 = cycolotomic_exp(t2);\n            c.call(prefix + \"__cyclotomicExp_w0\", t2, t3),\n\n            // let mut t4 = cyclotomic_square(t3);\n            c.call(prefix + \"__cyclotomicSquare\", t3, t4),\n\n            // let mut t5 = t1 * t3;\n            c.call(ftmPrefix + \"_mul\", t1, t3, t5),\n\n            // t1 = cycolotomic_exp(t5);\n            c.call(prefix + \"__cyclotomicExp_w0\", t5, t1),\n\n            // t0 = cycolotomic_exp(t1);\n            c.call(prefix + \"__cyclotomicExp_w0\", t1, t0),\n\n            // let mut t6 = cycolotomic_exp(t0);\n            c.call(prefix + \"__cyclotomicExp_w0\", t0, t6),\n\n            // t6 *= t4;\n            c.call(ftmPrefix + \"_mul\", t6, t4, t6),\n\n            // t4 = cycolotomic_exp(t6);\n            c.call(prefix + \"__cyclotomicExp_w0\", t6, t4),\n\n            // t5 = t5.conjugate();\n            c.call(ftmPrefix + \"_conjugate\", t5, t5),\n\n            // t4 *= t5 * t2;\n            c.call(ftmPrefix + \"_mul\", t4, t5, t4),\n            c.call(ftmPrefix + \"_mul\", t4, t2, t4),\n\n            // t5 = t2.conjugate();\n            c.call(ftmPrefix + \"_conjugate\", t2, t5),\n\n            // t1 *= t2;\n            c.call(ftmPrefix + \"_mul\", t1, t2, t1),\n\n            // t1 = t1.frobenius_map().frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap3\", t1, t1),\n\n            // t6 *= t5;\n            c.call(ftmPrefix + \"_mul\", t6, t5, t6),\n\n            // t6 = t6.frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap1\", t6, t6),\n\n            // t3 *= t0;\n            c.call(ftmPrefix + \"_mul\", t3, t0, t3),\n\n            // t3 = t3.frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap2\", t3, t3),\n\n            // t3 *= t1;\n            c.call(ftmPrefix + \"_mul\", t3, t1, t3),\n\n            // t3 *= t6;\n            c.call(ftmPrefix + \"_mul\", t3, t6, t3),\n\n            // f = t3 * t4;\n            c.call(ftmPrefix + \"_mul\", t3, t4, res),\n\n        );\n    }\n\n\n    function buildFinalExponentiationOld() {\n        const f = module.addFunction(prefix+ \"_finalExponentiationOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;\n\n        const pExponent = module.alloc(utils.bigInt2BytesLE( exponent, 544 ));\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(ftmPrefix + \"_exp\", c.getLocal(\"x\"), c.i32_const(pExponent), c.i32_const(544), c.getLocal(\"r\")),\n        );\n    }\n\n\n    const pPreP = module.alloc(prePSize);\n    const pPreQ = module.alloc(preQSize);\n\n    function buildPairingEquation(nPairings) {\n\n        const f = module.addFunction(prefix+ \"_pairingEq\"+nPairings);\n        for (let i=0; i<nPairings; i++) {\n            f.addParam(\"p_\"+i, \"i32\");\n            f.addParam(\"q_\"+i, \"i32\");\n        }\n        f.addParam(\"c\", \"i32\");\n        f.setReturnType(\"i32\");\n\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n        const auxT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(ftmPrefix + \"_one\", resT ));\n\n        for (let i=0; i<nPairings; i++) {\n\n            f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p_\"+i), c.i32_const(pPreP) ));\n            f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q_\"+i), c.i32_const(pPreQ) ));\n\n            // Checks\n            f.addCode(\n                c.if(\n                    c.i32_eqz(c.call(g1mPrefix + \"_inGroupAffine\", c.i32_const(pPreP))),\n                    c.ret(c.i32_const(0))\n                ),\n                c.if(\n                    c.i32_eqz(c.call(g2mPrefix + \"_inGroupAffine\", c.i32_const(pPreQ))),\n                    c.ret(c.i32_const(0))\n                )\n            );\n\n            f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), auxT ));\n\n            f.addCode(c.call(ftmPrefix + \"_mul\", resT, auxT, resT ));\n        }\n\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, resT ));\n\n        f.addCode(c.call(ftmPrefix + \"_eq\", resT, c.getLocal(\"c\")));\n    }\n\n\n    function buildPairing() {\n\n        const f = module.addFunction(prefix+ \"_pairing\");\n        f.addParam(\"p\", \"i32\");\n        f.addParam(\"q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p\"), c.i32_const(pPreP) ));\n        f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q\"), c.i32_const(pPreQ) ));\n        f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), resT ));\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, c.getLocal(\"r\") ));\n    }\n\n\n    function buildInGroupG2() {\n        const f = module.addFunction(g2mPrefix+ \"_inGroupAffine\");\n        f.addParam(\"p\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const WINV = [\n            2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,\n            2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n\n        ];\n\n        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;\n        const FROB3Y = [\n            2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,\n            2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n\n        ];\n\n        const wInv = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),\n            ...utils.bigInt2BytesLE(toMontgomery(WINV[1]), n8q),\n        ]));\n\n        const frob2X = c.i32_const(module.alloc(utils.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));\n        const frob3Y = c.i32_const(module.alloc([\n            ...utils.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),\n            ...utils.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q),\n        ]));\n\n        const z = c.i32_const(module.alloc(utils.bigInt2BytesLE(finalExpZ, 8)));\n\n        const px = c.getLocal(\"p\");\n        const py = c.i32_add(c.getLocal(\"p\"), c.i32_const(f2size));\n\n        const aux = c.i32_const(module.alloc(f1size));\n\n        const x_winv = c.i32_const(module.alloc(f2size));\n        const y_winv = c.i32_const(module.alloc(f2size));\n        const pf2 = module.alloc(f2size*2);\n        const f2 = c.i32_const(pf2);\n        const f2x = c.i32_const(pf2);\n        const f2x_c1 = c.i32_const(pf2);\n        const f2x_c2 = c.i32_const(pf2+f1size);\n        const f2y = c.i32_const(pf2+f2size);\n        const f2y_c1 = c.i32_const(pf2+f2size);\n        const f2y_c2 = c.i32_const(pf2+f2size+f1size);\n        const pf3 = module.alloc(f2size*3);\n        const f3 = c.i32_const(pf3);\n        const f3x = c.i32_const(pf3);\n        const f3x_c1 = c.i32_const(pf3);\n        const f3x_c2 = c.i32_const(pf3+f1size);\n        const f3y = c.i32_const(pf3+f2size);\n        const f3y_c1 = c.i32_const(pf3+f2size);\n        const f3y_c2 = c.i32_const(pf3+f2size+f1size);\n        const f3z = c.i32_const(pf3+f2size*2);\n\n\n        f.addCode(\n            c.if(\n                c.call(g2mPrefix + \"_isZeroAffine\", c.getLocal(\"p\")),\n                c.ret( c.i32_const(1)),\n            ),\n            c.if(\n                c.i32_eqz(c.call(g2mPrefix + \"_inCurveAffine\", c.getLocal(\"p\"))),\n                c.ret( c.i32_const(0)),\n            ),\n            c.call(f2mPrefix + \"_mul\", px, wInv, x_winv),\n            c.call(f2mPrefix + \"_mul\", py, wInv, y_winv),\n\n            c.call(f2mPrefix + \"_mul1\", x_winv, frob2X, f2x),\n            c.call(f2mPrefix + \"_neg\", y_winv, f2y),\n\n            c.call(f2mPrefix + \"_neg\", x_winv, f3x),\n            c.call(f2mPrefix + \"_mul\", y_winv, frob3Y, f3y),\n\n            c.call(f1mPrefix + \"_sub\", f2x_c1, f2x_c2, aux),\n            c.call(f1mPrefix + \"_add\", f2x_c1, f2x_c2, f2x_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f2x_c1),\n\n            c.call(f1mPrefix + \"_sub\", f2y_c1, f2y_c2, aux),\n            c.call(f1mPrefix + \"_add\", f2y_c1, f2y_c2, f2y_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f2y_c1),\n\n            c.call(f1mPrefix + \"_add\", f3x_c1, f3x_c2, aux),\n            c.call(f1mPrefix + \"_sub\", f3x_c1, f3x_c2, f3x_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f3x_c1),\n\n            c.call(f1mPrefix + \"_sub\", f3y_c2, f3y_c1, aux),\n            c.call(f1mPrefix + \"_add\", f3y_c1, f3y_c2, f3y_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f3y_c1),\n\n            c.call(f2mPrefix + \"_one\", f3z),\n\n            c.call(g2mPrefix + \"_timesScalar\", f3, z, c.i32_const(8), f3),\n            c.call(g2mPrefix + \"_addMixed\", f3, f2, f3),\n\n            c.ret(\n                c.call(g2mPrefix + \"_eqMixed\", f3, c.getLocal(\"p\"))\n            )\n        );\n\n        const fInGroup = module.addFunction(g2mPrefix + \"_inGroup\");\n        fInGroup.addParam(\"pIn\", \"i32\");\n        fInGroup.setReturnType(\"i32\");\n\n        const c2 = fInGroup.getCodeBuilder();\n\n        const aux2 = c2.i32_const(module.alloc(f2size*2));\n\n        fInGroup.addCode(\n            c2.call(g2mPrefix + \"_toAffine\", c2.getLocal(\"pIn\"), aux2),\n\n            c2.ret(\n                c2.call(g2mPrefix + \"_inGroupAffine\", aux2),\n            )\n        );\n\n    }\n\n    function buildInGroupG1() {\n        const f = module.addFunction(g1mPrefix+ \"_inGroupAffine\");\n        f.addParam(\"p\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;\n        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;\n        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;\n\n        const beta = c.i32_const(module.alloc(utils.bigInt2BytesLE(toMontgomery(BETA), n8q)));\n        const beta2 = c.i32_const(module.alloc(utils.bigInt2BytesLE(toMontgomery(BETA2), n8q)));\n\n        const z2m1d3 = c.i32_const(module.alloc(utils.bigInt2BytesLE(Z2M1D3, 16)));\n\n\n        const px = c.getLocal(\"p\");\n        const py = c.i32_add(c.getLocal(\"p\"), c.i32_const(f1size));\n\n        const psp = module.alloc(f1size*3);\n        const sp = c.i32_const(psp);\n        const spx = c.i32_const(psp);\n        const spy = c.i32_const(psp+f1size);\n\n        const ps2p = module.alloc(f1size*2);\n        const s2p = c.i32_const(ps2p);\n        const s2px = c.i32_const(ps2p);\n        const s2py = c.i32_const(ps2p+f1size);\n\n        f.addCode(\n            c.if(\n                c.call(g1mPrefix + \"_isZeroAffine\", c.getLocal(\"p\")),\n                c.ret( c.i32_const(1)),\n            ),\n            c.if(\n                c.i32_eqz(c.call(g1mPrefix + \"_inCurveAffine\", c.getLocal(\"p\"))),\n                c.ret( c.i32_const(0)),\n            ),\n\n            c.call(f1mPrefix + \"_mul\", px, beta, spx),\n            c.call(f1mPrefix + \"_copy\", py, spy),\n\n            c.call(f1mPrefix + \"_mul\", px, beta2, s2px),\n            c.call(f1mPrefix + \"_copy\", py, s2py),\n\n\n            c.call(g1mPrefix + \"_doubleAffine\", sp, sp),\n            c.call(g1mPrefix + \"_subMixed\", sp, c.getLocal(\"p\"), sp),\n            c.call(g1mPrefix + \"_subMixed\", sp, s2p, sp),\n\n            c.call(g1mPrefix + \"_timesScalar\", sp, z2m1d3, c.i32_const(16), sp),\n\n            c.ret(\n                c.call(g1mPrefix + \"_eqMixed\", sp, s2p)\n            )\n\n        );\n\n        const fInGroup = module.addFunction(g1mPrefix + \"_inGroup\");\n        fInGroup.addParam(\"pIn\", \"i32\");\n        fInGroup.setReturnType(\"i32\");\n\n        const c2 = fInGroup.getCodeBuilder();\n\n        const aux2 = c2.i32_const(module.alloc(f1size*2));\n\n        fInGroup.addCode(\n            c2.call(g1mPrefix + \"_toAffine\", c2.getLocal(\"pIn\"), aux2),\n\n            c2.ret(\n                c2.call(g1mPrefix + \"_inGroupAffine\", aux2),\n            )\n        );\n    }\n\n    for (let i=0; i<10; i++) {\n        buildFrobeniusMap(i);\n        module.exportFunction(ftmPrefix + \"_frobeniusMap\"+i);\n    }\n\n\n    buildInGroupG1();\n    buildInGroupG2();\n\n    buildPrepAddStep();\n    buildPrepDoubleStep();\n\n    buildPrepareG1();\n    buildPrepareG2();\n\n    buildMillerLoop();\n\n    buildFinalExponentiationOld();\n    buildFinalExponentiation();\n\n    for (let i=1; i<=5; i++) {\n        buildPairingEquation(i);\n        module.exportFunction(prefix + \"_pairingEq\"+i);\n    }\n\n    buildPairing();\n\n    module.exportFunction(prefix + \"_pairing\");\n\n\n    module.exportFunction(prefix + \"_prepareG1\");\n    module.exportFunction(prefix + \"_prepareG2\");\n    module.exportFunction(prefix + \"_millerLoop\");\n    module.exportFunction(prefix + \"_finalExponentiation\");\n    module.exportFunction(prefix + \"_finalExponentiationOld\");\n    module.exportFunction(prefix + \"__cyclotomicSquare\");\n    module.exportFunction(prefix + \"__cyclotomicExp_w0\");\n\n    module.exportFunction(f6mPrefix + \"_mul1\");\n    module.exportFunction(f6mPrefix + \"_mul01\");\n    module.exportFunction(ftmPrefix + \"_mul014\");\n\n    module.exportFunction(g1mPrefix + \"_inGroupAffine\");\n    module.exportFunction(g1mPrefix + \"_inGroup\");\n    module.exportFunction(g2mPrefix + \"_inGroupAffine\");\n    module.exportFunction(g2mPrefix + \"_inGroup\");\n\n    // console.log(module.functionIdxByName);\n};\n\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n// module.exports.bn128_wasm = require(\"./build/bn128_wasm.js\");\n// module.exports.bls12381_wasm = require(\"./build/bls12381_wasm.js\");\n// module.exports.mnt6753_wasm = require(\"./build/mnt6753_wasm.js\");\n\nmodule.exports.buildBn128 = require(\"./src/bn128/build_bn128.js\");\nmodule.exports.buildBls12381 = require(\"./src/bls12381/build_bls12381.js\");\n// module.exports.buildMnt6753 = require(\"./src/mnt6753/build_mnt7.js\");\n\nmodule.exports.buildF1m = require(\"./src/build_f1m\");\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst URL = require('url');\n\nconst VM = require('vm');\n\nconst threads = require('worker_threads');\n\nconst WORKER = Symbol.for('worker');\nconst EVENTS = Symbol.for('events');\n\nclass EventTarget {\n  constructor() {\n    Object.defineProperty(this, EVENTS, {\n      value: new Map()\n    });\n  }\n\n  dispatchEvent(event) {\n    event.target = event.currentTarget = this;\n\n    if (this['on' + event.type]) {\n      try {\n        this['on' + event.type](event);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    const list = this[EVENTS].get(event.type);\n    if (list == null) return;\n    list.forEach(handler => {\n      try {\n        handler.call(this, event);\n      } catch (err) {\n        console.error(err);\n      }\n    });\n  }\n\n  addEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n    if (!events) this[EVENTS].set(type, events = []);\n    events.push(fn);\n  }\n\n  removeEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n\n    if (events) {\n      const index = events.indexOf(fn);\n      if (index !== -1) events.splice(index, 1);\n    }\n  }\n\n}\n\nfunction Event(type, target) {\n  this.type = type;\n  this.timeStamp = Date.now();\n  this.target = this.currentTarget = this.data = null;\n} // this module is used self-referentially on both sides of the\n// thread boundary, but behaves differently in each context.\n\n\nmodule.exports = threads.isMainThread ? mainThread() : workerThread();\nconst baseUrl = URL.pathToFileURL(process.cwd() + '/');\n\nfunction mainThread() {\n  /**\n   * A web-compatible Worker implementation atop Node's worker_threads.\n   *  - uses DOM-style events (Event.data, Event.type, etc)\n   *  - supports event handler properties (worker.onmessage)\n   *  - Worker() constructor accepts a module URL\n   *  - accepts the {type:'module'} option\n   *  - emulates WorkerGlobalScope within the worker\n   * @param {string} url  The URL or module specifier to load\n   * @param {object} [options]  Worker construction options\n   * @param {string} [options.name]  Available as `self.name` within the Worker\n   * @param {string} [options.type=\"classic\"]  Pass \"module\" to create a Module Worker.\n   */\n  class Worker extends EventTarget {\n    constructor(url, options) {\n      super();\n      const {\n        name,\n        type\n      } = options || {};\n      url += '';\n      let mod;\n\n      if (/^data:/.test(url)) {\n        mod = url;\n      } else {\n        mod = URL.fileURLToPath(new URL.URL(url, baseUrl));\n      }\n\n      const worker = new threads.Worker(__filename, {\n        workerData: {\n          mod,\n          name,\n          type\n        }\n      });\n      Object.defineProperty(this, WORKER, {\n        value: worker\n      });\n      worker.on('message', data => {\n        const event = new Event('message');\n        event.data = data;\n        this.dispatchEvent(event);\n      });\n      worker.on('error', error => {\n        error.type = 'error';\n        this.dispatchEvent(error);\n      });\n      worker.on('exit', () => {\n        this.dispatchEvent(new Event('close'));\n      });\n    }\n\n    postMessage(data, transferList) {\n      this[WORKER].postMessage(data, transferList);\n    }\n\n    terminate() {\n      this[WORKER].terminate();\n    }\n\n  }\n\n  Worker.prototype.onmessage = Worker.prototype.onerror = Worker.prototype.onclose = null;\n  return Worker;\n}\n\nfunction workerThread() {\n  let {\n    mod,\n    name,\n    type\n  } = threads.workerData; // turn global into a mock WorkerGlobalScope\n\n  const self = global.self = global; // enqueue messages to dispatch after modules are loaded\n\n  let q = [];\n\n  function flush() {\n    const buffered = q;\n    q = null;\n    buffered.forEach(event => {\n      self.dispatchEvent(event);\n    });\n  }\n\n  threads.parentPort.on('message', data => {\n    const event = new Event('message');\n    event.data = data;\n    if (q == null) self.dispatchEvent(event);else q.push(event);\n  });\n  threads.parentPort.on('error', err => {\n    err.type = 'Error';\n    self.dispatchEvent(err);\n  });\n\n  class WorkerGlobalScope extends EventTarget {\n    postMessage(data, transferList) {\n      threads.parentPort.postMessage(data, transferList);\n    } // Emulates https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/close\n\n\n    close() {\n      process.exit();\n    }\n\n  }\n\n  let proto = Object.getPrototypeOf(global);\n  delete proto.constructor;\n  Object.defineProperties(WorkerGlobalScope.prototype, proto);\n  proto = Object.setPrototypeOf(global, new WorkerGlobalScope());\n  ['postMessage', 'addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(fn => {\n    proto[fn] = proto[fn].bind(global);\n  });\n  global.name = name;\n  const isDataUrl = /^data:/.test(mod);\n\n  if (type === 'module') {\n    import(mod).catch(err => {\n      if (isDataUrl && err.message === 'Not supported') {\n        console.warn('Worker(): Importing data: URLs requires Node 12.10+. Falling back to classic worker.');\n        return evaluateDataUrl(mod, name);\n      }\n\n      console.error(err);\n    }).then(flush);\n  } else {\n    try {\n      if (/^data:/.test(mod)) {\n        evaluateDataUrl(mod, name);\n      } else {\n        require(mod);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n\n    Promise.resolve().then(flush);\n  }\n}\n\nfunction evaluateDataUrl(url, name) {\n  const {\n    data\n  } = parseDataUrl(url);\n  return VM.runInThisContext(data, {\n    filename: 'worker.<' + (name || 'data:') + '>'\n  });\n}\n\nfunction parseDataUrl(url) {\n  let [m, type, encoding, data] = url.match(/^data: *([^;,]*)(?: *; *([^,]*))? *,(.*)$/) || [];\n  if (!m) throw Error('Invalid Data URL.');\n  if (encoding) switch (encoding.toLowerCase()) {\n    case 'base64':\n      data = Buffer.from(data, 'base64').toString();\n      break;\n\n    default:\n      throw Error('Unknown Data URL encoding \"' + encoding + '\"');\n  }\n  return {\n    type,\n    data\n  };\n}","/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n/**\n * Private utility functions\n * @module utils\n * @private\n */\n\n'use strict';\n\nvar regExpChars = /[|\\\\{}()[\\]^$+*?.]/g;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hasOwn = function (obj, key) { return hasOwnProperty.apply(obj, [key]); };\n\n/**\n * Escape characters reserved in regular expressions.\n *\n * If `string` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} string Input string\n * @return {String} Escaped string\n * @static\n * @private\n */\nexports.escapeRegExpChars = function (string) {\n  // istanbul ignore if\n  if (!string) {\n    return '';\n  }\n  return String(string).replace(regExpChars, '\\\\$&');\n};\n\nvar _ENCODE_HTML_RULES = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&#34;',\n  \"'\": '&#39;'\n};\nvar _MATCH_HTML = /[&<>'\"]/g;\n\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n}\n\n/**\n * Stringified version of constants used by {@link module:utils.escapeXML}.\n *\n * It is used in the process of generating {@link ClientFunction}s.\n *\n * @readonly\n * @type {String}\n */\n\nvar escapeFuncStr =\n  'var _ENCODE_HTML_RULES = {\\n'\n+ '      \"&\": \"&amp;\"\\n'\n+ '    , \"<\": \"&lt;\"\\n'\n+ '    , \">\": \"&gt;\"\\n'\n+ '    , \\'\"\\': \"&#34;\"\\n'\n+ '    , \"\\'\": \"&#39;\"\\n'\n+ '    }\\n'\n+ '  , _MATCH_HTML = /[&<>\\'\"]/g;\\n'\n+ 'function encode_char(c) {\\n'\n+ '  return _ENCODE_HTML_RULES[c] || c;\\n'\n+ '};\\n';\n\n/**\n * Escape characters reserved in XML.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @implements {EscapeCallback}\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @static\n * @private\n */\n\nexports.escapeXML = function (markup) {\n  return markup == undefined\n    ? ''\n    : String(markup)\n      .replace(_MATCH_HTML, encode_char);\n};\n\nfunction escapeXMLToString() {\n  return Function.prototype.toString.call(this) + ';\\n' + escapeFuncStr;\n}\n\ntry {\n  if (typeof Object.defineProperty === 'function') {\n  // If the Function prototype is frozen, the \"toString\" property is non-writable. This means that any objects which inherit this property\n  // cannot have the property changed using an assignment. If using strict mode, attempting that will cause an error. If not using strict\n  // mode, attempting that will be silently ignored.\n  // However, we can still explicitly shadow the prototype's \"toString\" property by defining a new \"toString\" property on this object.\n    Object.defineProperty(exports.escapeXML, 'toString', { value: escapeXMLToString });\n  } else {\n    // If Object.defineProperty() doesn't exist, attempt to shadow this property using the assignment operator.\n    exports.escapeXML.toString = escapeXMLToString;\n  }\n} catch (err) {\n  console.warn('Unable to set escapeXML.toString (is the Function prototype frozen?)');\n}\n\n/**\n * Naive copy of properties from one object to another.\n * Does not recurse into non-scalar properties\n * Does not check to see if the property has a value before copying\n *\n * @param  {Object} to   Destination object\n * @param  {Object} from Source object\n * @return {Object}      Destination object\n * @static\n * @private\n */\nexports.shallowCopy = function (to, from) {\n  from = from || {};\n  if ((to !== null) && (to !== undefined)) {\n    for (var p in from) {\n      if (!hasOwn(from, p)) {\n        continue;\n      }\n      if (p === '__proto__' || p === 'constructor') {\n        continue;\n      }\n      to[p] = from[p];\n    }\n  }\n  return to;\n};\n\n/**\n * Naive copy of a list of key names, from one object to another.\n * Only copies property if it is actually defined\n * Does not recurse into non-scalar properties\n *\n * @param  {Object} to   Destination object\n * @param  {Object} from Source object\n * @param  {Array} list List of properties to copy\n * @return {Object}      Destination object\n * @static\n * @private\n */\nexports.shallowCopyFromList = function (to, from, list) {\n  list = list || [];\n  from = from || {};\n  if ((to !== null) && (to !== undefined)) {\n    for (var i = 0; i < list.length; i++) {\n      var p = list[i];\n      if (typeof from[p] != 'undefined') {\n        if (!hasOwn(from, p)) {\n          continue;\n        }\n        if (p === '__proto__' || p === 'constructor') {\n          continue;\n        }\n        to[p] = from[p];\n      }\n    }\n  }\n  return to;\n};\n\n/**\n * Simple in-process cache implementation. Does not implement limits of any\n * sort.\n *\n * @implements {Cache}\n * @static\n * @private\n */\nexports.cache = {\n  _data: {},\n  set: function (key, val) {\n    this._data[key] = val;\n  },\n  get: function (key) {\n    return this._data[key];\n  },\n  remove: function (key) {\n    delete this._data[key];\n  },\n  reset: function () {\n    this._data = {};\n  }\n};\n\n/**\n * Transforms hyphen case variable into camel case.\n *\n * @param {String} string Hyphen case string\n * @return {String} Camel case string\n * @static\n * @private\n */\nexports.hyphenToCamel = function (str) {\n  return str.replace(/-[a-z]/g, function (match) { return match[1].toUpperCase(); });\n};\n\n/**\n * Returns a null-prototype object in runtimes that support it\n *\n * @return {Object} Object, prototype will be set to null where possible\n * @static\n * @private\n */\nexports.createNullProtoObjWherePossible = (function () {\n  if (typeof Object.create == 'function') {\n    return function () {\n      return Object.create(null);\n    };\n  }\n  if (!({__proto__: null} instanceof Object)) {\n    return function () {\n      return {__proto__: null};\n    };\n  }\n  // Not possible, just pass through\n  return function () {\n    return {};\n  };\n})();\n\nexports.hasOwnOnlyObject = function (obj) {\n  var o = exports.createNullProtoObjWherePossible();\n  for (var p in obj) {\n    if (hasOwn(obj, p)) {\n      o[p] = obj[p];\n    }\n  }\n  return o;\n};\n\n","{\"name\":\"ejs\",\"description\":\"Embedded JavaScript templates\",\"keywords\":[\"template\",\"engine\",\"ejs\"],\"version\":\"3.1.10\",\"author\":\"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)\",\"license\":\"Apache-2.0\",\"bin\":{\"ejs\":\"./bin/cli.js\"},\"main\":\"./lib/ejs.js\",\"jsdelivr\":\"ejs.min.js\",\"unpkg\":\"ejs.min.js\",\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/mde/ejs.git\"},\"bugs\":\"https://github.com/mde/ejs/issues\",\"homepage\":\"https://github.com/mde/ejs\",\"dependencies\":{\"jake\":\"^10.8.5\"},\"devDependencies\":{\"browserify\":\"^16.5.1\",\"eslint\":\"^6.8.0\",\"git-directory-deploy\":\"^1.5.1\",\"jsdoc\":\"^4.0.2\",\"lru-cache\":\"^4.0.1\",\"mocha\":\"^10.2.0\",\"uglify-js\":\"^3.3.16\"},\"engines\":{\"node\":\">=0.10.0\"},\"scripts\":{\"test\":\"npx jake test\"}}","/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n'use strict';\n\n/**\n * @file Embedded JavaScript templating engine. {@link http://ejs.co}\n * @author Matthew Eernisse <mde@fleegix.org>\n * @author Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n * @project EJS\n * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}\n */\n\n/**\n * EJS internal functions.\n *\n * Technically this \"module\" lies in the same file as {@link module:ejs}, for\n * the sake of organization all the private functions re grouped into this\n * module.\n *\n * @module ejs-internal\n * @private\n */\n\n/**\n * Embedded JavaScript templating engine.\n *\n * @module ejs\n * @public\n */\n\n\nvar fs = require('fs');\nvar path = require('path');\nvar utils = require('./utils');\n\nvar scopeOptionWarned = false;\n/** @type {string} */\nvar _VERSION_STRING = require('../package.json').version;\nvar _DEFAULT_OPEN_DELIMITER = '<';\nvar _DEFAULT_CLOSE_DELIMITER = '>';\nvar _DEFAULT_DELIMITER = '%';\nvar _DEFAULT_LOCALS_NAME = 'locals';\nvar _NAME = 'ejs';\nvar _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';\nvar _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug',\n  'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];\n// We don't allow 'cache' option to be passed in the data obj for\n// the normal `render` call, but this is where Express 2 & 3 put it\n// so we make an exception for `renderFile`\nvar _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');\nvar _BOM = /^\\uFEFF/;\nvar _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\n\n/**\n * EJS template function cache. This can be a LRU object from lru-cache NPM\n * module. By default, it is {@link module:utils.cache}, a simple in-process\n * cache that grows continuously.\n *\n * @type {Cache}\n */\n\nexports.cache = utils.cache;\n\n/**\n * Custom file loader. Useful for template preprocessing or restricting access\n * to a certain part of the filesystem.\n *\n * @type {fileLoader}\n */\n\nexports.fileLoader = fs.readFileSync;\n\n/**\n * Name of the object containing the locals.\n *\n * This variable is overridden by {@link Options}`.localsName` if it is not\n * `undefined`.\n *\n * @type {String}\n * @public\n */\n\nexports.localsName = _DEFAULT_LOCALS_NAME;\n\n/**\n * Promise implementation -- defaults to the native implementation if available\n * This is mostly just for testability\n *\n * @type {PromiseConstructorLike}\n * @public\n */\n\nexports.promiseImpl = (new Function('return this;'))().Promise;\n\n/**\n * Get the path to the included file from the parent file path and the\n * specified path.\n *\n * @param {String}  name     specified path\n * @param {String}  filename parent file path\n * @param {Boolean} [isDir=false] whether the parent file path is a directory\n * @return {String}\n */\nexports.resolveInclude = function(name, filename, isDir) {\n  var dirname = path.dirname;\n  var extname = path.extname;\n  var resolve = path.resolve;\n  var includePath = resolve(isDir ? filename : dirname(filename), name);\n  var ext = extname(name);\n  if (!ext) {\n    includePath += '.ejs';\n  }\n  return includePath;\n};\n\n/**\n * Try to resolve file path on multiple directories\n *\n * @param  {String}        name  specified path\n * @param  {Array<String>} paths list of possible parent directory paths\n * @return {String}\n */\nfunction resolvePaths(name, paths) {\n  var filePath;\n  if (paths.some(function (v) {\n    filePath = exports.resolveInclude(name, v, true);\n    return fs.existsSync(filePath);\n  })) {\n    return filePath;\n  }\n}\n\n/**\n * Get the path to the included file by Options\n *\n * @param  {String}  path    specified path\n * @param  {Options} options compilation options\n * @return {String}\n */\nfunction getIncludePath(path, options) {\n  var includePath;\n  var filePath;\n  var views = options.views;\n  var match = /^[A-Za-z]+:\\\\|^\\//.exec(path);\n\n  // Abs path\n  if (match && match.length) {\n    path = path.replace(/^\\/*/, '');\n    if (Array.isArray(options.root)) {\n      includePath = resolvePaths(path, options.root);\n    } else {\n      includePath = exports.resolveInclude(path, options.root || '/', true);\n    }\n  }\n  // Relative paths\n  else {\n    // Look relative to a passed filename first\n    if (options.filename) {\n      filePath = exports.resolveInclude(path, options.filename);\n      if (fs.existsSync(filePath)) {\n        includePath = filePath;\n      }\n    }\n    // Then look in any views directories\n    if (!includePath && Array.isArray(views)) {\n      includePath = resolvePaths(path, views);\n    }\n    if (!includePath && typeof options.includer !== 'function') {\n      throw new Error('Could not find the include file \"' +\n          options.escapeFunction(path) + '\"');\n    }\n  }\n  return includePath;\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `template` is not set, the file specified in `options.filename` will be\n * read.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @memberof module:ejs-internal\n * @param {Options} options   compilation options\n * @param {String} [template] template source\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned.\n * @static\n */\n\nfunction handleCache(options, template) {\n  var func;\n  var filename = options.filename;\n  var hasTemplate = arguments.length > 1;\n\n  if (options.cache) {\n    if (!filename) {\n      throw new Error('cache option requires a filename');\n    }\n    func = exports.cache.get(filename);\n    if (func) {\n      return func;\n    }\n    if (!hasTemplate) {\n      template = fileLoader(filename).toString().replace(_BOM, '');\n    }\n  }\n  else if (!hasTemplate) {\n    // istanbul ignore if: should not happen at all\n    if (!filename) {\n      throw new Error('Internal EJS error: no file name or template '\n                    + 'provided');\n    }\n    template = fileLoader(filename).toString().replace(_BOM, '');\n  }\n  func = exports.compile(template, options);\n  if (options.cache) {\n    exports.cache.set(filename, func);\n  }\n  return func;\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @memberof module:ejs-internal\n * @param {Options} options    compilation options\n * @param {Object} data        template data\n * @param {RenderFileCallback} cb callback\n * @static\n */\n\nfunction tryHandleCache(options, data, cb) {\n  var result;\n  if (!cb) {\n    if (typeof exports.promiseImpl == 'function') {\n      return new exports.promiseImpl(function (resolve, reject) {\n        try {\n          result = handleCache(options)(data);\n          resolve(result);\n        }\n        catch (err) {\n          reject(err);\n        }\n      });\n    }\n    else {\n      throw new Error('Please provide a callback function');\n    }\n  }\n  else {\n    try {\n      result = handleCache(options)(data);\n    }\n    catch (err) {\n      return cb(err);\n    }\n\n    cb(null, result);\n  }\n}\n\n/**\n * fileLoader is independent\n *\n * @param {String} filePath ejs file path.\n * @return {String} The contents of the specified file.\n * @static\n */\n\nfunction fileLoader(filePath){\n  return exports.fileLoader(filePath);\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * @memberof module:ejs-internal\n * @param {String}  path    path for the specified file\n * @param {Options} options compilation options\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned\n * @static\n */\n\nfunction includeFile(path, options) {\n  var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);\n  opts.filename = getIncludePath(path, opts);\n  if (typeof options.includer === 'function') {\n    var includerResult = options.includer(path, opts.filename);\n    if (includerResult) {\n      if (includerResult.filename) {\n        opts.filename = includerResult.filename;\n      }\n      if (includerResult.template) {\n        return handleCache(opts, includerResult.template);\n      }\n    }\n  }\n  return handleCache(opts);\n}\n\n/**\n * Re-throw the given `err` in context to the `str` of ejs, `filename`, and\n * `lineno`.\n *\n * @implements {RethrowCallback}\n * @memberof module:ejs-internal\n * @param {Error}  err      Error object\n * @param {String} str      EJS source\n * @param {String} flnm     file name of the EJS file\n * @param {Number} lineno   line number of the error\n * @param {EscapeCallback} esc\n * @static\n */\n\nfunction rethrow(err, str, flnm, lineno, esc) {\n  var lines = str.split('\\n');\n  var start = Math.max(lineno - 3, 0);\n  var end = Math.min(lines.length, lineno + 3);\n  var filename = esc(flnm);\n  // Error context\n  var context = lines.slice(start, end).map(function (line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? ' >> ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'ejs') + ':'\n    + lineno + '\\n'\n    + context + '\\n\\n'\n    + err.message;\n\n  throw err;\n}\n\nfunction stripSemi(str){\n  return str.replace(/;(\\s*$)/, '$1');\n}\n\n/**\n * Compile the given `str` of ejs into a template function.\n *\n * @param {String}  template EJS template\n *\n * @param {Options} [opts] compilation options\n *\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `opts.client`, either type might be returned.\n * Note that the return type of the function also depends on the value of `opts.async`.\n * @public\n */\n\nexports.compile = function compile(template, opts) {\n  var templ;\n\n  // v1 compat\n  // 'scope' is 'context'\n  // FIXME: Remove this in a future version\n  if (opts && opts.scope) {\n    if (!scopeOptionWarned){\n      console.warn('`scope` option is deprecated and will be removed in EJS 3');\n      scopeOptionWarned = true;\n    }\n    if (!opts.context) {\n      opts.context = opts.scope;\n    }\n    delete opts.scope;\n  }\n  templ = new Template(template, opts);\n  return templ.compile();\n};\n\n/**\n * Render the given `template` of ejs.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}   template EJS template\n * @param {Object}  [data={}] template data\n * @param {Options} [opts={}] compilation and rendering options\n * @return {(String|Promise<String>)}\n * Return value type depends on `opts.async`.\n * @public\n */\n\nexports.render = function (template, d, o) {\n  var data = d || utils.createNullProtoObjWherePossible();\n  var opts = o || utils.createNullProtoObjWherePossible();\n\n  // No options object -- if there are optiony names\n  // in the data, copy them to options\n  if (arguments.length == 2) {\n    utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);\n  }\n\n  return handleCache(opts, template)(data);\n};\n\n/**\n * Render an EJS file at the given `path` and callback `cb(err, str)`.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}             path     path to the EJS file\n * @param {Object}            [data={}] template data\n * @param {Options}           [opts={}] compilation and rendering options\n * @param {RenderFileCallback} cb callback\n * @public\n */\n\nexports.renderFile = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var filename = args.shift();\n  var cb;\n  var opts = {filename: filename};\n  var data;\n  var viewOpts;\n\n  // Do we have a callback?\n  if (typeof arguments[arguments.length - 1] == 'function') {\n    cb = args.pop();\n  }\n  // Do we have data/opts?\n  if (args.length) {\n    // Should always have data obj\n    data = args.shift();\n    // Normal passed opts (data obj + opts obj)\n    if (args.length) {\n      // Use shallowCopy so we don't pollute passed in opts obj with new vals\n      utils.shallowCopy(opts, args.pop());\n    }\n    // Special casing for Express (settings + opts-in-data)\n    else {\n      // Express 3 and 4\n      if (data.settings) {\n        // Pull a few things from known locations\n        if (data.settings.views) {\n          opts.views = data.settings.views;\n        }\n        if (data.settings['view cache']) {\n          opts.cache = true;\n        }\n        // Undocumented after Express 2, but still usable, esp. for\n        // items that are unsafe to be passed along with data, like `root`\n        viewOpts = data.settings['view options'];\n        if (viewOpts) {\n          utils.shallowCopy(opts, viewOpts);\n        }\n      }\n      // Express 2 and lower, values set in app.locals, or people who just\n      // want to pass options in their data. NOTE: These values will override\n      // anything previously set in settings  or settings['view options']\n      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);\n    }\n    opts.filename = filename;\n  }\n  else {\n    data = utils.createNullProtoObjWherePossible();\n  }\n\n  return tryHandleCache(opts, data, cb);\n};\n\n/**\n * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.\n * @public\n */\n\n/**\n * EJS template class\n * @public\n */\nexports.Template = Template;\n\nexports.clearCache = function () {\n  exports.cache.reset();\n};\n\nfunction Template(text, optsParam) {\n  var opts = utils.hasOwnOnlyObject(optsParam);\n  var options = utils.createNullProtoObjWherePossible();\n  this.templateText = text;\n  /** @type {string | null} */\n  this.mode = null;\n  this.truncate = false;\n  this.currentLine = 1;\n  this.source = '';\n  options.client = opts.client || false;\n  options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;\n  options.compileDebug = opts.compileDebug !== false;\n  options.debug = !!opts.debug;\n  options.filename = opts.filename;\n  options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;\n  options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;\n  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;\n  options.strict = opts.strict || false;\n  options.context = opts.context;\n  options.cache = opts.cache || false;\n  options.rmWhitespace = opts.rmWhitespace;\n  options.root = opts.root;\n  options.includer = opts.includer;\n  options.outputFunctionName = opts.outputFunctionName;\n  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;\n  options.views = opts.views;\n  options.async = opts.async;\n  options.destructuredLocals = opts.destructuredLocals;\n  options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true;\n\n  if (options.strict) {\n    options._with = false;\n  }\n  else {\n    options._with = typeof opts._with != 'undefined' ? opts._with : true;\n  }\n\n  this.opts = options;\n\n  this.regex = this.createRegex();\n}\n\nTemplate.modes = {\n  EVAL: 'eval',\n  ESCAPED: 'escaped',\n  RAW: 'raw',\n  COMMENT: 'comment',\n  LITERAL: 'literal'\n};\n\nTemplate.prototype = {\n  createRegex: function () {\n    var str = _REGEX_STRING;\n    var delim = utils.escapeRegExpChars(this.opts.delimiter);\n    var open = utils.escapeRegExpChars(this.opts.openDelimiter);\n    var close = utils.escapeRegExpChars(this.opts.closeDelimiter);\n    str = str.replace(/%/g, delim)\n      .replace(/</g, open)\n      .replace(/>/g, close);\n    return new RegExp(str);\n  },\n\n  compile: function () {\n    /** @type {string} */\n    var src;\n    /** @type {ClientFunction} */\n    var fn;\n    var opts = this.opts;\n    var prepended = '';\n    var appended = '';\n    /** @type {EscapeCallback} */\n    var escapeFn = opts.escapeFunction;\n    /** @type {FunctionConstructor} */\n    var ctor;\n    /** @type {string} */\n    var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined';\n\n    if (!this.source) {\n      this.generateSource();\n      prepended +=\n        '  var __output = \"\";\\n' +\n        '  function __append(s) { if (s !== undefined && s !== null) __output += s }\\n';\n      if (opts.outputFunctionName) {\n        if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {\n          throw new Error('outputFunctionName is not a valid JS identifier.');\n        }\n        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n      }\n      if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {\n        throw new Error('localsName is not a valid JS identifier.');\n      }\n      if (opts.destructuredLocals && opts.destructuredLocals.length) {\n        var destructuring = '  var __locals = (' + opts.localsName + ' || {}),\\n';\n        for (var i = 0; i < opts.destructuredLocals.length; i++) {\n          var name = opts.destructuredLocals[i];\n          if (!_JS_IDENTIFIER.test(name)) {\n            throw new Error('destructuredLocals[' + i + '] is not a valid JS identifier.');\n          }\n          if (i > 0) {\n            destructuring += ',\\n  ';\n          }\n          destructuring += name + ' = __locals.' + name;\n        }\n        prepended += destructuring + ';\\n';\n      }\n      if (opts._with !== false) {\n        prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\\n';\n        appended += '  }' + '\\n';\n      }\n      appended += '  return __output;' + '\\n';\n      this.source = prepended + this.source + appended;\n    }\n\n    if (opts.compileDebug) {\n      src = 'var __line = 1' + '\\n'\n        + '  , __lines = ' + JSON.stringify(this.templateText) + '\\n'\n        + '  , __filename = ' + sanitizedFilename + ';' + '\\n'\n        + 'try {' + '\\n'\n        + this.source\n        + '} catch (e) {' + '\\n'\n        + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\\n'\n        + '}' + '\\n';\n    }\n    else {\n      src = this.source;\n    }\n\n    if (opts.client) {\n      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src;\n      if (opts.compileDebug) {\n        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n      }\n    }\n\n    if (opts.strict) {\n      src = '\"use strict\";\\n' + src;\n    }\n    if (opts.debug) {\n      console.log(src);\n    }\n    if (opts.compileDebug && opts.filename) {\n      src = src + '\\n'\n        + '//# sourceURL=' + sanitizedFilename + '\\n';\n    }\n\n    try {\n      if (opts.async) {\n        // Have to use generated function for this, since in envs without support,\n        // it breaks in parsing\n        try {\n          ctor = (new Function('return (async function(){}).constructor;'))();\n        }\n        catch(e) {\n          if (e instanceof SyntaxError) {\n            throw new Error('This environment does not support async/await');\n          }\n          else {\n            throw e;\n          }\n        }\n      }\n      else {\n        ctor = Function;\n      }\n      fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);\n    }\n    catch(e) {\n      // istanbul ignore else\n      if (e instanceof SyntaxError) {\n        if (opts.filename) {\n          e.message += ' in ' + opts.filename;\n        }\n        e.message += ' while compiling ejs\\n\\n';\n        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\\n';\n        e.message += 'https://github.com/RyanZim/EJS-Lint';\n        if (!opts.async) {\n          e.message += '\\n';\n          e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.';\n        }\n      }\n      throw e;\n    }\n\n    // Return a callable function which will execute the function\n    // created by the source-code, with the passed data as locals\n    // Adds a local `include` function which allows full recursive include\n    var returnedFn = opts.client ? fn : function anonymous(data) {\n      var include = function (path, includeData) {\n        var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);\n        if (includeData) {\n          d = utils.shallowCopy(d, includeData);\n        }\n        return includeFile(path, opts)(d);\n      };\n      return fn.apply(opts.context,\n        [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);\n    };\n    if (opts.filename && typeof Object.defineProperty === 'function') {\n      var filename = opts.filename;\n      var basename = path.basename(filename, path.extname(filename));\n      try {\n        Object.defineProperty(returnedFn, 'name', {\n          value: basename,\n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n      } catch (e) {/* ignore */}\n    }\n    return returnedFn;\n  },\n\n  generateSource: function () {\n    var opts = this.opts;\n\n    if (opts.rmWhitespace) {\n      // Have to use two separate replace here as `^` and `$` operators don't\n      // work well with `\\r` and empty lines don't work well with the `m` flag.\n      this.templateText =\n        this.templateText.replace(/[\\r\\n]+/g, '\\n').replace(/^\\s+|\\s+$/gm, '');\n    }\n\n    // Slurp spaces and tabs before <%_ and after _%>\n    this.templateText =\n      this.templateText.replace(/[ \\t]*<%_/gm, '<%_').replace(/_%>[ \\t]*/gm, '_%>');\n\n    var self = this;\n    var matches = this.parseTemplateText();\n    var d = this.opts.delimiter;\n    var o = this.opts.openDelimiter;\n    var c = this.opts.closeDelimiter;\n\n    if (matches && matches.length) {\n      matches.forEach(function (line, index) {\n        var closing;\n        // If this is an opening tag, check for closing tags\n        // FIXME: May end up with some false positives here\n        // Better to store modes as k/v with openDelimiter + delimiter as key\n        // Then this can simply check against the map\n        if ( line.indexOf(o + d) === 0        // If it is a tag\n          && line.indexOf(o + d + d) !== 0) { // and is not escaped\n          closing = matches[index + 2];\n          if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) {\n            throw new Error('Could not find matching close tag for \"' + line + '\".');\n          }\n        }\n        self.scanLine(line);\n      });\n    }\n\n  },\n\n  parseTemplateText: function () {\n    var str = this.templateText;\n    var pat = this.regex;\n    var result = pat.exec(str);\n    var arr = [];\n    var firstPos;\n\n    while (result) {\n      firstPos = result.index;\n\n      if (firstPos !== 0) {\n        arr.push(str.substring(0, firstPos));\n        str = str.slice(firstPos);\n      }\n\n      arr.push(result[0]);\n      str = str.slice(result[0].length);\n      result = pat.exec(str);\n    }\n\n    if (str) {\n      arr.push(str);\n    }\n\n    return arr;\n  },\n\n  _addOutput: function (line) {\n    if (this.truncate) {\n      // Only replace single leading linebreak in the line after\n      // -%> tag -- this is the single, trailing linebreak\n      // after the tag that the truncation mode replaces\n      // Handle Win / Unix / old Mac linebreaks -- do the \\r\\n\n      // combo first in the regex-or\n      line = line.replace(/^(?:\\r\\n|\\r|\\n)/, '');\n      this.truncate = false;\n    }\n    if (!line) {\n      return line;\n    }\n\n    // Preserve literal slashes\n    line = line.replace(/\\\\/g, '\\\\\\\\');\n\n    // Convert linebreaks\n    line = line.replace(/\\n/g, '\\\\n');\n    line = line.replace(/\\r/g, '\\\\r');\n\n    // Escape double-quotes\n    // - this will be the delimiter during execution\n    line = line.replace(/\"/g, '\\\\\"');\n    this.source += '    ; __append(\"' + line + '\")' + '\\n';\n  },\n\n  scanLine: function (line) {\n    var self = this;\n    var d = this.opts.delimiter;\n    var o = this.opts.openDelimiter;\n    var c = this.opts.closeDelimiter;\n    var newLineCount = 0;\n\n    newLineCount = (line.split('\\n').length - 1);\n\n    switch (line) {\n    case o + d:\n    case o + d + '_':\n      this.mode = Template.modes.EVAL;\n      break;\n    case o + d + '=':\n      this.mode = Template.modes.ESCAPED;\n      break;\n    case o + d + '-':\n      this.mode = Template.modes.RAW;\n      break;\n    case o + d + '#':\n      this.mode = Template.modes.COMMENT;\n      break;\n    case o + d + d:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(o + d + d, o + d) + '\")' + '\\n';\n      break;\n    case d + d + c:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(d + d + c, d + c) + '\")' + '\\n';\n      break;\n    case d + c:\n    case '-' + d + c:\n    case '_' + d + c:\n      if (this.mode == Template.modes.LITERAL) {\n        this._addOutput(line);\n      }\n\n      this.mode = null;\n      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;\n      break;\n    default:\n      // In script mode, depends on type of tag\n      if (this.mode) {\n        // If '//' is found without a line break, add a line break.\n        switch (this.mode) {\n        case Template.modes.EVAL:\n        case Template.modes.ESCAPED:\n        case Template.modes.RAW:\n          if (line.lastIndexOf('//') > line.lastIndexOf('\\n')) {\n            line += '\\n';\n          }\n        }\n        switch (this.mode) {\n        // Just executing code\n        case Template.modes.EVAL:\n          this.source += '    ; ' + line + '\\n';\n          break;\n          // Exec, esc, and output\n        case Template.modes.ESCAPED:\n          this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\\n';\n          break;\n          // Exec and output\n        case Template.modes.RAW:\n          this.source += '    ; __append(' + stripSemi(line) + ')' + '\\n';\n          break;\n        case Template.modes.COMMENT:\n          // Do nothing\n          break;\n          // Literal <%% mode, append as raw output\n        case Template.modes.LITERAL:\n          this._addOutput(line);\n          break;\n        }\n      }\n      // In string mode, just add the output\n      else {\n        this._addOutput(line);\n      }\n    }\n\n    if (self.opts.compileDebug && newLineCount) {\n      this.currentLine += newLineCount;\n      this.source += '    ; __line = ' + this.currentLine + '\\n';\n    }\n  }\n};\n\n/**\n * Escape characters reserved in XML.\n *\n * This is simply an export of {@link module:utils.escapeXML}.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @public\n * @func\n * */\nexports.escapeXML = utils.escapeXML;\n\n/**\n * Express.js support.\n *\n * This is an alias for {@link module:ejs.renderFile}, in order to support\n * Express.js out-of-the-box.\n *\n * @func\n */\n\nexports.__express = exports.renderFile;\n\n/**\n * Version of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.VERSION = _VERSION_STRING;\n\n/**\n * Name for detection of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.name = _NAME;\n\n/* istanbul ignore if */\nif (typeof window != 'undefined') {\n  window.ejs = exports;\n}\n\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nexport class r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            const val = this.Fr.neg(linCom2[s]);\n            if (typeof res[s] == \"undefined\") {\n                res[s] = val;\n            } else {\n                res[s] = this.Fr.add(res[s], val);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}","import { buildBn128 as buildBn128wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bn128 = null;\n\nexport default async function buildBn128(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBn128wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: Scalar.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\nimport thread from \"./threadman_thread.js\";\nimport os from \"os\";\nimport Worker from \"web-worker\";\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet workerSource;\n\nconst threadStr = `(${thread.toString()})(self)`;\nif(process.browser) {\n    if(globalThis?.Blob) {\n        const threadBytes= new TextEncoder().encode(threadStr);\n        const workerBlob = new Blob([threadBytes], { type: \"application/javascript\" }) ;\n        workerSource = URL.createObjectURL(workerBlob);\n    } else {\n        workerSource = \"data:application/javascript;base64,\" + globalThis.btoa(threadStr);\n    }\n} else {  \n    workerSource = \"data:application/javascript;base64,\" + Buffer.from(threadStr).toString(\"base64\");\n}\n\n\n\nexport default async function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n    \n    if(process.browser && !globalThis?.Worker) {\n        singleThread = true;\n    }\n    \n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency = 2;\n        if (process.browser) {\n            if (typeof navigator === \"object\" && navigator.hardwareConcurrency) {\n                concurrency = navigator.hardwareConcurrency;\n            }\n        } else {\n            concurrency = os.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nexport class ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n","const PAGE_SIZE = 1<<22;\n\nexport function createNew(o) {\n    const initialSize = o.initialSize || 0;\n    const fd = new BigMemFile();\n    fd.o = o;\n    const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE)+1 : 0;\n    fd.o.data = [];\n    for (let i=0; i<nPages-1; i++) {\n        fd.o.data.push( new Uint8Array(PAGE_SIZE));\n    }\n    if (nPages) fd.o.data.push( new Uint8Array(initialSize - PAGE_SIZE*(nPages-1)));\n    fd.totalSize = 0;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readExisting(o) {\n    const fd = new BigMemFile();\n    fd.o = o;\n    fd.totalSize = (o.data.length-1)* PAGE_SIZE + o.data[o.data.length-1].byteLength;\n    fd.readOnly = true;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readWriteExisting(o) {\n    const fd = new BigMemFile();\n    fd.o = o;\n    fd.totalSize = (o.data.length-1)* PAGE_SIZE + o.data[o.data.length-1].byteLength;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nconst tmpBuff32 = new Uint8Array(4);\nconst tmpBuff32v = new DataView(tmpBuff32.buffer);\nconst tmpBuff64 = new Uint8Array(8);\nconst tmpBuff64v = new DataView(tmpBuff64.buffer);\n\nclass BigMemFile {\n\n    constructor() {\n        this.pageSize = 1 << 14;  // for compatibility\n    }\n\n    _resizeIfNeeded(newLen) {\n\n        if (newLen <= this.totalSize) return;\n\n        if (this.readOnly) throw new Error(\"Reading out of file bounds\");\n\n        const nPages = Math.floor((newLen - 1) / PAGE_SIZE)+1;\n        for (let i= Math.max(this.o.data.length-1, 0); i<nPages; i++) {\n            const newSize = i<nPages-1 ? PAGE_SIZE : newLen - (nPages-1)*PAGE_SIZE;\n            const p = new Uint8Array(newSize);\n            if (i == this.o.data.length-1) p.set(this.o.data[i]);\n            this.o.data[i] = p;\n        }\n        this.totalSize = newLen;\n    }\n\n    async write(buff, pos) {\n        const self =this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) throw new Error(\"Writing a read only file\");\n\n        this._resizeIfNeeded(pos + buff.byteLength);\n\n        const firstPage = Math.floor(pos / PAGE_SIZE);\n\n        let p = firstPage;\n        let o = pos % PAGE_SIZE;\n        let r = buff.byteLength;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l);\n            const dstView = new Uint8Array(self.o.data[p].buffer, o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        this.pos = pos + buff.byteLength;\n    }\n\n    async readToBuffer(buffDst, offset, len, pos) {\n        const self = this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) {\n            if (pos + len > this.totalSize) throw new Error(\"Reading out of bounds\");\n        }\n        this._resizeIfNeeded(pos + len);\n\n        const firstPage = Math.floor(pos / PAGE_SIZE);\n\n        let p = firstPage;\n        let o = pos % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(self.o.data[p].buffer, o, l);\n            buffDst.set(srcView, offset+len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        this.pos = pos + len;\n    }\n\n    async read(len, pos) {\n        const self = this;\n        const buff = new Uint8Array(len);\n\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    close() {\n    }\n\n    async discard() {\n    }\n\n\n    async writeULE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n        const fixedSize = 2048;\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n\n        if (currentPosition > this.totalSize) {\n            if (this.readOnly) {\n                throw new Error(\"Reading out of bounds\");\n            }\n            this._resizeIfNeeded(pos);\n        }\n\n        let endOfStringFound = false;\n        let str = \"\";\n\n        while (!endOfStringFound) {\n            let currentPage = Math.floor(currentPosition / PAGE_SIZE);\n            let offsetOnPage = currentPosition % PAGE_SIZE;\n\n            if (self.o.data[currentPage] === undefined) {\n                throw new Error(\"ERROR\");\n            }\n\n            let readLength = Math.min(fixedSize, self.o.data[currentPage].length - offsetOnPage);\n            const dataArray = new Uint8Array(self.o.data[currentPage].buffer, offsetOnPage, readLength);\n\n            let indexEndOfString = dataArray.findIndex(element => element === 0);\n            endOfStringFound = indexEndOfString !== -1;\n\n            if (endOfStringFound) {\n                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n                self.pos = currentPage * PAGE_SIZE + offsetOnPage + indexEndOfString + 1;\n            } else {\n                str += new TextDecoder().decode(dataArray);\n                self.pos = currentPage * PAGE_SIZE + offsetOnPage + dataArray.length;\n            }\n\n            currentPosition = self.pos;\n        }\n        return str;\n    }\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/validate/route\",\n        pathname: \"/api/validate\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/packages/web/app/api/validate/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/validate/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\nimport thread from \"./threadman_thread.js\";\nimport os from \"os\";\nimport Worker from \"web-worker\";\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet workerSource;\n\nconst threadStr = `(${thread.toString()})(self)`;\nif(process.browser) {\n    if(globalThis?.Blob) {\n        const threadBytes= new TextEncoder().encode(threadStr);\n        const workerBlob = new Blob([threadBytes], { type: \"application/javascript\" }) ;\n        workerSource = URL.createObjectURL(workerBlob);\n    } else {\n        workerSource = \"data:application/javascript;base64,\" + globalThis.btoa(threadStr);\n    }\n} else {  \n    workerSource = \"data:application/javascript;base64,\" + Buffer.from(threadStr).toString(\"base64\");\n}\n\n\n\nexport default async function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n    \n    if(process.browser && !globalThis?.Worker) {\n        singleThread = true;\n    }\n    \n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency = 2;\n        if (process.browser) {\n            if (typeof navigator === \"object\" && navigator.hardwareConcurrency) {\n                concurrency = navigator.hardwareConcurrency;\n            }\n        } else {\n            concurrency = os.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nexport class ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n","import { NextResponse } from \"next/server\";\nimport * as snarkjs from \"snarkjs\";\nimport { readFile } from \"fs/promises\";\nimport path from \"path\";\n\nexport const runtime = \"nodejs\";\n\nlet vkeyCache: object | null = null;\n\nasync function getVkey() {\n  if (vkeyCache) return vkeyCache;\n  const vkeyPath = path.join(process.cwd(), \"public\", \"zk\", \"verification_key.json\");\n  const raw = await readFile(vkeyPath, \"utf-8\");\n  vkeyCache = JSON.parse(raw);\n  return vkeyCache;\n}\n\nexport async function POST(req: Request) {\n  try {\n    const { proof, publicSignals } = await req.json();\n    if (!proof || !Array.isArray(publicSignals)) {\n      return NextResponse.json(\n        { verified: false, error: \"Missing proof or publicSignals\" },\n        { status: 400 }\n      );\n    }\n\n    const vkey = await getVkey();\n    const isValid = await snarkjs.groth16.verify(vkey, publicSignals, proof);\n    const verified = isValid && publicSignals[0] === \"1\";\n\n    return NextResponse.json({ verified });\n  } catch (err: unknown) {\n    const msg = err instanceof Error ? err.message : String(err);\n    return NextResponse.json({ verified: false, error: msg }, { status: 500 });\n  }\n}\n","const SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\nexport default BigArray;\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\nexport default BigArray;\n","import ejs from \"ejs\";\n\nimport exportVerificationKey from \"./zkey_export_verificationkey.js\";\nimport fflonkExportSolidityVerifierCmd from \"./fflonk_export_solidity_verifier.js\";\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nexport default async function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await exportVerificationKey(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return fflonkExportSolidityVerifierCmd(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs.render(template, verificationKey);\n}\n","export function createNew(o) {\n    const initialSize = o.initialSize || 1<<20;\n    const fd = new MemFile();\n    fd.o = o;\n    fd.o.data = new Uint8Array(initialSize);\n    fd.allocSize = initialSize;\n    fd.totalSize = 0;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readExisting(o) {\n    const fd = new MemFile();\n    fd.o = o;\n    fd.allocSize = o.data.byteLength;\n    fd.totalSize = o.data.byteLength;\n    fd.readOnly = true;\n    fd.pos = 0;\n    return fd;\n}\n\nexport function readWriteExisting(o) {\n    const fd = new MemFile();\n    fd.o = o;\n    fd.allocSize = o.data.byteLength;\n    fd.totalSize = o.data.byteLength;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nconst tmpBuff32 = new Uint8Array(4);\nconst tmpBuff32v = new DataView(tmpBuff32.buffer);\nconst tmpBuff64 = new Uint8Array(8);\nconst tmpBuff64v = new DataView(tmpBuff64.buffer);\n\nclass MemFile {\n\n    constructor() {\n        this.pageSize = 1 << 14;  // for compatibility\n    }\n\n    _resizeIfNeeded(newLen) {\n        if (newLen > this.allocSize) {\n            const newAllocSize = Math.max(\n                this.allocSize + (1 << 20),\n                Math.floor(this.allocSize * 1.1),\n                newLen\n            );\n            const newData = new Uint8Array(newAllocSize);\n            newData.set(this.o.data);\n            this.o.data = newData;\n            this.allocSize = newAllocSize;\n        }\n    }\n\n    async write(buff, pos) {\n        const self =this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) throw new Error(\"Writing a read only file\");\n\n        this._resizeIfNeeded(pos + buff.byteLength);\n\n        this.o.data.set(buff.slice(), pos);\n\n        if (pos + buff.byteLength > this.totalSize) this.totalSize = pos + buff.byteLength;\n\n        this.pos = pos + buff.byteLength;\n    }\n\n    async readToBuffer(buffDest, offset, len, pos) {\n        const self = this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) {\n            if (pos + len > this.totalSize) throw new Error(\"Reading out of bounds\");\n        }\n        this._resizeIfNeeded(pos + len);\n\n        const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);\n\n        buffDest.set(buffSrc, offset);\n\n        this.pos = pos + len;\n    }\n\n    async read(len, pos) {\n        const self = this;\n\n        const buff = new Uint8Array(len);\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    close() {\n        if (this.o.data.byteLength != this.totalSize) {\n            this.o.data = this.o.data.slice(0, this.totalSize);\n        }\n    }\n\n    async discard() {\n    }\n\n\n    async writeULE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n\n        if (currentPosition > this.totalSize) {\n            if (this.readOnly) {\n                throw new Error(\"Reading out of bounds\");\n            }\n            this._resizeIfNeeded(pos);\n        }\n        const dataArray = new Uint8Array(\n            self.o.data.buffer,\n            currentPosition,\n            this.totalSize - currentPosition\n        );\n\n        let indexEndOfString = dataArray.findIndex(element => element === 0);\n        let endOfStringFound = indexEndOfString !== -1;\n\n        let str = \"\";\n        if (endOfStringFound) {\n            str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n            self.pos = currentPosition + indexEndOfString + 1;\n        } else {\n            self.pos = currentPosition;\n        }\n        return str;\n    }\n}\n","export const HEADER_ZKEY_SECTION = 1;\n\nexport const GROTH16_PROTOCOL_ID = 1;\nexport const PLONK_PROTOCOL_ID = 2;\nexport const FFLONK_PROTOCOL_ID = 10;\n","export const ZKEY_PL_NSECTIONS = 13;\n\nexport const ZKEY_PL_HEADER_SECTION = 2;\nexport const ZKEY_PL_ADDITIONS_SECTION = 3;\nexport const ZKEY_PL_A_MAP_SECTION = 4;\nexport const ZKEY_PL_B_MAP_SECTION = 5;\nexport const ZKEY_PL_C_MAP_SECTION = 6;\nexport const ZKEY_PL_QM_SECTION = 7;\nexport const ZKEY_PL_QL_SECTION = 8;\nexport const ZKEY_PL_QR_SECTION = 9;\nexport const ZKEY_PL_QO_SECTION = 10;\nexport const ZKEY_PL_QC_SECTION = 11;\nexport const ZKEY_PL_SIGMA_SECTION = 12;\nexport const ZKEY_PL_LAGRANGE_SECTION = 13;\nexport const ZKEY_PL_PTAU_SECTION = 14;\n\n","\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nexport function fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nexport const e = fromString;\n\nexport function fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nexport function bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nexport function isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nexport function isZero(a) {\n    return !a;\n}\n\nexport function shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nexport function shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nexport const shl = shiftLeft;\nexport const shr = shiftRight;\n\nexport function isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nexport function naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nexport function bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nexport function toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nexport function toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nexport function add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nexport function sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nexport function neg(a) {\n    return -BigInt(a);\n}\n\nexport function mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nexport function square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nexport function pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nexport function div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nexport function mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nexport function eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nexport function neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nexport function lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nexport function gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nexport function leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nexport function geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nexport function band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nexport function bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nexport function bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nexport function land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nexport function lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nexport function lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nexport function toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nexport function toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nexport function fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nexport function fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nexport function toString(a, radix) {\n    return a.toString(radix);\n}\n\nexport function toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nexport const zero = e(0);\nexport const one = e(1);\n\n\n\n\n\n","\nimport fs from\"fs\";\n\nexport async function open(fileName, openFlags, cacheSize, pageSize) {\n    cacheSize = cacheSize || 4096*64;\n    if (typeof openFlags !== \"number\" && [\"w+\", \"wx+\", \"r\", \"ax+\", \"a+\"].indexOf(openFlags) <0)\n        throw new Error(\"Invalid open option\");\n    const fd =await fs.promises.open(fileName, openFlags);\n\n    const stats = await fd.stat();\n\n    return  new FastFile(fd, stats, cacheSize, pageSize, fileName);\n}\n\n\nclass FastFile {\n\n    constructor(fd, stats, cacheSize, pageSize, fileName) {\n        this.fileName = fileName;\n        this.fd = fd;\n        this.pos = 0;\n        this.pageSize = pageSize || (1 << 8);\n        while (this.pageSize < stats.blksize) {\n            this.pageSize *= 2;\n        }\n        this.totalSize = stats.size;\n        this.totalPages = Math.floor((stats.size -1) / this.pageSize)+1;\n        this.maxPagesLoaded = Math.floor( cacheSize / this.pageSize)+1;\n        this.pages = {};\n        this.pendingLoads = [];\n        this.writing = false;\n        this.reading = false;\n        this.avBuffs = [];\n        this.history = {};\n    }\n\n    _loadPage(p) {\n        const self = this;\n        const P = new Promise((resolve, reject)=> {\n            self.pendingLoads.push({\n                page: p,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        self.__statusPage(\"After Load request: \", p);\n        return P;\n    }\n\n    __statusPage(s, p) {\n        const logEntry = [];\n        const self=this;\n        if (!self.logHistory) return;\n        logEntry.push(\"==\" + s+ \" \" +p);\n        let S = \"\";\n        for (let i=0; i<self.pendingLoads.length; i++) {\n            if (self.pendingLoads[i].page == p) S = S + \" \" + i;\n        }\n        if (S) logEntry.push(\"Pending loads:\"+S);\n        if (typeof self.pages[p] != \"undefined\") {\n            const page = self.pages[p];\n            logEntry.push(\"Loaded\");\n            logEntry.push(\"pendingOps: \"+page.pendingOps);\n            if (page.loading) logEntry.push(\"loading: \"+page.loading);\n            if (page.writing) logEntry.push(\"writing\");\n            if (page.dirty) logEntry.push(\"dirty\");\n        }\n        logEntry.push(\"==\");\n\n        if (!self.history[p]) self.history[p] = [];\n        self.history[p].push(logEntry);\n    }\n\n    __printHistory(p) {\n        const self = this;\n        if (!self.history[p]) console.log(\"Empty History \", p);\n        console.log(\"History \"+p);\n        for (let i=0; i<self.history[p].length; i++) {\n            for (let j=0; j<self.history[p][i].length; j++) {\n                console.log(\"-> \" + self.history[p][i][j]);\n            }\n        }\n    }\n\n\n\n    _triggerLoad() {\n        const self = this;\n\n        if (self.reading) return;\n        if (self.pendingLoads.length==0) return;\n\n        const pageIdxs = Object.keys(self.pages);\n\n        const deletablePages = [];\n        for (let i=0; i<pageIdxs.length; i++) {\n            const page = self.pages[parseInt(pageIdxs[i])];\n            if ((page.dirty == false)&&(page.pendingOps==0)&&(!page.writing)&&(!page.loading)) deletablePages.push(parseInt(pageIdxs[i]));\n        }\n\n        let freePages = self.maxPagesLoaded - pageIdxs.length;\n\n        const ops = [];\n\n        // while pending loads and\n        //     the page is loaded or I can recover one.\n        while (\n            (self.pendingLoads.length>0) &&\n            (   (typeof self.pages[self.pendingLoads[0].page] != \"undefined\" )\n              ||(  (freePages>0)\n                 ||(deletablePages.length>0)))) {\n            const load = self.pendingLoads.shift();\n            if (typeof self.pages[load.page] != \"undefined\") {\n                self.pages[load.page].pendingOps ++;\n                const idx = deletablePages.indexOf(load.page);\n                if (idx>=0) deletablePages.splice(idx, 1);\n                if (self.pages[load.page].loading) {\n                    self.pages[load.page].loading.push(load);\n                } else {\n                    load.resolve();\n                }\n                self.__statusPage(\"After Load (cached): \", load.page);\n\n            } else {\n                if (freePages) {\n                    freePages--;\n                } else {\n                    const fp = deletablePages.shift();\n                    self.__statusPage(\"Before Unload: \", fp);\n                    self.avBuffs.unshift(self.pages[fp]);\n                    delete self.pages[fp];\n                    self.__statusPage(\"After Unload: \", fp);\n                }\n\n                if (load.page>=self.totalPages) {\n                    self.pages[load.page] = getNewPage();\n                    load.resolve();\n                    self.__statusPage(\"After Load (new): \", load.page);\n                } else {\n                    self.reading = true;\n                    self.pages[load.page] = getNewPage();\n                    self.pages[load.page].loading = [load];\n                    ops.push(self.fd.read(self.pages[load.page].buff, 0, self.pageSize, load.page*self.pageSize).then((res)=> {\n                        self.pages[load.page].size = res.bytesRead;\n                        const loading = self.pages[load.page].loading;\n                        delete self.pages[load.page].loading;\n                        for (let i=0; i<loading.length; i++) {\n                            loading[i].resolve();\n                        }\n                        self.__statusPage(\"After Load (loaded): \", load.page);\n                        return res;\n                    }, (err) => {\n                        load.reject(err);\n                    }));\n                    self.__statusPage(\"After Load (loading): \", load.page);\n                }\n            }\n        }\n        // if (ops.length>1) console.log(ops.length);\n\n        Promise.all(ops).then( () => {\n            self.reading = false;\n            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n            self._tryClose();\n        });\n\n        function getNewPage() {\n            if (self.avBuffs.length>0) {\n                const p = self.avBuffs.shift();\n                p.dirty = false;\n                p.pendingOps = 1;\n                p.size =0;\n                return p;\n            } else {\n                return {\n                    dirty: false,\n                    buff: new Uint8Array(self.pageSize),\n                    pendingOps: 1,\n                    size: 0\n                };\n            }\n        }\n\n    }\n\n\n    _triggerWrite() {\n        const self = this;\n        if (self.writing) return;\n\n        const pageIdxs = Object.keys(self.pages);\n\n        const ops = [];\n\n        for (let i=0; i<pageIdxs.length; i++) {\n            const page = self.pages[parseInt(pageIdxs[i])];\n            if (page.dirty) {\n                page.dirty = false;\n                page.writing = true;\n                self.writing = true;\n                ops.push( self.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i])*self.pageSize).then(() => {\n                    page.writing = false;\n                    return;\n                }, (err) => {\n                    console.log(\"ERROR Writing: \"+err);\n                    self.error = err;\n                    self._tryClose();\n                }));\n            }\n        }\n\n        if (self.writing) {\n            Promise.all(ops).then( () => {\n                self.writing = false;\n                setImmediate(self._triggerWrite.bind(self));\n                self._tryClose();\n                if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n            });\n        }\n    }\n\n    _getDirtyPage() {\n        for (let p in this.pages) {\n            if (this.pages[p].dirty) return p;\n        }\n        return -1;\n    }\n\n    async write(buff, pos) {\n        if (buff.byteLength == 0) return;\n        const self = this;\n/*\n        if (buff.byteLength > self.pageSize*self.maxPagesLoaded*0.8) {\n            const cacheSize = Math.floor(buff.byteLength * 1.1);\n            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;\n        }\n*/\n        if (typeof pos == \"undefined\") pos = self.pos;\n        self.pos = pos+buff.byteLength;\n        if (self.totalSize < pos + buff.byteLength) self.totalSize = pos + buff.byteLength;\n        if (self.pendingClose)\n            throw new Error(\"Writing a closing file\");\n        const firstPage = Math.floor(pos / self.pageSize);\n        const lastPage = Math.floor((pos + buff.byteLength -1) / self.pageSize);\n\n        const pagePromises = [];\n        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));\n        self._triggerLoad();\n\n        let p = firstPage;\n        let o = pos % self.pageSize;\n        let r = buff.byteLength;\n        while (r>0) {\n            await pagePromises[p-firstPage];\n            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;\n            const srcView = buff.slice( buff.byteLength - r, buff.byteLength - r + l);\n            const dstView = new Uint8Array(self.pages[p].buff.buffer, o, l);\n            dstView.set(srcView);\n            self.pages[p].dirty = true;\n            self.pages[p].pendingOps --;\n            self.pages[p].size = Math.max(o+l, self.pages[p].size);\n            if (p>=self.totalPages) {\n                self.totalPages = p+1;\n            }\n            r = r-l;\n            p ++;\n            o = 0;\n            if (!self.writing) setImmediate(self._triggerWrite.bind(self));\n        }\n    }\n\n    async read(len, pos) {\n        const self = this;\n        let buff = new Uint8Array(len);\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    async readToBuffer(buffDst, offset, len, pos) {\n        if (len == 0) {\n            return;\n        }\n        const self = this;\n        if (len > self.pageSize*self.maxPagesLoaded*0.8) {\n            const cacheSize = Math.floor(len * 1.1);\n            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;\n        }\n        if (typeof pos == \"undefined\") pos = self.pos;\n        self.pos = pos+len;\n        if (self.pendingClose)\n            throw new Error(\"Reading a closing file\");\n        const firstPage = Math.floor(pos / self.pageSize);\n        const lastPage = Math.floor((pos + len -1) / self.pageSize);\n\n        const pagePromises = [];\n        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));\n\n        self._triggerLoad();\n\n        let p = firstPage;\n        let o = pos % self.pageSize;\n        // Remaining bytes to read\n        let r = pos + len > self.totalSize ? len - (pos + len - self.totalSize): len;\n        while (r>0) {\n            await pagePromises[p - firstPage];\n            self.__statusPage(\"After Await (read): \", p);\n\n            // bytes to copy from this page\n            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;\n            const srcView = new Uint8Array(self.pages[p].buff.buffer, self.pages[p].buff.byteOffset + o, l);\n            buffDst.set(srcView, offset+len-r);\n            self.pages[p].pendingOps --;\n\n            self.__statusPage(\"After Op done: \", p);\n\n            r = r-l;\n            p ++;\n            o = 0;\n            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n        }\n\n        this.pos = pos + len;\n\n    }\n\n\n    _tryClose() {\n        const self = this;\n        if (!self.pendingClose) return;\n        if (self.error) {\n            self.pendingCloseReject(self.error);\n        }\n        const p = self._getDirtyPage();\n        if ((p>=0) || (self.writing) || (self.reading) || (self.pendingLoads.length>0)) return;\n        self.pendingClose();\n    }\n\n    close() {\n        const self = this;\n        if (self.pendingClose)\n            throw new Error(\"Closing the file twice\");\n        return new Promise((resolve, reject) => {\n            self.pendingClose = resolve;\n            self.pendingCloseReject = reject;\n            self._tryClose();\n        }).then(()=> {\n            self.fd.close();\n        }, (err) => {\n            self.fd.close();\n            throw (err);\n        });\n    }\n\n    async discard() {\n        const self = this;\n        await self.close();\n        await fs.promises.unlink(this.fileName);\n    }\n\n    async writeULE32(v, pos) {\n        const self = this;\n        const tmpBuff32 = new Uint8Array(4);\n        const tmpBuff32v = new DataView(tmpBuff32.buffer);\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        const tmpBuff32 = new Uint8Array(4);\n        const tmpBuff32v = new DataView(tmpBuff32.buffer);\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        const tmpBuff64 = new Uint8Array(8);\n        const tmpBuff64v = new DataView(tmpBuff64.buffer);\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n\n        if (self.pendingClose) {\n            throw new Error(\"Reading a closing file\");\n        }\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n        let currentPage = Math.floor(currentPosition / self.pageSize);\n\n        let endOfStringFound = false;\n        let str = \"\";\n\n        while (!endOfStringFound) {\n            //Read page\n            let pagePromise = self._loadPage(currentPage);\n            self._triggerLoad();\n            await pagePromise;\n            self.__statusPage(\"After Await (read): \", currentPage);\n\n            let offsetOnPage = currentPosition % self.pageSize;\n\n            const dataArray = new Uint8Array(\n                self.pages[currentPage].buff.buffer,\n                self.pages[currentPage].buff.byteOffset + offsetOnPage,\n                self.pageSize - offsetOnPage\n            );\n\n            let indexEndOfString = dataArray.findIndex(element => element === 0);\n            endOfStringFound = indexEndOfString !== -1;\n\n            if (endOfStringFound) {\n                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n                self.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;\n            } else {\n                str += new TextDecoder().decode(dataArray);\n                self.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;\n            }\n\n            self.pages[currentPage].pendingOps--;\n            self.__statusPage(\"After Op done: \", currentPage);\n\n            currentPosition = self.pos;\n            currentPage++;\n\n            if (self.pendingLoads.length > 0) setImmediate(self._triggerLoad.bind(self));\n        }\n\n        return str;\n    }\n}\n","\nimport * as _Scalar  from \"./src/scalar.js\";\nexport const Scalar=_Scalar;\n\nexport {default as PolField} from \"./src/polfield.js\";\nexport {default as F1Field} from \"./src/f1field.js\";\nexport {default as F2Field} from \"./src/f2field.js\";\nexport {default as F3Field} from \"./src/f3field.js\";\n\nexport {default as ZqField} from \"./src/f1field.js\";\n\nexport {default as EC} from \"./src/ec.js\";\n\nexport {default as buildBn128} from \"./src/bn128.js\";\nexport {default as buildBls12381} from \"./src/bls12381.js\";\n\nimport * as _utils from \"./src/utils.js\";\nexport const utils = _utils;\nexport {default as ChaCha} from \"./src/chacha.js\";\n\nexport {default as BigBuffer} from \"./src/bigbuffer.js\";\n\nexport {getCurveFromR, getCurveFromQ, getCurveFromName} from \"./src/curves.js\";\n\n","import ChaCha from \"./chacha.js\";\nimport crypto from \"crypto\";\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Browser\n        if (typeof globalThis.crypto !== \"undefined\") { // Supported\n            globalThis.crypto.getRandomValues(array);\n        } else { // fallback\n            for (let i=0; i<n; i++) {\n                array[i] = (Math.random()*4294967296)>>>0;\n            }\n        }\n    }\n    else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport function getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nexport function getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n","\nconst PAGE_SIZE = 1<<30;\n\nexport default class BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n","\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nexport function fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nexport const e = fromString;\n\nexport function fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nexport function bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nexport function isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nexport function isZero(a) {\n    return !a;\n}\n\nexport function shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nexport function shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nexport const shl = shiftLeft;\nexport const shr = shiftRight;\n\nexport function isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nexport function naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nexport function bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nexport function toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nexport function toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nexport function add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nexport function sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nexport function neg(a) {\n    return -BigInt(a);\n}\n\nexport function mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nexport function square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nexport function pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nexport function abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nexport function div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nexport function mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nexport function eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nexport function neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nexport function lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nexport function gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nexport function leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nexport function geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nexport function band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nexport function bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nexport function bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nexport function land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nexport function lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nexport function lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nexport function toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nexport function toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nexport function fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nexport function fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nexport function toString(a, radix) {\n    return a.toString(radix);\n}\n\nexport function toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nexport const zero = e(0);\nexport const one = e(1);\n\n\n\n\n\n","\nimport * as _Scalar  from \"./src/scalar.js\";\nexport const Scalar=_Scalar;\n\nexport {default as PolField} from \"./src/polfield.js\";\nexport {default as F1Field} from \"./src/f1field.js\";\nexport {default as F2Field} from \"./src/f2field.js\";\nexport {default as F3Field} from \"./src/f3field.js\";\n\nexport {default as ZqField} from \"./src/f1field.js\";\n\nexport {default as EC} from \"./src/ec.js\";\n\nexport {default as buildBn128} from \"./src/bn128.js\";\nexport {default as buildBls12381} from \"./src/bls12381.js\";\n\nimport * as _utils from \"./src/utils.js\";\nexport const utils = _utils;\nexport {default as ChaCha} from \"./src/chacha.js\";\n\nexport {default as BigBuffer} from \"./src/bigbuffer.js\";\n\nexport {getCurveFromR, getCurveFromQ, getCurveFromName} from \"./src/curves.js\";\n\n","\nconst PAGE_SIZE = 1<<30;\n\nexport default class BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n","\nexport default function buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n","\nexport default function buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n","import { Scalar, buildBn128, buildBls12381} from \"ffjavascript\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, options) {\n    let curve;\n    // check that options param is defined and that options.singleThread is defined\n    let singleThread = options && options.singleThread;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\n","import { log2 } from \"./utils.js\";\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nexport default function buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n","import { log2 } from \"./utils.js\";\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nexport default function buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n","import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n","import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n","/* global WebAssembly */\n\nexport default function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n","import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n","import BigBuffer from \"./bigbuffer.js\";\n\nexport default function buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n","/* global WebAssembly */\n\nexport default function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n","import ChaCha from \"./chacha.js\";\nimport crypto from \"crypto\";\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Browser\n        if (typeof globalThis.crypto !== \"undefined\") { // Supported\n            globalThis.crypto.getRandomValues(array);\n        } else { // fallback\n            for (let i=0; i<n; i++) {\n                array[i] = (Math.random()*4294967296)>>>0;\n            }\n        }\n    }\n    else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport function getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nexport function getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n","/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\n\nexport function stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return Scalar.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nexport function beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 2 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nexport function leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((Scalar.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(o, Number(r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(o, Number(r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nexport function log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nexport function buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nexport function array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nexport function buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n","/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\n\nexport function stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return Scalar.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nexport function beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 2 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nexport function leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((Scalar.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(o, Number(r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(o, Number(r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nexport function stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nexport function unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nexport function log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nexport function buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nexport function array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nexport function buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n","import * as Scalar from \"./scalar.js\";\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nexport default function buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (Scalar.eq(Scalar.mod(F.p, 4), 1 )) {\n            if (Scalar.eq(Scalar.mod(F.p, 8), 1 )) {\n                if (Scalar.eq(Scalar.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (Scalar.eq(Scalar.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (Scalar.eq(Scalar.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (Scalar.eq(Scalar.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = Scalar.mod(Scalar.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = Scalar.sub(F.sqrt_q, 1);\n\n    while (!Scalar.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = Scalar.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = Scalar.div(Scalar.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n    F.sqrt_e1 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m/2);\n    F.sqrt_e34 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = Scalar.div( Scalar.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n","import { readZKey as readZKey } from \"./zkey_utils.js\";\nimport { utils } from \"ffjavascript\";\n\nexport default async function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await readZKey(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return utils.stringifyBigInts(zKey);\n}\n","import * as Scalar from \"./scalar.js\";\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nexport default function buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (Scalar.eq(Scalar.mod(F.p, 4), 1 )) {\n            if (Scalar.eq(Scalar.mod(F.p, 8), 1 )) {\n                if (Scalar.eq(Scalar.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (Scalar.eq(Scalar.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (Scalar.eq(Scalar.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (Scalar.eq(Scalar.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = Scalar.mod(Scalar.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = Scalar.sub(F.sqrt_q, 1);\n\n    while (!Scalar.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = Scalar.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = Scalar.div(Scalar.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = Scalar.pow(F.p, F.m);\n    F.sqrt_e1 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = Scalar.pow(F.p, F.m/2);\n    F.sqrt_e34 = Scalar.div( Scalar.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = Scalar.div( Scalar.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n","/* global fetch */\nimport { open } from \"./osfile.js\";\nimport * as memFile from \"./memfile.js\";\nimport * as bigMemFile from \"./bigmemfile.js\";\nimport { O_TRUNC, O_CREAT, O_RDWR, O_EXCL, O_RDONLY } from \"constants\";\n\nconst DEFAULT_CACHE_SIZE = (1 << 16);\nconst DEFAULT_PAGE_SIZE = (1 << 13);\n\n\nexport async function createOverride(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return await open(o.fileName, O_TRUNC | O_CREAT | O_RDWR, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return memFile.createNew(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.createNew(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport function createNoOverride(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return open(o.fileName, O_TRUNC | O_CREAT | O_RDWR | O_EXCL, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return memFile.createNew(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.createNew(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport async function readExisting(o, b, c) {\n    if (o instanceof Uint8Array) {\n        o = {\n            type: \"mem\",\n            data: o\n        };\n    }\n    if (process.browser) {\n        if (typeof o === \"string\") {\n            const buff = await fetch(o).then( function(res) {\n                return res.arrayBuffer();\n            }).then(function (ab) {\n                return new Uint8Array(ab);\n            });\n            o = {\n                type: \"mem\",\n                data: buff\n            };\n        }\n    } else {\n        if (typeof o === \"string\") {\n            o = {\n                type: \"file\",\n                fileName: o,\n                cacheSize: b || DEFAULT_CACHE_SIZE,\n                pageSize: c || DEFAULT_PAGE_SIZE\n            };\n        }\n    }\n    if (o.type == \"file\") {\n        return await open(o.fileName, O_RDONLY, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return await memFile.readExisting(o);\n    } else if (o.type == \"bigMem\") {\n        return await bigMemFile.readExisting(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport function readWriteExisting(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return open(o.fileName, O_CREAT | O_RDWR, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return memFile.readWriteExisting(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.readWriteExisting(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nexport function readWriteExistingOrCreate(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return open(o.fileName, O_CREAT | O_RDWR | O_EXCL, o.cacheSize);\n    } else if (o.type == \"mem\") {\n        return memFile.readWriteExisting(o);\n    } else if (o.type == \"bigMem\") {\n        return bigMemFile.readWriteExisting(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n","import * as Scalar from \"./scalar.js\";\nimport {default as buildBn128} from \"./bn128.js\";\nimport {default as buildBls12381} from \"./bls12381.js\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n","import * as Scalar from \"./scalar.js\";\nimport {default as buildBn128} from \"./bn128.js\";\nimport {default as buildBls12381} from \"./bls12381.js\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n","\nimport  { Scalar, BigBuffer } from \"ffjavascript\";\nimport * as fastFile from \"fastfile\";\n\nexport async function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {\n\n    const fd = await fastFile.readExisting(fileName, cacheSize, pageSize);\n\n    const b = await fd.read(4);\n    let readedType = \"\";\n    for (let i=0; i<4; i++) readedType += String.fromCharCode(b[i]);\n\n    if (readedType != type) throw new Error(fileName + \": Invalid File format\");\n\n    let v = await fd.readULE32();\n\n    if (v>maxVersion) throw new Error(\"Version not supported\");\n\n    const nSections = await fd.readULE32();\n\n    // Scan sections\n    let sections = [];\n    for (let i=0; i<nSections; i++) {\n        let ht = await fd.readULE32();\n        let hl = await fd.readULE64();\n        if (typeof sections[ht] == \"undefined\") sections[ht] = [];\n        sections[ht].push({\n            p: fd.pos,\n            size: hl\n        });\n        fd.pos += hl;\n    }\n\n    return {fd, sections};\n}\n\nexport async function createBinFile(fileName, type, version, nSections, cacheSize, pageSize) {\n\n    const fd = await fastFile.createOverride(fileName, cacheSize, pageSize);\n\n    const buff = new Uint8Array(4);\n    for (let i=0; i<4; i++) buff[i] = type.charCodeAt(i);\n    await fd.write(buff, 0); // Magic \"r1cs\"\n\n    await fd.writeULE32(version); // Version\n    await fd.writeULE32(nSections); // Number of Sections\n\n    return fd;\n}\n\nexport async function startWriteSection(fd, idSection) {\n    if (typeof fd.writingSection !== \"undefined\") throw new Error(\"Already writing a section\");\n    await fd.writeULE32(idSection); // Header type\n    fd.writingSection = {\n        pSectionSize: fd.pos\n    };\n    await fd.writeULE64(0); // Temporally set to 0 length\n}\n\nexport async function endWriteSection(fd) {\n    if (typeof fd.writingSection === \"undefined\") throw new Error(\"Not writing a section\");\n\n    const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;\n    const oldPos = fd.pos;\n    fd.pos = fd.writingSection.pSectionSize;\n    await fd.writeULE64(sectionSize);\n    fd.pos = oldPos;\n    delete fd.writingSection;\n}\n\nexport async function startReadUniqueSection(fd, sections, idSection) {\n    if (typeof fd.readingSection !== \"undefined\") throw new Error(\"Already reading a section\");\n    if (!sections[idSection])  throw new Error(fd.fileName + \": Missing section \"+ idSection );\n    if (sections[idSection].length>1) throw new Error(fd.fileName +\": Section Duplicated \" +idSection);\n\n    fd.pos = sections[idSection][0].p;\n\n    fd.readingSection = sections[idSection][0];\n}\n\nexport async function endReadSection(fd, noCheck) {\n    if (typeof fd.readingSection === \"undefined\") throw new Error(\"Not reading a section\");\n    if (!noCheck) {\n        if (fd.pos-fd.readingSection.p !=  fd.readingSection.size) throw new Error(\"Invalid section size reading\");\n    }\n    delete fd.readingSection;\n}\n\nexport async function writeBigInt(fd, n, n8, pos) {\n    const buff = new Uint8Array(n8);\n    Scalar.toRprLE(buff, 0, n, n8);\n    await fd.write(buff, pos);\n}\n\nexport async function readBigInt(fd, n8, pos) {\n    const buff = await fd.read(n8, pos);\n    return Scalar.fromRprLE(buff, 0, n8);\n}\n\nexport async function copySection(fdFrom, sections, fdTo, sectionId, size) {\n    if (typeof size === \"undefined\") {\n        size = sections[sectionId][0].size;\n    }\n    const chunkSize = fdFrom.pageSize;\n    await startReadUniqueSection(fdFrom, sections, sectionId);\n    await startWriteSection(fdTo, sectionId);\n    for (let p=0; p<size; p+=chunkSize) {\n        const l = Math.min(size -p, chunkSize);\n        const buff = await fdFrom.read(l);\n        await fdTo.write(buff);\n    }\n    await endWriteSection(fdTo);\n    await endReadSection(fdFrom, size != sections[sectionId][0].size);\n\n}\n\nexport async function readSection(fd, sections, idSection, offset, length) {\n\n    offset = (typeof offset === \"undefined\") ? 0 : offset;\n    length = (typeof length === \"undefined\") ? sections[idSection][0].size - offset : length;\n\n    if (offset + length > sections[idSection][0].size) {\n        throw new Error(\"Reading out of the range of the section\");\n    }\n\n    let buff;\n    if (length < (1 << 30) ) {\n        buff = new Uint8Array(length);\n    } else {\n        buff = new BigBuffer(length);\n    }\n\n    await fd.readToBuffer(buff, 0, length, sections[idSection][0].p + offset);\n    return buff;\n}\n\nexport async function sectionIsEqual(fd1, sections1, fd2, sections2, idSection) {\n    const MAX_BUFF_SIZE = fd1.pageSize * 16;\n    await startReadUniqueSection(fd1, sections1, idSection);\n    await startReadUniqueSection(fd2, sections2, idSection);\n    if (sections1[idSection][0].size != sections2[idSection][0].size) return false;\n    const totalBytes=sections1[idSection][0].size;\n    for (let i=0; i<totalBytes; i+= MAX_BUFF_SIZE) {\n        const n = Math.min(totalBytes-i, MAX_BUFF_SIZE);\n        const buff1 = await fd1.read(n);\n        const buff2 = await fd2.read(n);\n        for (let j=0; j<n; j++) if (buff1[j] != buff2[j]) return false;\n    }\n    await endReadSection(fd1);\n    await endReadSection(fd2);\n    return true;\n}\n","import {F1Field, getCurveFromR} from \"ffjavascript\";\nimport  BigArray from \"@iden3/bigarray\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nexport const R1CS_FILE_HEADER_SECTION = 1;\nexport const R1CS_FILE_CONSTRAINTS_SECTION = 2;\nexport const R1CS_FILE_WIRE2LABELID_SECTION = 3;\nexport const R1CS_FILE_CUSTOM_GATES_LIST_SECTION = 4;\nexport const R1CS_FILE_CUSTOM_GATES_USES_SECTION = 5;\n\nexport async function readR1csHeader(fd,sections,singleThread) {\n    let options;\n    if (typeof singleThread === \"object\") {\n        options = singleThread;\n    } else if (typeof singleThread === \"undefined\") {\n        options= {\n            singleThread: false,\n        };\n    } else {\n        options = {\n            singleThread: singleThread,\n        };\n    }\n\n    const res = {};\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    // Read Header\n    res.n8 = await fd.readULE32();\n    res.prime = await binFileUtils.readBigInt(fd, res.n8);\n\n    if (options.F) {\n        if (options.F.p != res.prime) throw new Error(\"Different Prime\");\n        res.F = options.F;\n    } else if (options.getFieldFromPrime) {\n        res.F = await options.getFieldFromPrime(res.prime, options.singleThread);\n    } else if (options.getCurveFromPrime) {\n        res.curve = await options.getCurveFromPrime(res.prime, options.singleThread);\n        res.F = res.curve.Fr;\n    } else {\n        try {\n            res.curve = await getCurveFromR(res.prime, options.singleThread);\n            res.F = res.curve.Fr;\n        } catch (err) {\n            res.F = new F1Field(res.prime);\n        }\n    }\n\n    res.nVars = await fd.readULE32();\n    res.nOutputs = await fd.readULE32();\n    res.nPubInputs = await fd.readULE32();\n    res.nPrvInputs = await fd.readULE32();\n    res.nLabels = await fd.readULE64();\n    res.nConstraints = await fd.readULE32();\n    res.useCustomGates = typeof sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== \"undefined\" && sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== null\n        && typeof sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== \"undefined\" && sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== null;\n\n    await binFileUtils.endReadSection(fd);\n\n    return res;\n}\n\nexport async function readConstraints(fd,sections, r1cs, logger, loggerCtx) {\n    let options;\n    if (typeof logger === \"object\") {\n        options = logger;\n    } else if (typeof logger === \"undefined\") {\n        options= {};\n    } else {\n        options = {\n            logger: logger,\n            loggerCtx: loggerCtx,\n        };\n    }\n\n    const bR1cs = await binFileUtils.readSection(fd, sections, 2);\n    let bR1csPos = 0;\n    let constraints;\n    if (r1cs.nConstraints>1<<20) {\n        constraints = new BigArray();\n    } else {\n        constraints = [];\n    }\n    for (let i=0; i<r1cs.nConstraints; i++) {\n        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading constraints: ${i}/${r1cs.nConstraints}`);\n        const c = readConstraint();\n        constraints.push(c);\n    }\n    return constraints;\n\n\n    function readConstraint() {\n        const c = [];\n        c[0] = readLC();\n        c[1] = readLC();\n        c[2] = readLC();\n        return c;\n    }\n\n    function readLC() {\n        const lc= {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos+4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4+r1cs.n8)*nIdx );\n        bR1csPos += (4+r1cs.n8)*nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i=0; i<nIdx; i++) {\n            const idx = buffV.getUint32(i*(4+r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i*(4+r1cs.n8)+4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n}\n\nexport async function readMap(fd, sections, r1cs, logger, loggerCtx) {\n    let options;\n    if (typeof logger === \"object\") {\n        options = logger;\n    } else if (typeof logger === \"undefined\") {\n        options= {};\n    } else {\n        options = {\n            logger: logger,\n            loggerCtx: loggerCtx,\n        };\n    }\n    const bMap = await binFileUtils.readSection(fd, sections, 3);\n    let bMapPos = 0;\n    let map;\n\n    if (r1cs.nVars>1<<20) {\n        map = new BigArray();\n    } else {\n        map = [];\n    }\n    for (let i=0; i<r1cs.nVars; i++) {\n        if ((options.logger)&&(i%10000 == 0)) options.logger.info(`${options.loggerCtx}: Loading map: ${i}/${r1cs.nVars}`);\n        const idx = readULE64();\n        map.push(idx);\n    }\n\n    return map;\n\n    function readULE64() {\n        const buffULE64 = bMap.slice(bMapPos, bMapPos+8);\n        bMapPos += 8;\n        const buffULE64V = new DataView(buffULE64.buffer);\n        const LSB = buffULE64V.getUint32(0, true);\n        const MSB = buffULE64V.getUint32(4, true);\n\n        return MSB * 0x100000000 + LSB;\n    }\n\n}\n\nexport async function readR1csFd(fd, sections, options) {\n    /**\n     * Options properties:\n     *  loadConstraints: <bool> true by default\n     *  loadMap:         <bool> false by default\n     *  loadCustomGates: <bool> true by default\n     */\n\n    if(typeof options !== \"object\") {\n        throw new Error(\"readR1csFd: options must be an object\");\n    }\n\n    options.loadConstraints = \"loadConstraints\" in options ? options.loadConstraints : true;\n    options.loadMap = \"loadMap\" in options ? options.loadMap : false;\n    options.loadCustomGates = \"loadCustomGates\" in options ? options.loadCustomGates : true;\n\n    const res = await readR1csHeader(fd, sections, options);\n\n    if (options.loadConstraints) {\n        res.constraints = await readConstraints(fd, sections, res, options);\n    }\n\n    // Read Labels\n\n    if (options.loadMap) {\n        res.map = await readMap(fd, sections, res, options);\n    }\n\n    if (options.loadCustomGates) {\n        if (res.useCustomGates) {\n            res.customGates = await readCustomGatesListSection(fd, sections, res);\n            res.customGatesUses = await readCustomGatesUsesSection(fd, sections, options);\n        } else {\n            res.customGates = [];\n            res.customGatesUses = [];\n        }\n    }\n    return res;\n}\n\nexport async function readR1cs(fileName, loadConstraints, loadMap, singleThread, logger, loggerCtx) {\n    let options;\n    if (typeof loadConstraints === \"object\") {\n        options = loadConstraints;\n    } else if (typeof loadConstraints === \"undefined\") {\n        options= {\n            loadConstraints: true,\n            loadMap: false,\n            loadCustomGates: true\n        };\n    } else {\n        options = {\n            loadConstraints: loadConstraints,\n            loadMap: loadMap,\n            singleThread: singleThread,\n            logger: logger,\n            loggerCtx: loggerCtx\n        };\n    }\n\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"r1cs\", 1, 1<<25, 1<<22);\n\n    const res = await readR1csFd(fd, sections, options);\n\n    await fd.close();\n\n    return res;\n}\n\nexport async function readCustomGatesListSection(fd, sections, res) {\n    await binFileUtils.startReadUniqueSection(fd, sections, R1CS_FILE_CUSTOM_GATES_LIST_SECTION);\n\n    let num = await fd.readULE32();\n\n    let customGates = [];\n    for (let i = 0; i < num; i++) {\n        let customGate = {};\n        customGate.templateName = await fd.readString();\n        let numParameters = await fd.readULE32();\n\n        customGate.parameters = Array(numParameters);\n        let buff = await fd.read(res.n8 * numParameters);\n\n        for (let j = 0; j < numParameters; j++) {\n            customGate.parameters[j] = res.F.fromRprLE(buff, j * res.n8, res.n8);;\n        }\n        customGates.push(customGate);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    return customGates;\n}\n\nexport async function readCustomGatesUsesSection(fd,sections, options) {\n    const bR1cs = await binFileUtils.readSection(fd, sections, R1CS_FILE_CUSTOM_GATES_USES_SECTION);\n    const bR1cs32 = new Uint32Array(bR1cs.buffer, bR1cs.byteOffset, bR1cs.byteLength/4);\n    const nCustomGateUses = bR1cs32[0];\n    let bR1csPos = 1;\n    let customGatesUses;\n    if (nCustomGateUses>1<<20) {\n        customGatesUses = new BigArray();\n    } else {\n        customGatesUses = [];\n    }\n    for (let i=0; i<nCustomGateUses; i++) {\n        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading custom gate uses: ${i}/${nCustomGateUses}`);\n        let c = {};\n        c.id = bR1cs32[bR1csPos++];\n        let numSignals = bR1cs32[bR1csPos++];\n        c.signals = [];\n        for (let j = 0; j < numSignals; j++) {\n            const LSB = bR1cs32[bR1csPos++];\n            const MSB = bR1cs32[bR1csPos++];\n            c.signals.push(MSB * 0x100000000 + LSB);\n        }\n        customGatesUses.push(c);\n    }\n    return customGatesUses;\n}\n\nexport async function writeR1csHeader(fd, cir) {\n    await binFileUtils.startWriteSection(fd, 1);\n    await fd.writeULE32(cir.n8); // Temporally set to 0 length\n    await binFileUtils.writeBigInt(fd, cir.prime, cir.n8);\n\n    await fd.writeULE32(cir.nVars);\n    await fd.writeULE32(cir.nOutputs);\n    await fd.writeULE32(cir.nPubInputs);\n    await fd.writeULE32(cir.nPrvInputs);\n    await fd.writeULE64(cir.nLabels);\n    await fd.writeULE32(cir.constraints.length);\n\n    await binFileUtils.endWriteSection(fd);\n}\n\nexport async function writeR1csConstraints(fd, cir, logger, loggerCtx) {\n    await binFileUtils.startWriteSection(fd, 2);\n\n    for (let i=0; i<cir.constraints.length; i++) {\n        if ((logger)&&(i%10000 == 0)) logger.info(`${loggerCtx}: writing constraint: ${i}/${cir.constraints.length}`);\n        await writeConstraint(cir.constraints[i]);\n    }\n\n    await binFileUtils.endWriteSection(fd);\n\n\n    function writeConstraint(c) {\n        const n8 = cir.n8;\n        const F = cir.F || cir.curve.Fr;\n        const idxA = Object.keys(c[0]);\n        const idxB = Object.keys(c[1]);\n        const idxC = Object.keys(c[2]);\n        const buff = new Uint8Array((idxA.length+idxB.length+idxC.length)*(n8+4) + 12);\n        const buffV = new DataView(buff.buffer);\n        let o=0;\n\n        buffV.setUint32(o, idxA.length, true); o+=4;\n        for (let i=0; i<idxA.length; i++) {\n            const coef = idxA[i];\n            buffV.setUint32(o, coef, true); o+=4;\n            F.toRprLE(buff, o, c[0][coef]); o+=n8;\n        }\n\n        buffV.setUint32(o, idxB.length, true); o+=4;\n        for (let i=0; i<idxB.length; i++) {\n            const coef = idxB[i];\n            buffV.setUint32(o, coef, true); o+=4;\n            F.toRprLE(buff, o, c[1][coef]); o+=n8;\n        }\n\n        buffV.setUint32(o, idxC.length, true); o+=4;\n        for (let i=0; i<idxC.length; i++) {\n            const coef = idxC[i];\n            buffV.setUint32(o, coef, true); o+=4;\n            F.toRprLE(buff, o, c[2][coef]); o+=n8;\n        }\n\n        return fd.write(buff);\n    }\n\n}\n\n\nexport async function writeR1csMap(fd, cir, logger, loggerCtx) {\n    await binFileUtils.startWriteSection(fd, 3);\n\n    if (cir.map.length != cir.nVars) throw new Error(\"Invalid map size\");\n    for (let i=0; i<cir.nVars; i++) {\n        if ((logger)&&(i%10000 == 0)) logger.info(`${loggerCtx}: writing map: ${i}/${cir.nVars}`);\n        await fd.writeULE64(cir.map[i]);\n    }\n\n    await binFileUtils.endWriteSection(fd);\n}\n\n\n\nexport async function writeR1cs(fileName, cir, logger, loggerCtx) {\n\n    const fd = await binFileUtils.createBinFile(fileName, \"r1cs\", 1, 3, 1<<25, 1<<22);\n\n    await writeR1csHeader(fd, cir);\n\n    await writeR1csConstraints(fd, cir, logger, loggerCtx);\n\n    await writeR1csMap(fd, cir, logger, loggerCtx);\n\n    await fd.close();\n}\n","import { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n","import {log2, buffReverseBits, array2buffer, buffer2array} from \"./utils.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default function buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n","import {log2, buffReverseBits, array2buffer, buffer2array} from \"./utils.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default function buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n","import { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n","import { buildBn128 as buildBn128wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bn128 = null;\n\nexport default async function buildBn128(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBn128wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: Scalar.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n","import { buildBls12381 as buildBls12381wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bls12381 = null;\n\nexport default async function buildBls12381(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBls12381wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: Scalar.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: Scalar.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n","\n\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nexport default class ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return Scalar.add(Scalar.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n","import { buildBls12381 as buildBls12381wasm } from \"wasmcurves\";\nimport buildEngine from \"./engine.js\";\nimport * as Scalar from \"./scalar.js\";\nimport { ModuleBuilder } from \"wasmbuilder\";\n\nglobalThis.curve_bls12381 = null;\n\nexport default async function buildBls12381(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBls12381wasm(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: Scalar.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: Scalar.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n","\n\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nexport default class ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return Scalar.add(Scalar.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n","\n\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\n\nexport default class WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = Scalar.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = Scalar.toLEBuff(Scalar.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n","\n\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\n\nexport default class WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = Scalar.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = Scalar.toLEBuff(Scalar.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","\n\nimport { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n","\n\nimport { getThreadRng } from \"./random.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nexport default class WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n","\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as fastFile from \"fastfile\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\n\nexport default async function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastFile.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await binFileUtils.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await binFileUtils.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be always m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await binFileUtils.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await binFileUtils.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n","/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\nimport * as futils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\nimport {getRandomBytes} from \"./random.js\";\nimport FFFT from \"./fft.js\";\n\nexport default class ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = Scalar.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        Scalar.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        Scalar.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return Scalar.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return Scalar.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}","import * as Scalar from \"./scalar.js\";\nimport * as utils from \"./utils.js\";\nimport { getThreadRng } from \"./random.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default class WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = Scalar.shiftRight(p, Scalar.one);\n        this.bitLength = Scalar.bitLength(p);\n        this.mask = Scalar.sub(Scalar.shiftLeft(Scalar.one, this.bitLength), Scalar.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = Scalar.shiftRight(this.p, Scalar.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = Scalar.sub(this.p, Scalar.one);\n\n        while ( !Scalar.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = Scalar.shiftRight(t, Scalar.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = Scalar.e(a, b);\n        if (Scalar.isNegative(ra)) {\n            ra = Scalar.neg(ra);\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n            ra = Scalar.sub(this.p, ra);\n        } else {\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n        }\n        const buff = utils.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = Scalar.fromRprLE(an, 0);\n        return Scalar.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = Scalar.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = Scalar.add(v,  Scalar.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = Scalar.band(v, this.mask);\n        } while (Scalar.geq(v, this.p));\n        Scalar.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return Scalar.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        Scalar.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = utils.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return utils.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n","/* global BigInt */\nimport * as Scalar from \"./scalar.js\";\nimport * as futils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\nimport {getRandomBytes} from \"./random.js\";\nimport FFFT from \"./fft.js\";\n\nexport default class ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = Scalar.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return futils.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        Scalar.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        Scalar.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return Scalar.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return Scalar.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}","import * as Scalar from \"./scalar.js\";\nimport * as utils from \"./utils.js\";\nimport { getThreadRng } from \"./random.js\";\nimport buildBatchConvert from \"./engine_batchconvert.js\";\nimport BigBuffer from \"./bigbuffer.js\";\n\n\nexport default class WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = Scalar.shiftRight(p, Scalar.one);\n        this.bitLength = Scalar.bitLength(p);\n        this.mask = Scalar.sub(Scalar.shiftLeft(Scalar.one, this.bitLength), Scalar.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = Scalar.shiftRight(this.p, Scalar.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = Scalar.sub(this.p, Scalar.one);\n\n        while ( !Scalar.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = Scalar.shiftRight(t, Scalar.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = Scalar.toLEBuff(Scalar.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = Scalar.e(a, b);\n        if (Scalar.isNegative(ra)) {\n            ra = Scalar.neg(ra);\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n            ra = Scalar.sub(this.p, ra);\n        } else {\n            if (Scalar.gt(ra, this.p)) {\n                ra = Scalar.mod(ra, this.p);\n            }\n        }\n        const buff = utils.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = Scalar.fromRprLE(an, 0);\n        return Scalar.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = Scalar.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = Scalar.add(v,  Scalar.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = Scalar.band(v, this.mask);\n        } while (Scalar.geq(v, this.p));\n        Scalar.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return Scalar.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        Scalar.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = utils.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return utils.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n","/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from './_blake.ts';\nimport { SHA256_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32,\n  type CHashO, type Input\n} from './utils.ts';\n\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\nexport type Blake2Opts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction checkBlake2Opts(\n  outputLen: number,\n  opts: Blake2Opts | undefined = {},\n  keyLen: number,\n  saltLen: number,\n  persLen: number\n) {\n  anumber(keyLen);\n  if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n  const { key, salt, personalization } = opts;\n  if (key !== undefined && (key.length < 1 || key.length > keyLen))\n    throw new Error('key length must be undefined or 1..' + keyLen);\n  if (salt !== undefined && salt.length !== saltLen)\n    throw new Error('salt must be undefined or ' + saltLen);\n  if (personalization !== undefined && personalization.length !== persLen)\n    throw new Error('personalization must be undefined or ' + persLen);\n}\n\n/** Class, from which others are subclassed. */\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected finished = false;\n  protected destroyed = false;\n  protected length: number = 0;\n  protected pos: number = 0;\n  readonly blockLen: number;\n  readonly outputLen: number;\n\n  constructor(blockLen: number, outputLen: number) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, false);\n        swap32IfBE(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        swap32IfBE(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        swap32IfBE(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(pos));\n    swap32IfBE(buffer32);\n    this.compress(buffer32, 0, true);\n    swap32IfBE(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.buffer.set(buffer);\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    // @ts-ignore\n    to.outputLen = outputLen;\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\nexport class BLAKE2b extends BLAKE2<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = B2B_IV[0] | 0;\n  private v0h = B2B_IV[1] | 0;\n  private v1l = B2B_IV[2] | 0;\n  private v1h = B2B_IV[3] | 0;\n  private v2l = B2B_IV[4] | 0;\n  private v2h = B2B_IV[5] | 0;\n  private v3l = B2B_IV[6] | 0;\n  private v3h = B2B_IV[7] | 0;\n  private v4l = B2B_IV[8] | 0;\n  private v4h = B2B_IV[9] | 0;\n  private v5l = B2B_IV[10] | 0;\n  private v5h = B2B_IV[11] | 0;\n  private v6l = B2B_IV[12] | 0;\n  private v6h = B2B_IV[13] | 0;\n  private v7l = B2B_IV[14] | 0;\n  private v7h = B2B_IV[15] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n    super(128, olen);\n    checkBlake2Opts(olen, opts, 64, 16, 16);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt);\n      this.v4l ^= swap8IfBE(slt[0]);\n      this.v4h ^= swap8IfBE(slt[1]);\n      this.v5l ^= swap8IfBE(slt[2]);\n      this.v5h ^= swap8IfBE(slt[3]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization);\n      this.v6l ^= swap8IfBE(pers[0]);\n      this.v6h ^= swap8IfBE(pers[1]);\n      this.v7l ^= swap8IfBE(pers[2]);\n      this.v7h ^= swap8IfBE(pers[3]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ): void {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n    BBUF.set(B2B_IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BBUF[28] = ~BBUF[28];\n      BBUF[29] = ~BBUF[29];\n    }\n    let j = 0;\n    const s = BSIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BBUF[0] ^ BBUF[16];\n    this.v0h ^= BBUF[1] ^ BBUF[17];\n    this.v1l ^= BBUF[2] ^ BBUF[18];\n    this.v1h ^= BBUF[3] ^ BBUF[19];\n    this.v2l ^= BBUF[4] ^ BBUF[20];\n    this.v2h ^= BBUF[5] ^ BBUF[21];\n    this.v3l ^= BBUF[6] ^ BBUF[22];\n    this.v3h ^= BBUF[7] ^ BBUF[23];\n    this.v4l ^= BBUF[8] ^ BBUF[24];\n    this.v4h ^= BBUF[9] ^ BBUF[25];\n    this.v5l ^= BBUF[10] ^ BBUF[26];\n    this.v5h ^= BBUF[11] ^ BBUF[27];\n    this.v6l ^= BBUF[12] ^ BBUF[28];\n    this.v6h ^= BBUF[13] ^ BBUF[29];\n    this.v7l ^= BBUF[14] ^ BBUF[30];\n    this.v7h ^= BBUF[15] ^ BBUF[31];\n    clean(BBUF);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2b, Blake2Opts>(\n  (opts) => new BLAKE2b(opts)\n);\n\n// =================\n// Blake2S\n// =================\n\n// prettier-ignore\nexport type Num16 = {\n  v0: number; v1: number; v2: number; v3: number;\n  v4: number; v5: number; v6: number; v7: number;\n  v8: number; v9: number; v10: number; v11: number;\n  v12: number; v13: number; v14: number; v15: number;\n};\n\n// prettier-ignore\nexport function compress(s: Uint8Array, offset: number, msg: Uint32Array, rounds: number,\n  v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number,\n  v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n): Num16 {\n  let j = 0;\n  for (let i = 0; i < rounds; i++) {\n    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n\n    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n  }\n  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\n\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2<BLAKE2s> {\n  // Internal state, same as SHA-256\n  private v0 = B2S_IV[0] | 0;\n  private v1 = B2S_IV[1] | 0;\n  private v2 = B2S_IV[2] | 0;\n  private v3 = B2S_IV[3] | 0;\n  private v4 = B2S_IV[4] | 0;\n  private v5 = B2S_IV[5] | 0;\n  private v6 = B2S_IV[6] | 0;\n  private v7 = B2S_IV[7] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    super(64, olen);\n    checkBlake2Opts(olen, opts, 32, 8, 8);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt as Uint8Array);\n      this.v4 ^= swap8IfBE(slt[0]);\n      this.v5 ^= swap8IfBE(slt[1]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization as Uint8Array);\n      this.v6 ^= swap8IfBE(pers[0]);\n      this.v7 ^= swap8IfBE(pers[1]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      abytes(key);\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n    return [v0, v1, v2, v3, v4, v5, v6, v7];\n  }\n  // prettier-ignore\n  protected set(\n    v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number\n  ): void {\n    this.v0 = v0 | 0;\n    this.v1 = v1 | 0;\n    this.v2 = v2 | 0;\n    this.v3 = v3 | 0;\n    this.v4 = v4 | 0;\n    this.v5 = v5 | 0;\n    this.v6 = v6 | 0;\n    this.v7 = v7 | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    const { h, l } = u64.fromBig(BigInt(this.length));\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        BSIGMA, offset, msg, 10,\n        this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7,\n        B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]\n      );\n    this.v0 ^= v0 ^ v8;\n    this.v1 ^= v1 ^ v9;\n    this.v2 ^= v2 ^ v10;\n    this.v3 ^= v3 ^ v11;\n    this.v4 ^= v4 ^ v12;\n    this.v5 ^= v5 ^ v13;\n    this.v6 ^= v6 ^ v14;\n    this.v7 ^= v7 ^ v15;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2s, Blake2Opts>(\n  (opts) => new BLAKE2s(opts)\n);\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setManifestsSingleton } from '../../server/app-render/manifests-singleton'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (\n        error,\n        _request,\n        errorContext,\n        silenceLog\n      ) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          silenceLog,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            const silenceLog = false\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              silenceLog,\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      const silenceLog = false\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: normalizedSrcPage,\n          routeType: 'route',\n          revalidateReason: getRevalidateReason({\n            isStaticGeneration,\n            isOnDemandRevalidate,\n          }),\n        },\n        silenceLog,\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from './utils.ts';\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA: Uint8Array = /* @__PURE__ */ Uint8Array.from([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  // Blake1, unused in others\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n\n// prettier-ignore\nexport type Num4 = { a: number; b: number; c: number; d: number; };\n\n// Mixing function G splitted in two halfs\nexport function G1s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 16);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 12);\n  return { a, b, c, d };\n}\n\nexport function G2s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 8);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 7);\n  return { a, b, c, d };\n}\n","import WasmField1 from \"./wasm_field1.js\";\nimport WasmField2 from \"./wasm_field2.js\";\nimport WasmField3 from \"./wasm_field3.js\";\nimport WasmCurve from \"./wasm_curve.js\";\nimport buildThreadManager from \"./threadman.js\";\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchApplyKey from \"./engine_applykey.js\";\nimport buildPairing from \"./engine_pairing.js\";\nimport buildMultiExp from \"./engine_multiexp.js\";\nimport buildFFT from \"./engine_fft.js\";\n\nexport default async function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = Scalar.e(params.wasm.q.toString());\n    curve.r = Scalar.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiExp(curve, \"G1\");\n    buildMultiExp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n","import WasmField1 from \"./wasm_field1.js\";\nimport WasmField2 from \"./wasm_field2.js\";\nimport WasmField3 from \"./wasm_field3.js\";\nimport WasmCurve from \"./wasm_curve.js\";\nimport buildThreadManager from \"./threadman.js\";\nimport * as Scalar from \"./scalar.js\";\nimport buildBatchApplyKey from \"./engine_applykey.js\";\nimport buildPairing from \"./engine_pairing.js\";\nimport buildMultiExp from \"./engine_multiexp.js\";\nimport buildFFT from \"./engine_fft.js\";\n\nexport default async function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = Scalar.e(params.wasm.q.toString());\n    curve.r = Scalar.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiExp(curve, \"G1\");\n    buildMultiExp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher, createXOFer, Hash,\n  swap32IfBE,\n  toBytes, u32,\n  type CHash, type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n","// Format of the outpu\n//     Hash of the last contribution  64Bytes\n//     2^N * 2 -1  TauG1 points (uncompressed)\n//     2^N  TauG2 Points (uncompressed)\n//     2^N  AlphaTauG1 Points (uncompressed)\n//     2^N  BetaTauG1 Points (uncompressed)\n//     BetaG2 (uncompressed)\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function exportChallenge(pTauFilename, challengeFilename, logger) {\n    const {fd: fdFrom, sections} = await binFileUtils.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await utils.readPTauHeader(fdFrom, sections);\n\n    const contributions = await utils.readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = blake2b.create({ dkLen: 64 }).digest();\n        curChallengeHash = utils.calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(misc.formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(misc.formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastFile.createOverride(challengeFilename);\n\n    const toHash = blake2b.create({ dkLen: 64 });\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!misc.hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(misc.formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await binFileUtils.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await binFileUtils.endReadSection(fdFrom);\n    }\n\n\n}\n\n","/*\n\nCopyright 2020 0KIMS association.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nexport function flatArray(a) {\n    let res = [];\n    fillArray(res, a);\n    return res;\n\n    function fillArray(res, a) {\n        if (Array.isArray(a)) {\n            for (let i = 0; i < a.length; i++) {\n                fillArray(res, a[i]);\n            }\n        } else {\n            res.push(a);\n        }\n    }\n}\n\n// Ref https://github.com/iden3/circom/commit/ec6388cf6eb62463539cb4c40cc3ceae9826de19\nexport function normalize(n, prime) {\n    let res = BigInt(n) % prime;\n    if (res < 0) res += prime;\n    return res;\n}\n\nexport function fnvHash(str) {\n    const uint64_max = BigInt(2) ** BigInt(64);\n    let hash = BigInt(\"0xCBF29CE484222325\");\n    for (let i = 0; i < str.length; i++) {\n        hash ^= BigInt(str[i].charCodeAt(0));\n        hash *= BigInt(0x100000001B3);\n        hash %= uint64_max;\n    }\n    let shash = hash.toString(16);\n    let n = 16 - shash.length;\n    shash = \"0\".repeat(n).concat(shash);\n    return shash;\n}\n\n// Note that this pads zeros\nexport function toArray32(s, size) {\n    const res = []; //new Uint32Array(size); //has no unshift\n    let rem = BigInt(s);\n    const radix = BigInt(0x100000000);\n    while (rem) {\n        res.unshift(Number(rem % radix));\n        rem = rem / radix;\n    }\n    if (size) {\n        let i = size - res.length;\n        while (i > 0) {\n            res.unshift(0);\n            i--;\n        }\n    }\n    return res;\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nexport default async function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport class MulZ {\n    static getZ1(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n    }\n\n    static getZ2(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n    }\n\n    static getZ3(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n    }\n\n    static mul2(a, b, ap, bp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = a_b;\n\n        let a0 = Fr.add(a_bp, ap_b);\n\n        let a1 = ap_bp;\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n        }\n\n        return [r, rz];\n    }\n\n    static mul3(a, b, c, ap, bp, cp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = Fr.mul(a_b, c);\n\n        let a0 = Fr.mul(ap_b, c);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp));\n\n        let a1 = Fr.mul(ap_bp, c);\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp));\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp));\n\n        rz = a0;\n        if (p) {\n            const a2 = Fr.mul(ap_bp, cp);\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n        }\n\n        return [r, rz];\n    }\n\n    static mul4(a, b, c, d, ap, bp, cp, dp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        const Z3 = this.getZ3(Fr);\n\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        const c_d = Fr.mul(c, d);\n        const c_dp = Fr.mul(c, dp);\n        const cp_d = Fr.mul(cp, d);\n        const cp_dp = Fr.mul(cp, dp);\n\n        r = Fr.mul(a_b, c_d);\n\n        let a0 = Fr.mul(ap_b, c_d);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n        let a1 = Fr.mul(ap_bp, c_d);\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n        let a2 = Fr.mul(a_bp, cp_dp);\n        a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n        let a3 = Fr.mul(ap_bp, cp_dp);\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n            rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n        }\n\n        return [r, rz];\n    }\n}","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport class Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof(splitFields = true) {\n        let res = splitFields ? {polynomials: {}, evaluations: {}} : {};\n\n        Object.keys(this.polynomials).forEach(key => {\n            const value = this.curve.G1.toObject(this.polynomials[key]);\n            if(splitFields) {\n                res.polynomials[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            const value = this.curve.Fr.toObject(this.evaluations[key]);\n            if(splitFields) {\n                res.evaluations[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport function toNumber(n) {\n    return BigInt(n);\n}\n\nexport function isNegative(n) {\n    return n < 0n;\n}\n\nexport function isZero(n) {\n    return n === 0n;\n}\n\nexport function bitLength(n) {\n    if (isNegative(n)) {\n        return n.toString(2).length - 1; // discard the - sign\n    } else {\n        return n.toString(2).length;\n    }\n}\n\nexport function u32(n) {\n    const b = [];\n    const v = toNumber(n);\n    b.push(Number(v & 0xFFn));\n    b.push(Number(v >> 8n & 0xFFn));\n    b.push(Number(v >> 16n & 0xFFn));\n    b.push(Number(v >> 24n & 0xFFn));\n    return b;\n}\n\nexport function u64(n) {\n    const b = [];\n    const v = toNumber(n);\n    b.push(Number(v & 0xFFn));\n    b.push(Number(v >> 8n & 0xFFn));\n    b.push(Number(v >> 16n & 0xFFn));\n    b.push(Number(v >> 24n & 0xFFn));\n    b.push(Number(v >> 32n & 0xFFn));\n    b.push(Number(v >> 40n & 0xFFn));\n    b.push(Number(v >> 48n & 0xFFn));\n    b.push(Number(v >> 56n & 0xFFn));\n    return b;\n}\n\nexport function toUTF8Array(str) {\n    var utf8 = [];\n    for (var i=0; i < str.length; i++) {\n        var charcode = str.charCodeAt(i);\n        if (charcode < 0x80) utf8.push(charcode);\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6),\n                0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n        // surrogate pair\n        else {\n            i++;\n            // UTF-16 encodes 0x10000-0x10FFFF by\n            // subtracting 0x10000 and splitting the\n            // 20 bits of 0x0-0xFFFFF into two halves\n            charcode = 0x10000 + (((charcode & 0x3ff)<<10)\n                      | (str.charCodeAt(i) & 0x3ff));\n            utf8.push(0xf0 | (charcode >>18),\n                0x80 | ((charcode>>12) & 0x3f),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n    }\n    return utf8;\n}\n\nexport function string(str) {\n    const bytes = toUTF8Array(str);\n    return [ ...varuint32(bytes.length), ...bytes ];\n}\n\nexport function varuint(n) {\n    const code = [];\n    let v = toNumber(n);\n    if (isNegative(v)) throw new Error(\"Number cannot be negative\");\n    while (!isZero(v)) {\n        code.push(Number(v & 0x7Fn));\n        v = v >> 7n;\n    }\n    if (code.length==0) code.push(0);\n    for (let i=0; i<code.length-1; i++) {\n        code[i] = code[i] | 0x80;\n    }\n    return code;\n}\n\nexport function varint(_n) {\n    let n, sign;\n    const bits = bitLength(_n);\n    if (_n<0) {\n        sign = true;\n        n = (1n << BigInt(bits)) + _n;\n    } else {\n        sign = false;\n        n = toNumber(_n);\n    }\n    const paddingBits = 7 - (bits % 7);\n\n    const padding = ((1n << BigInt(paddingBits)) - 1n) << BigInt(bits);\n    const paddingMask = ((1 << (7 - paddingBits))-1) | 0x80;\n\n    const code = varuint(n + padding);\n\n    if (!sign) {\n        code[code.length-1] = code[code.length-1] & paddingMask;\n    }\n\n    return code;\n}\n\nexport function varint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFn) v = v - 0x100000000n;\n    // bigInt(\"-80000000\", 16) as base10\n    if (v < -2147483648n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nexport function varint64(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFFFFFFFFFn) v = v - 0x10000000000000000n;\n    // bigInt(\"-8000000000000000\", 16) as base10\n    if (v < -9223372036854775808n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nexport function varuint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    return varuint(v);\n}\n\nexport function varuint64(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFFFFFFFFFn) throw new Error(\"Number too big\");\n    return varuint(v);\n}\n\nexport function toHexString(byteArray) {\n    return Array.from(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nexport function ident(text) {\n    if (typeof text === \"string\") {\n        let lines = text.split(\"\\n\");\n        for (let i=0; i<lines.length; i++) {\n            if (lines[i]) lines[i] = \"    \"+lines[i];\n        }\n        return lines.join(\"\\n\");\n    } else if (Array.isArray(text)) {\n        for (let i=0; i<text.length; i++ ) {\n            text[i] = ident(text[i]);\n        }\n        return text;\n    }\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport default function r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n","/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport fflonkProve from \"./fflonk_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await wtns_calculate(input, wasmFilename, wtns, wtnsCalcOptions);\n\n    // Compute the proof\n    return await fflonkProve(zkeyFilename, wtns, logger, proverOptions);\n}","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nexport const FF_T_POL_DEG_MIN = 3;\n\n// FFlonk A\nexport const A = 12;\n\n// ZKEY constants\nexport const ZKEY_FF_NSECTIONS = 17;\n\nexport const ZKEY_FF_HEADER_SECTION = 2;\nexport const ZKEY_FF_ADDITIONS_SECTION = 3;\nexport const ZKEY_FF_A_MAP_SECTION = 4;\nexport const ZKEY_FF_B_MAP_SECTION = 5;\nexport const ZKEY_FF_C_MAP_SECTION = 6;\nexport const ZKEY_FF_QL_SECTION = 7;\nexport const ZKEY_FF_QR_SECTION = 8;\nexport const ZKEY_FF_QM_SECTION = 9;\nexport const ZKEY_FF_QO_SECTION = 10;\nexport const ZKEY_FF_QC_SECTION = 11;\nexport const ZKEY_FF_SIGMA1_SECTION = 12;\nexport const ZKEY_FF_SIGMA2_SECTION = 13;\nexport const ZKEY_FF_SIGMA3_SECTION = 14;\nexport const ZKEY_FF_LAGRANGE_SECTION = 15;\nexport const ZKEY_FF_PTAU_SECTION = 16;\nexport const ZKEY_FF_C0_SECTION = 17;\n","/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { getCurveFromName } from \"./curves.js\";\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nexport default async function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await getCurveFromName(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.A[0])}, ${p256(proof.A[1])},` +\n    `${p256(proof.B[0])},${p256(proof.B[1])},` +\n    `${p256(proof.C[0])},${p256(proof.C[1])},` +\n    `${p256(proof.Z[0])},${p256(proof.Z[1])},` +\n    `${p256(proof.T1[0])},${p256(proof.T1[1])},` +\n    `${p256(proof.T2[0])},${p256(proof.T2[1])},` +\n    `${p256(proof.T3[0])},${p256(proof.T3[1])},` +\n    `${p256(proof.Wxi[0])},${p256(proof.Wxi[1])},` +\n    `${p256(proof.Wxiw[0])},${p256(proof.Wxiw[1])},` +\n    `${p256(proof.eval_a)},` + \n    `${p256(proof.eval_b)},` + \n    `${p256(proof.eval_c)},` + \n    `${p256(proof.eval_s1)},` + \n    `${p256(proof.eval_s2)},` + \n    `${p256(proof.eval_zw)}]` + \n    `[${inputs}]`;\n}\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {BigBuffer} from \"ffjavascript\";\n\nexport class Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n\n        let j = 0;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n                j = (j + 1) % m;\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        const upperBound = this.coef.byteLength / this.Fr.n8;\n        for (let i = domainSize; i < upperBound; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of websnark (Web Assembly zkSnark Prover).\n\n    websnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    websnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with websnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { ModuleBuilder } from \"./modulebuilder.js\";\n\nexport async function buildProtoboard(builder, defBytes, bitsPerBytes) {\n    const protoboard = new Protoboard();\n\n    protoboard.defBytes = defBytes;\n    protoboard.bitsPerBytes = bitsPerBytes || 32;\n\n    protoboard.memory = new WebAssembly.Memory({initial:20000});\n    protoboard.i32 = new Uint32Array(protoboard.memory.buffer);\n    protoboard.i8 = new Uint8Array(protoboard.memory.buffer);\n\n    const moduleBuilder = new ModuleBuilder();\n\n    const fLog32 = moduleBuilder.addIimportFunction(\"debug_log32\", \"debug\", \"log32\");\n    fLog32.addParam(\"x\", \"i32\");\n    const fLog64 = moduleBuilder.addIimportFunction(\"debug_log64\", \"debug\", \"log64\");\n    fLog64.addParam(\"x\", \"i32\");\n    fLog64.addParam(\"y\", \"i32\");\n\n    buildLog32(moduleBuilder);\n    buildLog64(moduleBuilder);\n\n    builder(moduleBuilder, protoboard);\n\n\n    const code = moduleBuilder.build();\n\n    const wasmModule = await WebAssembly.compile(code);\n\n    protoboard.log = console.log;\n\n    protoboard.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": protoboard.memory\n        },\n        debug: {\n            log32: function (c1) {\n                if (c1<0) c1 = 0x100000000+c1;\n                let s=c1.toString(16);\n                while (s.length<8) s = \"0\"+s;\n                protoboard.log(s + \": \" + c1.toString());\n            },\n            log64: function (c1, c2) {\n                if (c1<0) c1 = 0x100000000+c1;\n                if (c2<0) c2 = 0x100000000+c2;\n                const n = BigInt(c1) + (BigInt(c2) << 32n);\n                let s=n.toString(16);\n                while (s.length<16) s = \"0\"+s;\n                protoboard.log(s + \": \" + n.toString());\n            }\n        }\n    });\n\n    Object.assign(protoboard, protoboard.instance.exports);\n    Object.assign(protoboard, moduleBuilder.modules);\n\n    return protoboard;\n\n    function buildLog32(module) {\n\n        const f = module.addFunction(\"log32\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(\"debug_log32\", c.getLocal(\"x\")));\n    }\n\n    function buildLog64(module) {\n\n        const f = module.addFunction(\"log64\");\n        f.addParam(\"x\", \"i64\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(\n            \"debug_log64\",\n            c.i32_wrap_i64(c.getLocal(\"x\")),\n            c.i32_wrap_i64(\n                c.i64_shr_u(\n                    c.getLocal(\"x\"),\n                    c.i64_const(32)\n                )\n            )\n        ));\n    }\n\n}\n\nclass Protoboard {\n\n    constructor() {\n\n    }\n\n    alloc(length) {\n        if (typeof length === \"undefined\") {\n            length = this.defBytes;\n        }\n        length = (((length-1)>>3) +1)<<3;       // Align to 64 bits.\n\n        const res = this.i32[0];\n        this.i32[0] += length;\n        return res;\n    }\n\n    set(pos, nums, nBytes) {\n        if (!Array.isArray(nums)) {\n            nums = [nums];\n        }\n        if (typeof nBytes === \"undefined\") {\n            nBytes = this.defBytes;\n        }\n\n        const words = Math.floor((nBytes -1)/4)+1;\n        let p = pos;\n\n        const CHUNK = 1n << BigInt(this.bitsPerBytes);\n\n        for (let i=0; i<nums.length; i++) {\n            let v = BigInt(nums[i]);\n            for (let j=0; j<words; j++) {\n                const quotient = v / CHUNK;\n                const remainder = v % CHUNK;\n                this.i32[p>>2] = Number(remainder);\n                v = quotient;\n                p += 4;\n            }\n            if (v !== 0n) {\n                throw new Error(\"Expected v to be 0\");\n            }\n        }\n\n        return pos;\n    }\n\n    get(pos, nElements, nBytes) {\n        if (typeof nBytes == \"undefined\") {\n            if (typeof nElements == \"undefined\") {\n                nElements = 1;\n                nBytes = this.defBytes;\n            } else {\n                nElements = nBytes;\n                nBytes = this.defBytes;\n            }\n        }\n\n        const words = Math.floor((nBytes -1)/4)+1;\n\n        const CHUNK = 1n << BigInt(this.bitsPerBytes);\n\n\n        const nums = [];\n        for (let i=0; i<nElements; i++) {\n            let acc = 0n;\n            for (let j=words-1; j>=0; j--) {\n                acc = acc * CHUNK;\n                let v = this.i32[(pos>>2)+j];\n                if (this.bitsPerBytes <32) {\n                    if (v&0x80000000) v = v-0x100000000;\n                }\n                acc = acc + BigInt(v);\n            }\n            nums.push(acc);\n            pos += words*4;\n        }\n\n        if (nums.length == 1) return nums[0];\n        return nums;\n    }\n}\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as utils from \"./utils.js\";\n\nexport class CodeBuilder {\n    constructor(func) {\n        this.func = func;\n        this.functionName = func.functionName;\n        this.module = func.module;\n    }\n\n    setLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x21, ...utils.varuint32( idx )];\n    }\n\n    teeLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x22, ...utils.varuint32( idx )];\n    }\n\n    getLocal(localName) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [0x20, ...utils.varuint32( idx )];\n    }\n\n    i64_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x30, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x31, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x32, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x33, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load32_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x34, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load32_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x35, align, ...utils.varuint32(offset)];\n    }\n\n    i64_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 3 : _align;  // 64 bits alignment by default\n        return [...idxCode, 0x29, align, ...utils.varuint32(offset)];\n    }\n\n\n    i64_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 3;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 3;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x37, align, ...utils.varuint32(offset)];\n    }\n\n    i64_store32(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3e, align, ...utils.varuint32(offset)];\n    }\n\n\n    i64_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3d, align, ...utils.varuint32(offset)];\n    }\n\n\n    i64_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3c, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2c, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2d, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2e, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2f, align, ...utils.varuint32(offset)];\n    }\n\n    i32_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x28, align, ...utils.varuint32(offset)];\n    }\n\n    i32_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x36, align, ...utils.varuint32(offset)];\n    }\n\n\n    i32_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3b, align, ...utils.varuint32(offset)];\n    }\n\n    i32_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3a, align, ...utils.varuint32(offset)];\n    }\n\n    call(fnName, ...args) {\n        const idx = this.module.functionIdxByName[fnName];\n        if (idx === undefined)\n            throw new Error(`Function not defined: Function: ${fnName}`);\n        return [...[].concat(...args), 0x10, ...utils.varuint32(idx)];\n    }\n\n    call_indirect(fnIdx, ...args) {\n        return [...[].concat(...args), ...fnIdx, 0x11, 0, 0];\n    }\n\n    if(condCode, thenCode, elseCode) {\n        if (elseCode) {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x05, ...elseCode, 0x0b];\n        } else {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x0b];\n        }\n    }\n\n    block(bCode) { return [0x02, 0x40, ...bCode, 0x0b]; }\n    loop(...args) {\n        return [0x03, 0x40, ...[].concat(...[...args]), 0x0b];\n    }\n    br_if(relPath, condCode) { return [...condCode, 0x0d, ...utils.varuint32(relPath)]; }\n    br(relPath) { return [0x0c, ...utils.varuint32(relPath)]; }\n    ret(rCode) { return [...rCode, 0x0f]; }\n    drop(dCode) { return [...dCode,  0x1a]; }\n\n    i64_const(num) { return [0x42, ...utils.varint64(num)]; }\n    i32_const(num) { return [0x41, ...utils.varint32(num)]; }\n\n\n    i64_eqz(opcode) { return [...opcode, 0x50]; }\n    i64_eq(op1code, op2code) { return [...op1code, ...op2code, 0x51]; }\n    i64_ne(op1code, op2code) { return [...op1code, ...op2code, 0x52]; }\n    i64_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x53]; }\n    i64_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x54]; }\n    i64_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x55]; }\n    i64_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x56]; }\n    i64_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x57]; }\n    i64_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x58]; }\n    i64_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x59]; }\n    i64_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x5a]; }\n    i64_add(op1code, op2code) { return [...op1code, ...op2code, 0x7c]; }\n    i64_sub(op1code, op2code) { return [...op1code, ...op2code, 0x7d]; }\n    i64_mul(op1code, op2code) { return [...op1code, ...op2code, 0x7e]; }\n    i64_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x7f]; }\n    i64_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x80]; }\n    i64_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x81]; }\n    i64_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x82]; }\n    i64_and(op1code, op2code) { return [...op1code, ...op2code, 0x83]; }\n    i64_or(op1code, op2code) { return [...op1code, ...op2code, 0x84]; }\n    i64_xor(op1code, op2code) { return [...op1code, ...op2code, 0x85]; }\n    i64_shl(op1code, op2code) { return [...op1code, ...op2code, 0x86]; }\n    i64_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x87]; }\n    i64_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x88]; }\n    i64_extend_i32_s(op1code) { return [...op1code, 0xac]; }\n    i64_extend_i32_u(op1code) { return [...op1code, 0xad]; }\n    i64_clz(op1code) { return [...op1code, 0x79]; }\n    i64_ctz(op1code) { return [...op1code, 0x7a]; }\n\n    i32_eqz(op1code) { return [...op1code, 0x45]; }\n    i32_eq(op1code, op2code) { return [...op1code, ...op2code, 0x46]; }\n    i32_ne(op1code, op2code) { return [...op1code, ...op2code, 0x47]; }\n    i32_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x48]; }\n    i32_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x49]; }\n    i32_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x4a]; }\n    i32_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x4b]; }\n    i32_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x4c]; }\n    i32_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x4d]; }\n    i32_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x4e]; }\n    i32_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x4f]; }\n    i32_add(op1code, op2code) { return [...op1code, ...op2code, 0x6a]; }\n    i32_sub(op1code, op2code) { return [...op1code, ...op2code, 0x6b]; }\n    i32_mul(op1code, op2code) { return [...op1code, ...op2code, 0x6c]; }\n    i32_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x6d]; }\n    i32_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x6e]; }\n    i32_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x6f]; }\n    i32_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x70]; }\n    i32_and(op1code, op2code) { return [...op1code, ...op2code, 0x71]; }\n    i32_or(op1code, op2code) { return [...op1code, ...op2code, 0x72]; }\n    i32_xor(op1code, op2code) { return [...op1code, ...op2code, 0x73]; }\n    i32_shl(op1code, op2code) { return [...op1code, ...op2code, 0x74]; }\n    i32_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x75]; }\n    i32_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x76]; }\n    i32_rotl(op1code, op2code) { return [...op1code, ...op2code, 0x77]; }\n    i32_rotr(op1code, op2code) { return [...op1code, ...op2code, 0x78]; }\n    i32_wrap_i64(op1code) { return [...op1code, 0xa7]; }\n    i32_clz(op1code) { return [...op1code, 0x67]; }\n    i32_ctz(op1code) { return [...op1code, 0x68]; }\n\n    unreachable() { return [ 0x0 ]; }\n\n    current_memory() { return [ 0x3f, 0]; }\n\n    comment() { return []; }\n}\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as utils from \"./utils.js\";\n\nexport class CodeBuilderWat {\n    constructor(func) {\n        this.func = func;\n        this.functionName = func.functionName;\n        this.module = func.module;\n    }\n\n    setLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [valCode, `set_local $${localName}`];\n    }\n\n    teeLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [valCode, `tee_local $${localName}`];\n    }\n\n    getLocal(localName) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return `get_local $${localName}`;\n    }\n\n    genLoad(inst, def_align, idxCode, _offset, _align) {\n        let S = inst;\n        const offset = _offset || 0;\n        if (offset>0) S += ` offset=${offset}`;\n        const align = (_align === undefined) ? def_align : _align;  // 8 bits alignment by default\n        if (align!=def_align) S += ` align=${1 << align}`;\n        return [idxCode, S];\n    }\n\n\n    genStore(inst, def_align, idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (typeof _align === \"undefined\") {\n            offset = 0;\n            align = def_align;\n            codeVal = _offset;\n        } else if (typeof _codeVal === \"undefined\") {\n            offset = _offset;\n            align = def_align;\n            codeVal = _align;\n        } else {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        let S = inst;\n        if (offset>0) S += ` offset=${offset}`;\n        if (align!=def_align) S += ` align=${1 << align}`;\n        return [idxCode, codeVal, S];\n    }\n\n    i64_load8_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load8_s\", 0, idxCode, _offset, _align);\n    }\n\n    i64_load8_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load8_u\", 0, idxCode, _offset, _align);\n    }\n\n    i64_load16_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load16_s\", 1,idxCode, _offset, _align);\n    }\n\n    i64_load16_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load16_u\", 1, idxCode, _offset, _align);\n    }\n\n    i64_load32_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load32_s\", 2, idxCode, _offset, _align);\n    }\n\n    i64_load32_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load32_u\", 2, idxCode, _offset, _align);\n    }\n\n    i64_load(idxCode, _offset, _align) {\n        return this.genLoad(\"i64.load\", 3, idxCode, _offset, _align);\n    }\n\n\n    i64_store(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store\", 3, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store32(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store32\", 2, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store16(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store16\", 1, idxCode, _offset, _align, _codeVal);\n    }\n\n    i64_store8(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i64.store8\", 0, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_load8_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load8_s\", 0, idxCode, _offset, _align);\n    }\n\n    i32_load8_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load8_u\", 0, idxCode, _offset, _align);\n    }\n\n    i32_load16_s(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load16_s\", 1, idxCode, _offset, _align);\n    }\n\n    i32_load16_u(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load16_u\", 1, idxCode, _offset, _align);\n    }\n\n    i32_load(idxCode, _offset, _align) {\n        return this.genLoad(\"i32.load\", 2, idxCode, _offset, _align);\n    }\n\n    i32_store(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store\", 2, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_store16(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store16\", 1, idxCode, _offset, _align, _codeVal);\n    }\n\n    i32_store8(idxCode, _offset, _align, _codeVal) {\n        return this.genStore(\"i32.store8\", 0, idxCode, _offset, _align, _codeVal);\n    }\n\n    call(fnName, ...args) {\n        const idx = this.module.functionIdxByName[fnName];\n        if (idx === undefined)\n            throw new Error(`Function not defined: Function: ${fnName}`);\n        return [args, `call $${fnName}`];\n    }\n\n    call_indirect(fnIdx, ...args) {\n        return [args, fnIdx, \"call_indirect (type 0)\"];\n    }\n\n    if(condCode, thenCode, elseCode) {\n        if (elseCode) {\n            return [condCode, \"if\", utils.ident(thenCode), \"else\", utils.ident(elseCode), \"end\"];\n        } else {\n            return [condCode, \"if\", utils.ident(thenCode), \"end\"];\n        }\n    }\n\n    block(bCode) { return [\"block\", utils.ident(bCode), \"end\"]; }\n    loop(...args) { return [\"loop\", utils.ident(args), \"end\"]; }\n    br_if(relPath, condCode) { return [condCode, `br_if ${relPath}`]; }\n    br(relPath) { return `br ${relPath}`; }\n    ret(rCode) { return [rCode, \"return\"]; }\n    drop(dCode) { return [dCode,  \"drop\"]; }\n\n    i64_const(num) { return `i64.const ${num}`; }\n    i32_const(num) { return `i32.const ${num}`; }\n\n    i64_eqz(opcode) { return [opcode, \"i64.eqz\"]; }\n    i64_eq(op1code, op2code) { return [op1code, op2code, \"i64.eq\"]; }\n    i64_ne(op1code, op2code) { return [op1code, op2code, \"i64.ne\"]; }\n    i64_lt_s(op1code, op2code) { return [op1code, op2code, \"i64.lt_s\"]; }\n    i64_lt_u(op1code, op2code) { return [op1code, op2code, \"i64.lt_u\"]; }\n    i64_gt_s(op1code, op2code) { return [op1code, op2code, \"i64.gt_s\"]; }\n    i64_gt_u(op1code, op2code) { return [op1code, op2code, \"i64.gt_u\"]; }\n    i64_le_s(op1code, op2code) { return [op1code, op2code, \"i64.le_s\"]; }\n    i64_le_u(op1code, op2code) { return [op1code, op2code, \"i64.le_u\"]; }\n    i64_ge_s(op1code, op2code) { return [op1code, op2code, \"i64.ge_s\"]; }\n    i64_ge_u(op1code, op2code) { return [op1code, op2code, \"i64.ge_u\"]; }\n    i64_add(op1code, op2code) { return [op1code, op2code, \"i64.add\"]; }\n    i64_sub(op1code, op2code) { return [op1code, op2code, \"i64.sub\"]; }\n    i64_mul(op1code, op2code) { return [op1code, op2code, \"i64.mul\"]; }\n    i64_div_s(op1code, op2code) { return [op1code, op2code, \"i64.div_s\"]; }\n    i64_div_u(op1code, op2code) { return [op1code, op2code, \"i64.div_u\"]; }\n    i64_rem_s(op1code, op2code) { return [op1code, op2code, \"i64.rem_s\"]; }\n    i64_rem_u(op1code, op2code) { return [op1code, op2code, \"i64.rem_u\"]; }\n    i64_and(op1code, op2code) { return [op1code, op2code, \"i64.and\"]; }\n    i64_or(op1code, op2code) { return [op1code, op2code, \"i64.or\"]; }\n    i64_xor(op1code, op2code) { return [op1code, op2code, \"i64.xor\"]; }\n    i64_shl(op1code, op2code) { return [op1code, op2code, \"i64.shl\"]; }\n    i64_shr_s(op1code, op2code) { return [op1code, op2code, \"i64.shr_s\"]; }\n    i64_shr_u(op1code, op2code) { return [op1code, op2code, \"i64.shr_u\"]; }\n    i64_extend_i32_s(op1code) { return [op1code, \"i64.extend_s/i32\"]; }\n    i64_extend_i32_u(op1code) { return [op1code, \"i64.extend_u/i32\"]; }\n\n\n    i32_eqz(op1code) { return [op1code, \"i32.eqz\"]; }\n    i32_eq(op1code, op2code) { return [op1code, op2code, \"i32.eq\"]; }\n    i32_ne(op1code, op2code) { return [op1code, op2code, \"i32.ne\"]; }\n    i32_lt_s(op1code, op2code) { return [op1code, op2code, \"i32.lt_s\"]; }\n    i32_lt_u(op1code, op2code) { return [op1code, op2code, \"i32.lt_u\"]; }\n    i32_gt_s(op1code, op2code) { return [op1code, op2code, \"i32.gt_s\"]; }\n    i32_gt_u(op1code, op2code) { return [op1code, op2code, \"i32.gt_u\"]; }\n    i32_le_s(op1code, op2code) { return [op1code, op2code, \"i32.le_s\"]; }\n    i32_le_u(op1code, op2code) { return [op1code, op2code, \"i32.le_u\"]; }\n    i32_ge_s(op1code, op2code) { return [op1code, op2code, \"i32.ge_s\"]; }\n    i32_ge_u(op1code, op2code) { return [op1code, op2code, \"i32.ge_u\"]; }\n    i32_add(op1code, op2code) { return [op1code, op2code, \"i32.add\"]; }\n    i32_sub(op1code, op2code) { return [op1code, op2code, \"i32.sub\"]; }\n    i32_mul(op1code, op2code) { return [op1code, op2code, \"i32.mul\"]; }\n    i32_div_s(op1code, op2code) { return [op1code, op2code, \"i32.div_s\"]; }\n    i32_div_u(op1code, op2code) { return [op1code, op2code, \"i32.div_u\"]; }\n    i32_rem_s(op1code, op2code) { return [op1code, op2code, \"i32.rem_s\"]; }\n    i32_rem_u(op1code, op2code) { return [op1code, op2code, \"i32.rem_u\"]; }\n    i32_and(op1code, op2code) { return [op1code, op2code, \"i32.and\"]; }\n    i32_or(op1code, op2code) { return [op1code, op2code, \"i32.or\"]; }\n    i32_xor(op1code, op2code) { return [op1code, op2code, \"i32.xor\"]; }\n    i32_shl(op1code, op2code) { return [op1code, op2code, \"i32.shl\"]; }\n    i32_shr_s(op1code, op2code) { return [op1code, op2code, \"i32.shr_s\"]; }\n    i32_shr_u(op1code, op2code) { return [op1code, op2code, \"i32.shr_u\"]; }\n    i32_rotl(op1code, op2code) { return [op1code, op2code, \"i32.rotl\"]; }\n    i32_rotr(op1code, op2code) { return [op1code, op2code, \"i32.rotr\"]; }\n    i32_wrap_i64(op1code) { return [op1code, \"i32.wrap/i64\"]; }\n\n    ureachable() { return \"unreachable\"; }\n\n    current_memory() { return \"current_memory\"; }\n\n    comment(c) { return \";; \" + c; }\n\n}\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {BigBuffer} from \"ffjavascript\";\n\nexport class Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\n\nexport default async function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastFile.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\n\nexport default class F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {read} from \"./wtns_utils.js\";\n\nexport default async function wtnsExportJson(wtnsFileName) {\n\n    const w = await read(wtnsFileName);\n\n    return w;\n}\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\n\nexport default class F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {Scalar} from \"ffjavascript\";\nimport {keccak_256} from \"@noble/hashes/sha3\";\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nexport class Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = Scalar.fromRprBE(keccak_256(buffer));\n        return this.Fr.e(value);\n    }\n}","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport groth16_prove from \"./groth16_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function groth16FullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtns_calculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await groth16_prove(zkeyFileName, wtns, logger, proverOptions);\n}\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { CodeBuilder } from \"./codebuilder.js\";\nimport * as utils from \"./utils.js\";\n\nconst typeCodes = {\n    \"i32\": 0x7f,\n    \"i64\": 0x7e,\n    \"f32\": 0x7d,\n    \"f64\": 0x7c,\n    \"anyfunc\": 0x70,\n    \"func\": 0x60,\n    \"emptyblock\": 0x40\n};\n\n\nexport class FunctionBuilder {\n\n    constructor (module, fnName, fnType, moduleName, fieldName) {\n        if (fnType == \"import\") {\n            this.fnType = \"import\";\n            this.moduleName = moduleName;\n            this.fieldName = fieldName;\n        } else if (fnType == \"internal\") {\n            this.fnType = \"internal\";\n        } else {\n            throw new Error(\"Invalid function fnType: \" + fnType);\n        }\n        this.module = module;\n        this.fnName = fnName;\n        this.params = [];\n        this.locals = [];\n        this.localIdxByName = {};\n        this.code = [];\n        this.returnType = null;\n        this.nextLocal =0;\n    }\n\n    addParam(paramName, paramType) {\n        if (this.localIdxByName[paramName])\n            throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[paramName] = idx;\n        this.params.push({\n            type: paramType\n        });\n    }\n\n    addLocal(localName, localType, _length) {\n        const length = _length || 1;\n        if (this.localIdxByName[localName])\n            throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[localName] = idx;\n        this.locals.push({\n            type: localType,\n            length: length\n        });\n    }\n\n    setReturnType(returnType) {\n        if (this.returnType)\n            throw new Error(`returnType already defined. Function: ${this.fnName}`);\n        this.returnType = returnType;\n    }\n\n    getSignature() {\n        const params = [...utils.varuint32(this.params.length), ...this.params.map((p) => typeCodes[p.type])];\n        const returns = this.returnType ? [0x01, typeCodes[this.returnType]] : [0];\n        return [0x60, ...params, ...returns];\n    }\n\n    getBody() {\n        const locals = this.locals.map((l) => [\n            ...utils.varuint32(l.length),\n            typeCodes[l.type]\n        ]);\n\n        const body = [\n            ...utils.varuint32(this.locals.length),\n            ...[].concat(...locals),\n            ...this.code,\n            0x0b\n        ];\n        return [\n            ...utils.varuint32(body.length),\n            ...body\n        ];\n    }\n\n    addCode(...code) {\n        this.code.push(...[].concat(...[...code]));\n    }\n\n    getCodeBuilder() {\n        return new CodeBuilder(this);\n    }\n}\n","/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {getCurveFromName} from \"./curves.js\";\nimport {utils} from \"ffjavascript\";\n\nconst {unstringifyBigInts} = utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `0x${nstr}`;\n    return nstr;\n}\n\nexport default async function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await getCurveFromName(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},` +\n    `${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},` +\n    `${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},` +\n    `${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},` +\n    `${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},` +\n    `${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},` +\n    `${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},` +\n    `${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},` +\n    `${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},` +\n    `${p256(proof.evaluations.inv)}],` +\n    `[${inputs}]`;\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* global window */\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { u32 } from \"@noble/hashes/utils\";\nimport readline from \"readline\";\nimport { ChaCha } from \"ffjavascript\";\nimport crypto from \"crypto\";\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\n\nexport function log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nexport function formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nexport function hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nexport function cloneHasher(h) {\n    return h.clone();\n}\n\nexport function fromPartialHash(partial) {\n    // NOTE: this is unsafe and uses internal API\n    const buf = partial.subarray(0, 128);\n    const rest = u32(partial.subarray(128));\n    const res = blake2b.create({ dkLen: 64 });\n    res.buffer.set(buf);\n    (res.v0l = rest[0] | 0), (res.v0h = rest[1] | 0);\n    (res.v1l = rest[2] | 0), (res.v1h = rest[3] | 0);\n    (res.v2l = rest[4] | 0), (res.v2h = rest[5] | 0);\n    (res.v3l = rest[6] | 0), (res.v3h = rest[7] | 0);\n    (res.v4l = rest[8] | 0), (res.v4h = rest[9] | 0);\n    (res.v5l = rest[10] | 0), (res.v5h = rest[11] | 0);\n    (res.v6l = rest[12] | 0), (res.v6h = rest[13] | 0);\n    (res.v7l = rest[14] | 0), (res.v7h = rest[15] | 0);\n    const shift = 2 ** 32;\n    const len = rest[16] + rest[17] * shift;\n    const pos = rest[18] + rest[19] * shift;\n    res.length = len + pos;\n    res.pos = pos;\n    return res;\n}\n\nexport function toPartialHash(hash){\n    // NOTE: this is unsafe and uses internal API\n    const res = new Uint8Array(216);\n    const res32 = u32(res.subarray(128));\n    res.set(hash.buffer);\n    (res32[0] = hash.v0l), (res32[1] = hash.v0h);\n    (res32[2] = hash.v1l), (res32[3] = hash.v1h);\n    (res32[4] = hash.v2l), (res32[5] = hash.v2h);\n    (res32[6] = hash.v3l), (res32[7] = hash.v3h);\n    (res32[8] = hash.v4l), (res32[9] = hash.v4h);\n    (res32[10] = hash.v5l), (res32[11] = hash.v5h);\n    (res32[12] = hash.v6l), (res32[13] = hash.v6h);\n    (res32[14] = hash.v7l), (res32[15] = hash.v7h);\n    res32[18] = hash.pos;\n    res32[16] = hash.length-hash.pos;\n    return res;\n}\n\nexport async function sameRatio(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nexport function askEntropy() {\n    if (process.browser) {\n        return window.prompt(\"Enter a random text. (Entropy): \", \"\");\n    } else {\n        const rl = readline.createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Supported\n        globalThis.crypto.getRandomValues(array);\n    } else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport async function sha256digest(data) {\n    if (process.browser) { // Supported\n        const buffer = await globalThis.crypto.subtle.digest(\"SHA-256\", data.buffer);\n        return new Uint8Array(buffer);\n    } else { // NodeJS\n        return crypto.createHash(\"sha256\").update(data).digest();\n    }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n */\nexport function readUInt32BE(data, offset) {\n    return new DataView(data.buffer).getUint32(offset, false);\n}\n\nexport async function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = blake2b.create(64);\n    hasher.update(getRandomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = hasher.digest();\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = readUInt32BE(hash, i*4);\n    }\n    const rng = new ChaCha(seed);\n    return rng;\n}\n\nexport async function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = await sha256digest(curHash);\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ChaCha(seed);\n\n    return rng;\n}\n\nexport function hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nexport function byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nexport function stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\nimport { readR1cs }  from \"r1csfile\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nexport default async function r1csInfo(r1csName, logger) {\n\n    const cir = await readR1cs(r1csName);\n\n    if (Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n","/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport plonk_prove from \"./plonk_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function plonkFullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtns_calculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await plonk_prove(zkeyFileName, wtns, logger, proverOptions);\n}\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as Scalar from \"./scalar.js\";\n\n\nexport function mulScalar(F, base, e) {\n    let res;\n\n    if (Scalar.isZero(e)) return F.zero;\n\n    const n = Scalar.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nexport function exp(F, base, e) {\n\n    if (Scalar.isZero(e)) return F.one;\n\n    const n = Scalar.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as Scalar from \"./scalar.js\";\n\n\nexport function mulScalar(F, base, e) {\n    let res;\n\n    if (Scalar.isZero(e)) return F.zero;\n\n    const n = Scalar.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nexport function exp(F, base, e) {\n\n    if (Scalar.isZero(e)) return F.one;\n\n    const n = Scalar.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { CodeBuilderWat } from \"./codebuilder_wat.js\";\nimport * as utils from \"./utils.js\";\n\nexport class FunctionBuilderWat {\n\n    constructor (module, fnName, fnType, moduleName, fieldName) {\n        if (fnType == \"import\") {\n            this.fnType = \"import\";\n            this.moduleName = moduleName;\n            this.fieldName = fieldName;\n        } else if (fnType == \"internal\") {\n            this.fnType = \"internal\";\n            this.comment = moduleName;\n        } else {\n            throw new Error(\"Invalid function fnType: \" + fnType);\n        }\n        this.module = module;\n        this.fnName = fnName;\n        this.params = [];\n        this.locals = [];\n        this.localIdxByName = {};\n        this.code = [];\n        this.returnType = null;\n        this.nextLocal =0;\n    }\n\n    addParam(paramName, paramType) {\n        if (this.localIdxByName[paramName])\n            throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[paramName] = idx;\n        this.params.push({\n            type: paramType,\n            name: paramName\n        });\n    }\n\n    addLocal(localName, localType, _length) {\n        if ((typeof _length != \"undefined\") && (_length != 1)) {\n            throw new Error(\"Locals greater than 1 not implemented\");\n        }\n        if (this.localIdxByName[localName])\n            throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[localName] = idx;\n        this.locals.push({\n            type: localType,\n            name: localName,\n        });\n    }\n\n    setReturnType(returnType) {\n        if (this.returnType)\n            throw new Error(`returnType already defined. Function: ${this.fnName}`);\n        this.returnType = returnType;\n    }\n\n    getSignature() {\n        let p = \"\";\n        for (let i=0; i<this.params.length; i++) {\n            if (i==0) p += \" (param\";\n            p += \" \" + this.params[i].type;\n        }\n        if (p!=\"\") p+= \")\";\n        let r = \"\";\n        if (this.returnType) {\n            r += ` (result ${this.returnType})`;\n        }\n        return `(type $${this.getSignatureName()} (func ${p}${r}))`;\n    }\n\n    getSignatureName() {\n        let s = \"_sig_\";\n        for (let i=0; i<this.params.length; i++) {\n            s += this.params[i].type;\n        }\n        if (this.returnType) {\n            s+=\"r\"+this.returnType;\n        }\n        return s;\n    }\n\n    getBody() {\n        const src = [];\n\n        for (let i=0; i<this.params.length; i++) {\n            src.push(` (param $${this.params[i].name} ${this.params[i].type})`);\n        }\n        if (this.returnType) {\n            src.push(`(result ${this.returnType})`);\n        }\n        for (let i=0; i<this.locals.length; i++) {\n            src.push(` (local $${this.locals[i].name} ${this.locals[i].type})`);\n        }\n        src.push(this.code);\n\n        let Ss;\n        if (this.comment) {\n            Ss = this.comment.split(\"\\n\");\n            for (let i=0; i<Ss.length; i++) {\n                Ss[i] = \";; \" + Ss[i];\n            }\n        } else {\n            Ss = [];\n        }\n\n        return [\n            ...Ss,\n            `(func $${this.fnName} (type $${this.getSignatureName()})`,\n            utils.ident(src),\n            \")\"\n        ];\n\n    }\n\n    addCode(...code) {\n        this.code.push(code);\n    }\n\n    getCodeBuilder() {\n        return new CodeBuilderWat(this);\n    }\n}\n","/* globals WebAssembly */\n/*\n\nCopyright 2020 0KIMS association.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nimport {flatArray, fnvHash, toArray32, normalize} from \"./utils.js\";\nimport {Scalar, F1Field} from \"ffjavascript\";\n\nexport default async function builder(code, options) {\n    let instance;\n    let wc;\n    let memory;\n    options = options || {};\n\n    // Only circom 2 implements version lookup through exports in the WASM\n    // We default to `1` and update if we see the `getVersion` export (major version)\n    // These are updated after the instance is instantiated, assuming the functions are available\n    let majorVersion = 1;\n    // After Circom 2.0.7, Blaine added exported functions for getting minor and patch versions\n    let minorVersion = 0;\n    // If we can't look up the patch version, assume the lowest\n    let patchVersion = 0;\n\n    let codeIsWebAssemblyInstance = false;\n\n    // If code is already prepared WebAssembly.Instance, we use it directly\n    if (code instanceof WebAssembly.Instance) {\n        instance = code;\n        codeIsWebAssemblyInstance = true;\n    } else {\n        let memorySize = 32767;\n\n        if (options.memorySize) {\n            // make sure we have int\n            memorySize = parseInt(options.memorySize);\n            if (memorySize < 0) {\n                throw new Error(\"Invalid memory size\");\n            }\n        }\n\n        let memoryAllocated = false;\n        while (!memoryAllocated) {\n            try {\n                memory = new WebAssembly.Memory({initial: memorySize});\n                memoryAllocated = true;\n            } catch (err) {\n                if (memorySize <= 1) {\n                    throw err;\n                }\n                console.warn(\"Could not allocate \" + memorySize * 1024 * 64 + \" bytes. This may cause severe instability. Trying with \" + memorySize * 1024 * 64 / 2 + \" bytes\");\n                memorySize = Math.floor(memorySize / 2);\n            }\n        }\n\n        const wasmModule = await WebAssembly.compile(code);\n\n        let errStr = \"\";\n        let msgStr = \"\";\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            },\n            runtime: {\n                printDebug : function(value) {\n                    console.log(\"printDebug:\", value);\n                },\n                exceptionHandler: function (code) {\n                    let err;\n                    if (code === 1) {\n                        err = \"Signal not found. \";\n                    } else if (code === 2) {\n                        err = \"Too many signals set. \";\n                    } else if (code === 3) {\n                        err = \"Signal already set. \";\n                    } else if (code === 4) {\n                        err = \"Assert Failed. \";\n                    } else if (code === 5) {\n                        err = \"Not enough memory. \";\n                    } else if (code === 6) {\n                        err = \"Input signal array access exceeds the size. \";\n                    } else {\n                        err = \"Unknown error. \";\n                    }\n                    console.error(\"ERROR: \", code, errStr);\n                    throw new Error(err + errStr);\n                },\n                // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports\n                // `printErrorMessage` and `writeBufferMessage`.\n                printErrorMessage: function () {\n                    errStr += getMessage() + \"\\n\";\n                },\n                writeBufferMessage: function () {\n                    const msg = getMessage();\n                    // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n                    if (msg === \"\\n\") {\n                        console.log(msgStr);\n                        msgStr = \"\";\n                    } else {\n                        // If we've buffered other content, put a space in between the items\n                        if (msgStr !== \"\") {\n                            msgStr += \" \";\n                        }\n                        // Then append the message to the message we are creating\n                        msgStr += msg;\n                    }\n                },\n                showSharedRWMemory: function () {\n                    const shared_rw_memory_size = instance.exports.getFieldNumLen32();\n                    const arr = new Uint32Array(shared_rw_memory_size);\n                    for (let j = 0; j < shared_rw_memory_size; j++) {\n                        arr[shared_rw_memory_size - 1 - j] = instance.exports.readSharedRWMemory(j);\n                    }\n\n                    // In circom 2.0.7, they changed the log() function to allow strings and changed the\n                    // output API. This smoothes over the breaking change.\n                    if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {\n                        // If we've buffered other content, put a space in between the items\n                        if (msgStr !== \"\") {\n                            msgStr += \" \";\n                        }\n                        // Then append the value to the message we are creating\n                        const msg = (Scalar.fromArray(arr, 0x100000000).toString());\n                        msgStr += msg;\n                    } else {\n                        console.log(Scalar.fromArray(arr, 0x100000000));\n                    }\n                },\n                error: function (code, pstr, a, b, c, d) {\n                    let errStr;\n                    if (code === 7) {\n                        errStr = p2str(pstr) + \" \" + wc.getFr(b).toString() + \" != \" + wc.getFr(c).toString() + \" \" + p2str(d);\n                    } else if (code === 9) {\n                        errStr = p2str(pstr) + \" \" + wc.getFr(b).toString() + \" \" + p2str(c);\n                    } else if ((code === 5) && (options.sym)) {\n                        errStr = p2str(pstr) + \" \" + options.sym.labelIdx2Name[c];\n                    } else {\n                        errStr = p2str(pstr) + \" \" + a + \" \" + b + \" \" + c + \" \" + d;\n                    }\n                    console.log(\"ERROR: \", code, errStr);\n                    throw new Error(errStr);\n                },\n                log: function (a) {\n                    console.log(wc.getFr(a).toString());\n                },\n                logGetSignal: function (signal, pVal) {\n                    if (options.logGetSignal) {\n                        options.logGetSignal(signal, wc.getFr(pVal));\n                    }\n                },\n                logSetSignal: function (signal, pVal) {\n                    if (options.logSetSignal) {\n                        options.logSetSignal(signal, wc.getFr(pVal));\n                    }\n                },\n                logStartComponent: function (cIdx) {\n                    if (options.logStartComponent) {\n                        options.logStartComponent(cIdx);\n                    }\n                },\n                logFinishComponent: function (cIdx) {\n                    if (options.logFinishComponent) {\n                        options.logFinishComponent(cIdx);\n                    }\n                }\n            }\n        });\n    }\n\n    if (typeof instance.exports.getVersion == \"function\") {\n        majorVersion = instance.exports.getVersion();\n    }\n    if (typeof instance.exports.getMinorVersion == \"function\") {\n        minorVersion = instance.exports.getMinorVersion();\n    }\n    if (typeof instance.exports.getPatchVersion == \"function\") {\n        patchVersion = instance.exports.getPatchVersion();\n    }\n\n    const sanityCheck =\n        options &&\n        (\n            options.sanityCheck ||\n            options.logGetSignal ||\n            options.logSetSignal ||\n            options.logStartComponent ||\n            options.logFinishComponent\n        );\n\n    // We explicitly check for major version 2 in case there's a circom v3 in the future\n    if (majorVersion === 2) {\n        wc = new WitnessCalculatorCircom2(instance, sanityCheck);\n    } else if (majorVersion === 1) {\n        if (codeIsWebAssemblyInstance) {\n            throw new Error('Loading code from WebAssembly instance is not supported for circom version 1');\n        }\n        wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);\n    } else {\n        throw new Error(`Unsupported circom version: ${majorVersion}`);\n    }\n    return wc;\n\n    function getMessage() {\n        let message = \"\";\n        let c = instance.exports.getMessageChar();\n        while (c !== 0) {\n            message += String.fromCharCode(c);\n            c = instance.exports.getMessageChar();\n        }\n        return message;\n    }\n\n    function p2str(p) {\n        const i8 = new Uint8Array(memory.buffer);\n\n        const bytes = [];\n\n        for (let i = 0; i8[p + i] > 0; i++) bytes.push(i8[p + i]);\n\n        return String.fromCharCode.apply(null, bytes);\n    }\n}\n\nclass WitnessCalculatorCircom1 {\n    constructor(memory, instance, sanityCheck) {\n        this.memory = memory;\n        this.i32 = new Uint32Array(memory.buffer);\n        this.instance = instance;\n\n        this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;\n        const pRawPrime = this.instance.exports.getPRawPrime();\n\n        const arr = new Array(this.n32);\n        for (let i = 0; i < this.n32; i++) {\n            arr[this.n32 - 1 - i] = this.i32[(pRawPrime >> 2) + i];\n        }\n\n        this.prime = Scalar.fromArray(arr, 0x100000000);\n\n        this.Fr = new F1Field(this.prime);\n\n        this.mask32 = Scalar.fromString(\"FFFFFFFF\", 16);\n        this.NVars = this.instance.exports.getNVars();\n        this.n64 = Math.floor((this.Fr.bitLength - 1) / 64) + 1;\n        this.R = this.Fr.e(Scalar.shiftLeft(1, this.n64 * 64));\n        this.RInv = this.Fr.inv(this.R);\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return 1;\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const pSigOffset = this.allocInt();\n        const pFr = this.allocFr();\n        const keys = Object.keys(input);\n        keys.forEach((k) => {\n            const h = fnvHash(k);\n            const hMSB = parseInt(h.slice(0, 8), 16);\n            const hLSB = parseInt(h.slice(8, 16), 16);\n            try {\n                this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);\n            } catch (err) {\n                throw new Error(`Signal ${k} is not an input of the circuit.`);\n            }\n            const sigOffset = this.getInt(pSigOffset);\n            const fArr = flatArray(input[k]);\n            for (let i = 0; i < fArr.length; i++) {\n                this.setFr(pFr, fArr[i]);\n                this.instance.exports.setSignal(0, 0, sigOffset + i, pFr);\n            }\n        });\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n        const w = [];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        for (let i = 0; i < self.NVars; i++) {\n            const pWitness = self.instance.exports.getPWitness(i);\n            w.push(self.getFr(pWitness));\n        }\n\n        self.i32[0] = old0;\n        return w;\n    }\n\n    async calculateBinWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        const pWitnessBuffer = self.instance.exports.getWitnessBuffer();\n\n        self.i32[0] = old0;\n\n        const buff = self.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + (self.NVars * self.n64 * 8));\n        return new Uint8Array(buff);\n    }\n\n    allocInt() {\n        const p = this.i32[0];\n        this.i32[0] = p + 8;\n        return p;\n    }\n\n    allocFr() {\n        const p = this.i32[0];\n        this.i32[0] = p + this.n32 * 4 + 8;\n        return p;\n    }\n\n    getInt(p) {\n        return this.i32[p >> 2];\n    }\n\n    setInt(p, v) {\n        this.i32[p >> 2] = v;\n    }\n\n    getFr(p) {\n        const self = this;\n        const idx = (p >> 2);\n\n        if (self.i32[idx + 1] & 0x80000000) {\n            const arr = new Array(self.n32);\n            for (let i = 0; i < self.n32; i++) {\n                arr[self.n32 - 1 - i] = self.i32[idx + 2 + i];\n            }\n            const res = self.Fr.e(Scalar.fromArray(arr, 0x100000000));\n            if (self.i32[idx + 1] & 0x40000000) {\n                return fromMontgomery(res);\n            } else {\n                return res;\n            }\n\n        } else {\n            if (self.i32[idx] & 0x80000000) {\n                return self.Fr.e(self.i32[idx] - 0x100000000);\n            } else {\n                return self.Fr.e(self.i32[idx]);\n            }\n        }\n\n        function fromMontgomery(n) {\n            return self.Fr.mul(self.RInv, n);\n        }\n\n    }\n\n\n    setFr(p, v) {\n        const self = this;\n\n        v = self.Fr.e(v);\n\n        const minShort = self.Fr.neg(self.Fr.e(\"80000000\", 16));\n        const maxShort = self.Fr.e(\"7FFFFFFF\", 16);\n\n        if ((self.Fr.geq(v, minShort))\n            && (self.Fr.leq(v, maxShort))) {\n            let a;\n            if (self.Fr.geq(v, self.Fr.zero)) {\n                a = Scalar.toNumber(v);\n            } else {\n                a = Scalar.toNumber(self.Fr.sub(v, minShort));\n                a = a - 0x80000000;\n                a = 0x100000000 + a;\n            }\n            self.i32[(p >> 2)] = a;\n            self.i32[(p >> 2) + 1] = 0;\n            return;\n        }\n\n        self.i32[(p >> 2)] = 0;\n        self.i32[(p >> 2) + 1] = 0x80000000;\n        const arr = Scalar.toArray(v, 0x100000000);\n        for (let i = 0; i < self.n32; i++) {\n            const idx = arr.length - 1 - i;\n\n            if (idx >= 0) {\n                self.i32[(p >> 2) + 2 + i] = arr[idx];\n            } else {\n                self.i32[(p >> 2) + 2 + i] = 0;\n            }\n        }\n    }\n}\n\nclass WitnessCalculatorCircom2 {\n    constructor(instance, sanityCheck) {\n        this.instance = instance;\n\n        this.version = this.instance.exports.getVersion();\n        this.n32 = this.instance.exports.getFieldNumLen32();\n\n        this.instance.exports.getRawPrime();\n        const arr = new Uint32Array(this.n32);\n        for (let i = 0; i < this.n32; i++) {\n            arr[this.n32 - 1 - i] = this.instance.exports.readSharedRWMemory(i);\n        }\n        this.prime = Scalar.fromArray(arr, 0x100000000);\n\n        this.witnessSize = this.instance.exports.getWitnessSize();\n\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return this.instance.exports.getVersion();\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        //input is assumed to be a map from signals to arrays of bigints\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const keys = Object.keys(input);\n        let input_counter = 0;\n        keys.forEach((k) => {\n            const h = fnvHash(k);\n            const hMSB = parseInt(h.slice(0, 8), 16);\n            const hLSB = parseInt(h.slice(8, 16), 16);\n            const fArr = flatArray(input[k]);\n            // Slight deviation from https://github.com/iden3/circom/blob/v2.1.6/code_producers/src/wasm_elements/common/witness_calculator.js\n            // because I don't know when this exported function was added\n            if (typeof this.instance.exports.getInputSignalSize === \"function\") {\n                let signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);\n                if (signalSize < 0) {\n                    throw new Error(`Signal ${k} not found\\n`);\n                }\n                if (fArr.length < signalSize) {\n                    throw new Error(`Not enough values for input signal ${k}\\n`);\n                }\n                if (fArr.length > signalSize) {\n                    throw new Error(`Too many values for input signal ${k}\\n`);\n                }\n            }\n            for (let i = 0; i < fArr.length; i++) {\n                const arrFr = toArray32(normalize(fArr[i], this.prime), this.n32);\n                for (let j = 0; j < this.n32; j++) {\n                    this.instance.exports.writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);\n                }\n                try {\n                    this.instance.exports.setInputSignal(hMSB, hLSB, i);\n                    input_counter++;\n                } catch (err) {\n                    // console.log(`After adding signal ${i} of ${k}`)\n                    throw new Error(err);\n                }\n            }\n\n        });\n        if (input_counter < this.instance.exports.getInputSize()) {\n            throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);\n        }\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const w = [];\n\n        await this._doCalculateWitness(input, sanityCheck);\n\n        for (let i = 0; i < this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n            const arr = new Uint32Array(this.n32);\n            for (let j = 0; j < this.n32; j++) {\n                arr[this.n32 - 1 - j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            w.push(Scalar.fromArray(arr, 0x100000000));\n        }\n\n        return w;\n    }\n\n    async calculateWTNSBin(input, sanityCheck) {\n        const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);\n        const buff = new Uint8Array(buff32.buffer);\n        await this._doCalculateWitness(input, sanityCheck);\n\n        //\"wtns\"\n        buff[0] = \"w\".charCodeAt(0);\n        buff[1] = \"t\".charCodeAt(0);\n        buff[2] = \"n\".charCodeAt(0);\n        buff[3] = \"s\".charCodeAt(0);\n\n        //version 2\n        buff32[1] = 2;\n\n        //number of sections: 2\n        buff32[2] = 2;\n\n        //id section 1\n        buff32[3] = 1;\n\n        const n8 = this.n32 * 4;\n        //id section 1 length in 64bytes\n        const idSection1length = 8 + n8;\n        const idSection1lengthHex = idSection1length.toString(16);\n        buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);\n        buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);\n\n        //this.n32\n        buff32[6] = n8;\n\n        //prime number\n        this.instance.exports.getRawPrime();\n\n        let pos = 7;\n        for (let j = 0; j < this.n32; j++) {\n            buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n        }\n        pos += this.n32;\n\n        // witness size\n        buff32[pos] = this.witnessSize;\n        pos++;\n\n        //id section 2\n        buff32[pos] = 2;\n        pos++;\n\n        // section 2 length\n        const idSection2length = n8 * this.witnessSize;\n        const idSection2lengthHex = idSection2length.toString(16);\n        buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);\n        buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);\n\n        pos += 2;\n        for (let i = 0; i < this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n            for (let j = 0; j < this.n32; j++) {\n                buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            pos += this.n32;\n        }\n\n        return buff;\n    }\n\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport newZKey from \"./zkey_new.js\";\nimport phase2verifyFromInit from \"./zkey_verify_frominit.js\";\n\nexport default async function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await newZKey(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\n\nexport default async function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await binFileUtils.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await utils.writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await binFileUtils.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 7); // contributions\n        await binFileUtils.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\n\nexport default class F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fUtils from \"./futils.js\";\nimport buildSqrt from \"./fsqrt.js\";\n\nexport default class F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return fUtils.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */\nimport { Scalar } from \"ffjavascript\";\nimport * as curves from \"./curves.js\";\nimport {  utils }   from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts(_vk_verifier);\n    const proof = unstringifyBigInts(_proof);\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await curves.getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    if (!isWellConstructed(curve, {pi_a, pi_b, pi_c})) {\n        if(logger) logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    return G1.isValid(proof.pi_a)\n        && G2.isValid(proof.pi_b)\n        && G1.isValid(proof.pi_c);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return Scalar.geq(value, 0) && Scalar.lt(value, curve.r);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n","/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport ejs from \"ejs\";\nimport {getCurveFromName} from \"./curves.js\";\nimport {utils} from \"ffjavascript\";\n\nconst {unstringifyBigInts, stringifyBigInts} = utils;\n\nexport default async function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await getCurveFromName(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs.render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts(str);\n    }\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\n\nimport { ChaCha } from \"ffjavascript\";\n\nexport function hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nexport function getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = blake2b.create({ dkLen: 64 });\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nexport function createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\nexport function createDeltaKey(curve, transcript, rng) {\n    const delta = {};\n    delta.prvKey = curve.Fr.fromRng(rng);\n    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));\n    delta.g2_sp = hashToG2(curve, transcript);\n    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));\n    return delta;\n}\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nimport { FunctionBuilderWat } from \"./functionbuilder_wat.js\";\nimport * as utils from \"./utils.js\";\n\nexport class ModuleBuilderWat {\n\n    constructor() {\n        this.functions = [];\n        this.functionIdxByName = {};\n        this.nImportFunctions = 0;\n        this.nInternalFunctions =0;\n        this.memory = {\n            pagesSize: 1,\n            moduleName: \"env\",\n            fieldName: \"memory\"\n        };\n        this.free = 8;\n        this.datas = [];\n        this.modules = {};\n        this.exports = [];\n        this.functionsTable = [];\n    }\n\n    build() {\n        const src = [];\n        this._setSignatures();\n        src.push(this._buildType());\n        src.push(this._buildImport());\n        if (this.functionsTable.length>0) {\n            src.push(this._buildFunctionsTable());\n        }\n        if (this.exports.length > 0) {\n            src.push(this._buildExports());\n        }\n        if (this.functionsTable.length>0) {\n            src.push(this._buildElements());\n        }\n        if (this.nInternalFunctions>0) {\n            src.push(this._buildFunctions());\n        }\n        src.push(this._buildData());\n        return [\n            \"(module\",\n            utils.ident(src),\n            \")\"\n        ];\n    }\n\n    addFunction(fnName, comment) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilderWat(this, fnName, \"internal\", comment));\n\n        this.nInternalFunctions++;\n        return this.functions[idx];\n    }\n\n    addIimportFunction(fnName, moduleName, _fieldName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        if (  (this.functions.length>0)\n            &&(this.functions[this.functions.length-1].type == \"internal\"))\n            throw new Error(`Import functions must be declared before internal: ${fnName}`);\n\n        let fieldName = _fieldName || fnName;\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilderWat(this, fnName, \"import\", moduleName, fieldName));\n\n        this.nImportFunctions ++;\n        return this.functions[idx];\n    }\n\n    setMemory(pagesSize, moduleName, fieldName) {\n        this.memory = {\n            pagesSize: pagesSize,\n            moduleName: moduleName || \"env\",\n            fieldName: fieldName || \"memory\"\n        };\n    }\n\n    exportFunction(fnName, _exportName) {\n        const exportName = _exportName || fnName;\n        if (typeof(this.functionIdxByName[fnName]) === \"undefined\")\n            throw new Error(`Function not defined: ${fnName}`);\n        const idx = this.functionIdxByName[fnName];\n        if (exportName != fnName) {\n            this.functionIdxByName[exportName] = idx;\n        }\n        this.exports.push({\n            exportName: exportName,\n            idx: idx\n        });\n    }\n\n    addFunctionToTable(fnName) {\n        const idx = this.functionIdxByName[fnName];\n        this.functionsTable.push(idx);\n    }\n\n    addData(offset, bytes) {\n        this.datas.push({\n            offset: offset,\n            bytes: bytes\n        });\n    }\n\n    alloc(a, b) {\n        let size;\n        let bytes;\n        if ((Array.isArray(a) || ArrayBuffer.isView(a)) && (typeof(b) === \"undefined\")) {\n            size = a.length;\n            bytes = a;\n        } else {\n            size = a;\n            bytes = b;\n        }\n        size = (((size-1)>>3) +1)<<3;       // Align to 64 bits.\n        const p = this.free;\n        this.free += size;\n        if (bytes) {\n            this.addData(p, bytes);\n        }\n        return p;\n    }\n\n    allocString(s) {\n        const encoder = new TextEncoder();\n        const uint8array = encoder.encode(s);\n        return this.alloc([...uint8array, 0]);\n    }\n\n    _setSignatures() {\n        this.signatures = [];\n        const signatureIdxByName = {};\n        if (this.functionsTable.length>0) {\n            const signature = this.functions[this.functionsTable[0]].getSignature();\n            const signatureName = this.functions[this.functionsTable[0]].getSignatureName();\n            signatureIdxByName[signatureName] = 0;\n            this.signatures.push(signature);\n        }\n        for (let i=0; i<this.functions.length; i++) {\n            const signature = this.functions[i].getSignature();\n            const signatureName = this.functions[i].getSignatureName();\n            if (typeof(signatureIdxByName[signatureName]) === \"undefined\") {\n                signatureIdxByName[signatureName] = this.signatures.length;\n                this.signatures.push(signature);\n            }\n\n            this.functions[i].signatureIdx = signatureIdxByName[signatureName];\n            this.functions[i].signatureName = signatureName;\n        }\n\n    }\n\n    _buildType() {\n        return this.signatures;\n    }\n\n    _buildImport() {\n        const src = [];\n        src.push(`(import \"${this.memory.moduleName}\" \"${this.memory.fieldName}\" (memory ${this.memory.pagesSize}))`);\n        for (let i=0; i< this.nImportFunctions; i++) {\n            src.push(`(import \"${this.functions[i].moduleName}\" \"${this.functions[i].fieldName}\" (func $${this.functions[i].fnName} (type $${this.functions[i].getSignatureName()})))`);\n        }\n        return src;\n    }\n\n    _buildFunctionsTable() {\n        return `(table ${this.functionsTable.length} anyfunc)`;\n    }\n\n    _buildElements() {\n        let funcs=\"\";\n        for (let i=0; i<this.functionsTable.length; i++) {\n            funcs += \" $\"+this.functions[this.functionsTable[i]].fnName;\n        }\n        return `(elem (i32.const 0) ${funcs})`;\n    }\n\n    _buildExports() {\n        const src = [];\n        for (let i=0; i< this.exports.length; i++) {\n            src.push(`(export \"${this.exports[i].exportName}\" (func $${this.functions[this.exports[i].idx].fnName}))`);\n        }\n        return src;\n    }\n\n    _buildFunctions() {\n        const src = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            src.push(this.functions[i].getBody());\n        }\n        return src;\n    }\n\n    _buildData() {\n        const src = [];\n        const buf = Buffer.alloc(4);\n        buf.writeUInt32LE(this.free, 0);\n        src.push(`(data (i32.const 0) ${bytes2string(buf)})`);\n        for (let i=0; i< this.datas.length; i++) {\n            src.push(`(data (i32.const ${this.datas[i].offset}) ${bytes2string(this.datas[i].bytes)})`);\n        }\n        return src;\n\n        function bytes2string(b) {\n            let S = \"\\\"\";\n            for (let i=0; i<b.length; i++) {\n                if (b[i]<32 || b[i] >126 || b[i] == 34 || b[i]==92) {\n                    let h=b[i].toString(16);\n                    while (h.length<2) h = \"0\"+h;\n                    S += \"\\\\\" + h;\n                } else {\n                    S += String.fromCharCode(b[i]);\n                }\n            }\n            S +=  \"\\\"\";\n            return S;\n        }\n    }\n\n}\n","/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nimport { FunctionBuilder } from \"./functionbuilder.js\";\nimport * as utils from \"./utils.js\";\n\nexport class ModuleBuilder {\n\n    constructor() {\n        this.functions = [];\n        this.functionIdxByName = {};\n        this.nImportFunctions = 0;\n        this.nInternalFunctions =0;\n        this.memory = {\n            pagesSize: 1,\n            moduleName: \"env\",\n            fieldName: \"memory\"\n        };\n        this.free = 8;\n        this.datas = [];\n        this.modules = {};\n        this.exports = [];\n        this.functionsTable = [];\n    }\n\n    build() {\n        this._setSignatures();\n        return new Uint8Array([\n            ...utils.u32(0x6d736100),\n            ...utils.u32(1),\n            ...this._buildType(),\n            ...this._buildImport(),\n            ...this._buildFunctionDeclarations(),\n            ...this._buildFunctionsTable(),\n            ...this._buildExports(),\n            ...this._buildElements(),\n            ...this._buildCode(),\n            ...this._buildData()\n        ]);\n    }\n\n    addFunction(fnName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"internal\"));\n\n        this.nInternalFunctions++;\n        return this.functions[idx];\n    }\n\n    addIimportFunction(fnName, moduleName, _fieldName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        if (  (this.functions.length>0)\n            &&(this.functions[this.functions.length-1].type == \"internal\"))\n            throw new Error(`Import functions must be declared before internal: ${fnName}`);\n\n        let fieldName = _fieldName || fnName;\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"import\", moduleName, fieldName));\n\n        this.nImportFunctions ++;\n        return this.functions[idx];\n    }\n\n    setMemory(pagesSize, moduleName, fieldName) {\n        this.memory = {\n            pagesSize: pagesSize,\n            moduleName: moduleName || \"env\",\n            fieldName: fieldName || \"memory\"\n        };\n    }\n\n    exportFunction(fnName, _exportName) {\n        const exportName = _exportName || fnName;\n        if (typeof(this.functionIdxByName[fnName]) === \"undefined\")\n            throw new Error(`Function not defined: ${fnName}`);\n        const idx = this.functionIdxByName[fnName];\n        if (exportName != fnName) {\n            this.functionIdxByName[exportName] = idx;\n        }\n        this.exports.push({\n            exportName: exportName,\n            idx: idx\n        });\n    }\n\n    addFunctionToTable(fnName) {\n        const idx = this.functionIdxByName[fnName];\n        this.functionsTable.push(idx);\n    }\n\n    addData(offset, bytes) {\n        this.datas.push({\n            offset: offset,\n            bytes: bytes\n        });\n    }\n\n    alloc(a, b) {\n        let size;\n        let bytes;\n        if ((Array.isArray(a) || ArrayBuffer.isView(a)) && (typeof(b) === \"undefined\")) {\n            size = a.length;\n            bytes = a;\n        } else {\n            size = a;\n            bytes = b;\n        }\n        size = (((size-1)>>3) +1)<<3;       // Align to 64 bits.\n        const p = this.free;\n        this.free += size;\n        if (bytes) {\n            this.addData(p, bytes);\n        }\n        return p;\n    }\n\n    allocString(s) {\n        const encoder = new globalThis.TextEncoder();\n        const uint8array = encoder.encode(s);\n        return this.alloc([...uint8array, 0]);\n    }\n\n    _setSignatures() {\n        this.signatures = [];\n        const signatureIdxByName = {};\n        if (this.functionsTable.length>0) {\n            const signature = this.functions[this.functionsTable[0]].getSignature();\n            const signatureName = \"s_\"+utils.toHexString(signature);\n            signatureIdxByName[signatureName] = 0;\n            this.signatures.push(signature);\n        }\n        for (let i=0; i<this.functions.length; i++) {\n            const signature = this.functions[i].getSignature();\n            const signatureName = \"s_\"+utils.toHexString(signature);\n            if (typeof(signatureIdxByName[signatureName]) === \"undefined\") {\n                signatureIdxByName[signatureName] = this.signatures.length;\n                this.signatures.push(signature);\n            }\n\n            this.functions[i].signatureIdx = signatureIdxByName[signatureName];\n        }\n\n    }\n\n    _buildSection(sectionType, section) {\n        return [sectionType, ...utils.varuint32(section.length), ...section];\n    }\n\n    _buildType() {\n        return this._buildSection(\n            0x01,\n            [\n                ...utils.varuint32(this.signatures.length),\n                ...[].concat(...this.signatures)\n            ]\n        );\n    }\n\n    _buildImport() {\n        const entries = [];\n        entries.push([\n            ...utils.string(this.memory.moduleName),\n            ...utils.string(this.memory.fieldName),\n            0x02,\n            0x00,   //Flags no init valua\n            ...utils.varuint32(this.memory.pagesSize)\n        ]);\n        for (let i=0; i< this.nImportFunctions; i++) {\n            entries.push([\n                ...utils.string(this.functions[i].moduleName),\n                ...utils.string(this.functions[i].fieldName),\n                0x00,\n                ...utils.varuint32(this.functions[i].signatureIdx)\n            ]);\n        }\n        return this._buildSection(\n            0x02,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildFunctionDeclarations() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(...utils.varuint32(this.functions[i].signatureIdx));\n        }\n        return this._buildSection(\n            0x03,\n            [\n                ...utils.varuint32(entries.length),\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildFunctionsTable() {\n        if (this.functionsTable.length == 0) return [];\n        return this._buildSection(\n            0x04,\n            [\n                ...utils.varuint32(1),\n                0x70, 0, ...utils.varuint32(this.functionsTable.length)\n            ]\n        );\n    }\n\n    _buildElements() {\n        if (this.functionsTable.length == 0) return [];\n        const entries = [];\n        for (let i=0; i<this.functionsTable.length; i++) {\n            entries.push(...utils.varuint32(this.functionsTable[i]));\n        }\n        return this._buildSection(\n            0x09,\n            [\n                ...utils.varuint32(1),      // 1 entry\n                ...utils.varuint32(0),      // Table (0 in MVP)\n                0x41,                       // offset 0\n                ...utils.varint32(0),\n                0x0b,\n                ...utils.varuint32(this.functionsTable.length), // Number of elements\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildExports() {\n        const entries = [];\n        for (let i=0; i< this.exports.length; i++) {\n            entries.push([\n                ...utils.string(this.exports[i].exportName),\n                0x00,\n                ...utils.varuint32(this.exports[i].idx)\n            ]);\n        }\n        return this._buildSection(\n            0x07,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildCode() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(this.functions[i].getBody());\n        }\n        return this._buildSection(\n            0x0a,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildData() {\n        const entries = [];\n        entries.push([\n            0x00,\n            0x41,\n            0x00,\n            0x0b,\n            0x04,\n            ...utils.u32(this.free)\n        ]);\n        for (let i=0; i< this.datas.length; i++) {\n            entries.push([\n                0x00,\n                0x41,\n                ...utils.varint32(this.datas[i].offset),\n                0x0b,\n                ...utils.varuint32(this.datas[i].bytes.length),\n                ...this.datas[i].bytes,\n            ]);\n        }\n        return this._buildSection(\n            0x0b,\n            utils.varuint32(entries.length).concat(...entries)\n        );\n    }\n\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1cs}  from \"r1csfile\";\nimport { stringifyBigIntsWithField } from \"./misc.js\";\n\n\nexport default async function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await readR1cs(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return stringifyBigIntsWithField(Fr, cir);\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {BigBuffer} from \"ffjavascript\";\n\nexport default async function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    await binFileUtils.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const Fr = curve.Fr;\n            const sGin = G.F.n8*2;\n            const sGmid = G.F.n8*3;\n\n            let buff;\n            buff = new BigBuffer(nPoints*sGin);\n\n            await binFileUtils.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { stringifyBigIntsWithField } from \"./misc.js\";\n\nexport default async function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await binFileUtils.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await utils.readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await utils.readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return stringifyBigIntsWithField(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await binFileUtils.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await binFileUtils.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { WitnessCalculatorBuilder } from \"circom_runtime\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nexport default async function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastFile.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await WitnessCalculatorBuilder(wasm, options);\n    if (wc.circom_version() === 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await binFileUtils.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await wtnsUtils.writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastFile.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\n\nexport async function write(fd, witness, prime) {\n\n    await binFileUtils.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await binFileUtils.endWriteSection(fd);\n\n    await binFileUtils.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await binFileUtils.writeBigInt(fd, witness[i], n8);\n    }\n    await binFileUtils.endWriteSection(fd, 2);\n\n\n}\n\nexport async function writeBin(fd, witnessBin, prime) {\n\n    await binFileUtils.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await binFileUtils.endWriteSection(fd);\n\n\n    await binFileUtils.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await binFileUtils.endWriteSection(fd);\n\n}\n\nexport async function readHeader(fd, sections) {\n\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await binFileUtils.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await binFileUtils.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nexport async function read(fileName) {\n\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await binFileUtils.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nexport function getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nexport function getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nexport function getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as fastFile from \"fastfile\";\nimport {BigBuffer} from \"ffjavascript\";\n\nexport default async function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await binFileUtils.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await binFileUtils.copySection(fdOld, sections, fdNew, 13);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 14);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await binFileUtils.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await binFileUtils.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new BigBuffer(nPoints*sGin);\n\n            await binFileUtils.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as misc from \"./misc.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nexport default async function beacon(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = misc.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = await utils.keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = misc.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { WitnessCalculatorBuilder } from \"circom_runtime\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport loadSyms from \"./loadsyms.js\";\nimport {  utils }   from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\n\nexport default async function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastFile.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wcOps = {...options, sanityCheck: true};\n    let sym = await loadSyms(symName);\n    if (options.set) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await WitnessCalculatorBuilder(wasm, wcOps);\n    const w = await wc.calculateWitness(input, true);\n\n    const fdWtns = await binFileUtils.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await wtnsUtils.write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n","/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { Scalar, utils, BigBuffer } from \"ffjavascript\";\nconst {stringifyBigInts} = utils;\nimport { Proof } from \"./proof.js\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { MulZ } from \"./mul_z.js\";\nimport {  ZKEY_PL_HEADER_SECTION,\n    ZKEY_PL_ADDITIONS_SECTION,\n    ZKEY_PL_A_MAP_SECTION,\n    ZKEY_PL_B_MAP_SECTION,\n    ZKEY_PL_C_MAP_SECTION,\n    ZKEY_PL_QM_SECTION,\n    ZKEY_PL_QL_SECTION,\n    ZKEY_PL_QR_SECTION,\n    ZKEY_PL_QO_SECTION,\n    ZKEY_PL_QC_SECTION,\n    ZKEY_PL_SIGMA_SECTION,\n    ZKEY_PL_LAGRANGE_SECTION,\n    ZKEY_PL_PTAU_SECTION,\n} from \"./plonk_constants.js\";\nimport { Polynomial } from \"./polynomial/polynomial.js\";\nimport { Evaluations } from \"./polynomial/evaluations.js\";\n    \nexport default async function plonk16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    // Read witness file\n    if (logger) logger.debug(\"> Reading witness file\");\n    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);\n\n    // Read zkey file\n    if (logger) logger.debug(\"> Reading zkey file\");\n    const {fd: fdZKey, sections: zkeySections} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, zkeySections, undefined, options);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const sDomain = zkey.domainSize * n8r;\n\n    if (logger) {\n        logger.debug(\"----------------------------\");\n        logger.debug(\"  PLONK PROVE SETTINGS\");\n        logger.debug(`  Curve:         ${curve.name}`);\n        logger.debug(`  Circuit power: ${zkey.power}`);\n        logger.debug(`  Domain size:   ${zkey.domainSize}`);\n        logger.debug(`  Vars:          ${zkey.nVars}`);\n        logger.debug(`  Public vars:   ${zkey.nPublic}`);\n        logger.debug(`  Constraints:   ${zkey.nConstraints}`);\n        logger.debug(`  Additions:     ${zkey.nAdditions}`);\n        logger.debug(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.debug(\"> Reading witness file data\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new BigBuffer(n8r*zkey.nAdditions);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    let challenges = {};\n    let proof = new Proof(curve, logger);\n    const transcript = new Keccak256Transcript(curve);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.debug(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);\n\n    if (logger) logger.debug(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_PTAU_SECTION}. Powers of Tau`);\n    const PTau = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_PTAU_SECTION);\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.debug(\"\");\n    if (logger) logger.debug(\"> ROUND 1\");\n    await round1();\n\n    if (logger) logger.debug(\"> ROUND 2\");\n    await round2();\n\n    if (logger) logger.debug(\"> ROUND 3\");\n    await round3();\n\n    if (logger) logger.debug(\"> ROUND 4\");\n    await round4();\n\n    if (logger) logger.debug(\"> ROUND 5\");\n    await round5();\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    // Prepare proof\n    let _proof = proof.toObjectProof(false);\n    _proof.protocol = \"plonk\";\n    _proof.curve = curve.name;\n    \n    if (logger) logger.debug(\"PLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.debug(\" Computing additions\");\n        const additionsBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + n8r * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.debug(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + n8r);\n            offset += n8r;\n            const factor2 = additionsBuff.slice(offset, offset + n8r);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, n8r * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b1, ..., b11)  F\n        challenges.b = [];\n        for (let i=1; i<=11; i++) {\n            challenges.b[i] = curve.Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.debug(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute [a]_1, [b]_1, [c]_1\n        if (logger) logger.debug(\"> Computing A, B, C MSM\");\n        let commitA = await polynomials.A.multiExponentiation(PTau, \"A\");\n        let commitB = await polynomials.B.multiExponentiation(PTau, \"B\");\n        let commitC = await polynomials.C.multiExponentiation(PTau, \"C\");\n\n        // First output of the prover is ([A]_1, [B]_1, [C]_1)\n        proof.addPolynomial(\"A\", commitA);\n        proof.addPolynomial(\"B\", commitB);\n        proof.addPolynomial(\"C\", commitC);\n\n        return 0;\n    }\n\n    async function computeWirePolynomials() {\n        if (logger) logger.debug(\" Reading data from zkey file\");\n\n        // Build A, B and C evaluations buffer from zkey and witness files\n        buffers.A = new BigBuffer(sDomain);\n        buffers.B = new BigBuffer(sDomain);\n        buffers.C = new BigBuffer(sDomain);\n\n        // Read zkey file to the buffers\n        const aMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_A_MAP_SECTION);\n        const bMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_B_MAP_SECTION);\n        const cMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_C_MAP_SECTION);\n\n        // Compute all witness from signal ids and set them to A,B & C buffers\n        for (let i = 0; i < zkey.nConstraints; i++) {\n            const i_sFr = i * n8r;\n            const offset = i * 4;\n\n            // Compute A value from a signal id\n            const signalIdA = readUInt32(aMapBuff, offset);\n            buffers.A.set(getWitness(signalIdA), i_sFr);\n\n            // Compute B value from a signal id\n            const signalIdB = readUInt32(bMapBuff, offset);\n            buffers.B.set(getWitness(signalIdB), i_sFr);\n\n            // Compute C value from a signal id\n            const signalIdC = readUInt32(cMapBuff, offset);\n            buffers.C.set(getWitness(signalIdC), i_sFr);\n        }\n\n        buffers.A = await Fr.batchToMontgomery(buffers.A);\n        buffers.B = await Fr.batchToMontgomery(buffers.B);\n        buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n        // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n        if (logger) logger.debug(\" Computing A ifft\");\n        polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n        if (logger) logger.debug(\" Computing B ifft\");\n        polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n        if (logger) logger.debug(\" Computing C ifft\");\n        polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n        // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n        if (logger) logger.debug(\" Computing A fft\");\n        evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n        if (logger) logger.debug(\" Computing B fft\");\n        evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n        if (logger) logger.debug(\" Computing C fft\");\n        evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n        // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n        polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);\n        polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);\n        polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);\n\n        // Check degrees\n        if (polynomials.A.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"A Polynomial is not well calculated\");\n        }\n        if (polynomials.B.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"B Polynomial is not well calculated\");\n        }\n        if (polynomials.C.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"C Polynomial is not well calculated\");\n        }        \n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.debug(\"> Computing challenges beta and gamma\");\n        transcript.reset();\n\n        transcript.addPolCommitment(zkey.Qm);\n        transcript.addPolCommitment(zkey.Ql);\n        transcript.addPolCommitment(zkey.Qr);\n        transcript.addPolCommitment(zkey.Qo);\n        transcript.addPolCommitment(zkey.Qc);\n        transcript.addPolCommitment(zkey.S1);\n        transcript.addPolCommitment(zkey.S2);\n        transcript.addPolCommitment(zkey.S3);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * n8r, i * n8r + n8r));\n        }\n\n        // Add A, B, C to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"A\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"B\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"C\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.beta: \" + Fr.toString(challenges.beta, 16));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.gamma: \" + Fr.toString(challenges.gamma, 16));\n    \n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.debug(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute permutation [z]_1\n        if (logger) logger.debug(\"> Computing Z MSM\");\n        let commitZ = await polynomials.Z.multiExponentiation(PTau, \"Z\");\n\n        // Second output of the prover is ([Z]_1)\n        proof.addPolynomial(\"Z\", commitZ);\n    }\n\n    async function computeZ() {\n        if (logger) logger.debug(\" Computing Z evaluations\");\n\n        let numArr = new BigBuffer(sDomain);\n        let denArr = new BigBuffer(sDomain);\n\n        // Set the first values to 1\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        // Set initial omega\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_n8r = i * n8r;\n            \n            const a = buffers.A.slice(i_n8r, i_n8r + n8r);\n            const b = buffers.B.slice(i_n8r, i_n8r + n8r);\n            const c = buffers.C.slice(i_n8r, i_n8r + n8r);\n\n            // Z(X) := numArr / denArr\n            // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n            const betaw = Fr.mul(challenges.beta, w);\n\n            let n1 = Fr.add(a, betaw);\n            n1 = Fr.add(n1, challenges.gamma);\n\n            let n2 = Fr.add(b, Fr.mul(zkey.k1, betaw));\n            n2 = Fr.add(n2, challenges.gamma);\n\n            let n3 = Fr.add(c, Fr.mul(zkey.k2, betaw));\n            n3 = Fr.add(n3, challenges.gamma);\n\n            let num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n            let d1 = Fr.add(a, Fr.mul(evaluations.Sigma1.getEvaluation(i * 4), challenges.beta));\n            d1 = Fr.add(d1, challenges.gamma);\n\n            let d2 = Fr.add(b, Fr.mul(evaluations.Sigma2.getEvaluation(i * 4), challenges.beta));\n            d2 = Fr.add(d2, challenges.gamma);\n\n            let d3 = Fr.add(c, Fr.mul(evaluations.Sigma3.getEvaluation(i * 4), challenges.beta));\n            d3 = Fr.add(d3, challenges.gamma);\n\n            let den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            // Multiply current num value with the previous one saved in numArr\n            num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);\n            numArr.set(num, ((i + 1) % zkey.domainSize) * n8r);\n\n            // Multiply current den value with the previous one saved in denArr\n            den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);\n            denArr.set(den, ((i + 1) % zkey.domainSize) * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        // Compute the inverse of denArr to compute in the next command the\n        // division numArr/denArr by multiplying num  1/denArr\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        // Multiply numArr  denArr where denArr was inverted in the previous command\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_sFr = i * n8r;\n\n            const z = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));\n            numArr.set(z, i_sFr);\n        }\n\n        // From now on the values saved on numArr will be Z(X) buffer\n        buffers.Z = numArr;\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        // Compute polynomial coefficients z(X) from buffers.Z\n        if (logger) logger.debug(\" Computing Z ifft\");\n        polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n        // Compute extended evaluations of z(X) polynomial\n        if (logger) logger.debug(\" Computing Z fft\");\n        evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n        // Blind z(X) polynomial coefficients with blinding scalars b\n        polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n        // Check degree\n        if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n            throw new Error(\"Z Polynomial is not well calculated\");\n        }\n\n        delete buffers.Z;\n    }\n\n    async function round3() {\n        if (logger) logger.debug(\"> Computing challenge alpha\");\n\n        // STEP 3.1 - Compute evaluation challenge alpha  F\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"Z\"));\n\n        challenges.alpha = transcript.getChallenge();\n        challenges.alpha2 = Fr.square(challenges.alpha);\n        if (logger) logger.debug(\" challenges.alpha: \" + Fr.toString(challenges.alpha, 16));\n\n        // Compute quotient polynomial T(X)\n        if (logger) logger.debug(\"> Computing T polynomial\");\n        await computeT();\n\n        // Compute [T1]_1, [T2]_1, [T3]_1\n        if (logger) logger.debug(\"> Computing T MSM\");\n        let commitT1 = await polynomials.T1.multiExponentiation(PTau, \"T1\");\n        let commitT2 = await polynomials.T2.multiExponentiation(PTau, \"T2\");\n        let commitT3 = await polynomials.T3.multiExponentiation(PTau, \"T3\");\n\n        // Third output of the prover is ([T1]_1, [T2]_1, [T3]_1)\n        proof.addPolynomial(\"T1\", commitT1);\n        proof.addPolynomial(\"T2\", commitT2);\n        proof.addPolynomial(\"T3\", commitT3);        \n    }\n\n    async function computeT() {\n        if (logger)\n            logger.debug(` Reading sections ${ZKEY_PL_QL_SECTION}, ${ZKEY_PL_QR_SECTION}` +\n                `, ${ZKEY_PL_QM_SECTION}, ${ZKEY_PL_QO_SECTION}, ${ZKEY_PL_QC_SECTION}. Q selectors`);\n        // Reserve memory for Q's evaluations\n        evaluations.QL = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QR = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QM = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QO = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QC = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QL_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QR_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QM_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QO_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QC_SECTION][0].p + sDomain);\n\n        // Read Lagrange polynomials & evaluations from zkey file\n        evaluations.Lagrange = new Evaluations(new BigBuffer(sDomain * 4 * zkey.nPublic), curve, logger);\n\n        for (let i = 0; i < zkey.nPublic; i++) {\n            await fdZKey.readToBuffer(evaluations.Lagrange.eval, i * sDomain * 4, sDomain * 4, zkeySections[ZKEY_PL_LAGRANGE_SECTION][0].p + i * 5 * sDomain + sDomain);\n        }\n\n        buffers.T = new BigBuffer(sDomain * 4);\n        buffers.Tz = new BigBuffer(sDomain * 4);\n\n        if (logger) logger.debug(\" Computing T evaluations\");\n\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize * 4; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0))\n                logger.debug(`      T evaluation ${i}/${zkey.domainSize * 4}`);\n\n            const a = evaluations.A.getEvaluation(i);\n            const b = evaluations.B.getEvaluation(i);\n            const c = evaluations.C.getEvaluation(i);\n            const z = evaluations.Z.getEvaluation(i);\n            const zw = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n            const qm = evaluations.QM.getEvaluation(i);\n            const ql = evaluations.QL.getEvaluation(i);\n            const qr = evaluations.QR.getEvaluation(i);\n            const qo = evaluations.QO.getEvaluation(i);\n            const qc = evaluations.QC.getEvaluation(i);\n            const s1 = evaluations.Sigma1.getEvaluation(i);\n            const s2 = evaluations.Sigma2.getEvaluation(i);\n            const s3 = evaluations.Sigma3.getEvaluation(i);\n\n            const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w));\n            const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w));\n            const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w));\n\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w2), Fr.mul(challenges.b[8], w)), challenges.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);\n\n            let pi = Fr.zero;\n            for (let j = 0; j < zkey.nPublic; j++) {\n                const offset = (j * 4 * zkey.domainSize) + i;\n\n                const lPol = evaluations.Lagrange.getEvaluation(offset);\n                const aVal = buffers.A.slice(j * n8r, (j + 1) * n8r);\n\n                pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n            }\n\n            // e1 := a(X)b(X)qM(X) + a(X)qL(X) + b(X)qR(X) + c(X)qO(X) + PI(X) + qC(X)\n            let [e1, e1z] = MulZ.mul2(a, b, ap, bp, i % 4, Fr);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pi);\n            e1 = Fr.add(e1, qc);\n\n            // e2 := [(a(X) + X + )(b(X) + k1X + )(c(X) + k2X + )z(X)]\n            const betaw = Fr.mul(challenges.beta, w);\n            let e2a = a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, challenges.gamma);\n\n            let e2b = b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, challenges.gamma);\n\n            let e2c = c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, challenges.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i % 4, Fr);\n            e2 = Fr.mul(e2, challenges.alpha);\n            e2z = Fr.mul(e2z, challenges.alpha);\n\n            // e3 := [(a(X) + S1(X) + )(b(X) + S2(X) + )(c(X) + S3(X) + )z(X)]\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));\n            e3a = Fr.add(e3a, challenges.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));\n            e3b = Fr.add(e3b, challenges.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));\n            e3c = Fr.add(e3c, challenges.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i % 4, Fr);\n\n            e3 = Fr.mul(e3, challenges.alpha);\n            e3z = Fr.mul(e3z, challenges.alpha);\n\n            // e4 := ^2(z(X)1)L1(X)\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i));\n            e4 = Fr.mul(e4, challenges.alpha2);\n\n            let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i));\n            e4z = Fr.mul(e4z, challenges.alpha2);\n\n\n            let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            buffers.T.set(t, i * n8r);\n            buffers.Tz.set(tz, i * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power + 2]);\n        }\n\n        // Compute the coefficients of the polynomial T0(X) from buffers.T0\n        if (logger)\n            logger.debug(\" Computing T ifft\");\n        polynomials.T = await Polynomial.fromEvaluations(buffers.T, curve, logger);\n\n        // Divide the polynomial T0 by Z_H(X)\n        if (logger)\n            logger.debug(\" Computing T / ZH\");\n        polynomials.T.divZh(zkey.domainSize, 4);\n\n        // Compute the coefficients of the polynomial Tz(X) from buffers.Tz\n        if (logger)\n            logger.debug(\" Computing Tz ifft\");\n        polynomials.Tz = await Polynomial.fromEvaluations(buffers.Tz, curve, logger);\n\n        // Add the polynomial T1z to T1 to get the final polynomial T1\n        polynomials.T.add(polynomials.Tz);\n\n        // Check degree\n        if (polynomials.T.degree() >= zkey.domainSize * 3 + 6) {\n            throw new Error(\"T Polynomial is not well calculated\");\n        }\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // T1' and T2'  with a degree < n and T3' with a degree n+5\n        // such that t(x) = T1'(X) + X^n T2'(X) + X^{2n} T3'(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // T1(X) = T1'(X) + b_10 X^n\n        // T2(X) = T2'(X) - b_10 + b_11 X^n\n        // T3(X) = T3'(X) - b_11\n        // such that\n        // t(X) = T1(X) + X^n T2(X) + X^2n T3(X)\n        if (logger) logger.debug(\" Computing T1, T2, T3 polynomials\");\n        polynomials.T1 = new Polynomial(new BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T2 = new Polynomial(new BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T3 = new Polynomial(new BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);\n        polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);\n        polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);\n\n        // Add blinding scalar b_10 as a new coefficient n\n        polynomials.T1.setCoef(zkey.domainSize, challenges.b[10]);\n\n        // compute t_mid(X)\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);\n        polynomials.T2.setCoef(0, lowestMid);\n        polynomials.T2.setCoef(zkey.domainSize, challenges.b[11]);\n\n        // compute t_high(X)\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);\n        polynomials.T3.setCoef(0, lowestHigh);\n    }\n\n    async function round4() {\n        if (logger) logger.debug(\"> Computing challenge xi\");\n\n        // STEP 4.1 - Compute evaluation challenge xi  F\n        transcript.reset();\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"T1\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T2\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T3\"));\n\n        challenges.xi = transcript.getChallenge();\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        \n        if (logger) logger.debug(\" challenges.xi: \" + Fr.toString(challenges.xi, 16));  \n\n        // Fourth output of the prover is ( a(xi), b(xi), c(xi), s1(xi), s2(xi), z(xiw) )\n        proof.addEvaluation(\"eval_a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_zw\", polynomials.Z.evaluate(challenges.xiw));\n    }\n\n    async function round5() {\n        if (logger) logger.debug(\"> Computing challenge v\");\n        \n        // STEP 5.1 - Compute evaluation challenge v  F\n        transcript.reset();\n        transcript.addScalar(challenges.xi);\n        transcript.addScalar(proof.getEvaluation(\"eval_a\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_b\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_c\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s1\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s2\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_zw\"));\n\n        challenges.v = [];\n        challenges.v[1] = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.v: \" + Fr.toString(challenges.v[1], 16));\n\n        for (let i = 2; i < 6; i++) {\n            challenges.v[i] = Fr.mul(challenges.v[i - 1], challenges.v[1]);\n        }\n\n        // STEP 5.2 Compute linearisation polynomial r(X)\n        if (logger) logger.debug(\"> Computing linearisation polynomial R(X)\");\n        await computeR();\n\n        //STEP 5.3 Compute opening proof polynomial Wxi(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxi(X) polynomial\");\n        computeWxi();\n\n        //STEP 5.4 Compute opening proof polynomial Wxiw(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxiw(X) polynomial\");\n        computeWxiw();\n\n        if (logger) logger.debug(\"> Computing Wxi, Wxiw MSM\");\n        let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, \"Wxi\");\n        let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, \"Wxiw\");\n\n        // Fifth output of the prover is ([Wxi]_1, [Wxiw]_1)\n        proof.addPolynomial(\"Wxi\", commitWxi);\n        proof.addPolynomial(\"Wxiw\", commitWxiw);\n    }\n\n    async function computeR() {\n        const Fr = curve.Fr;\n    \n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_PL_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_PL_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_PL_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_PL_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_PL_QC_SECTION][0].p);   \n        \n        challenges.xin = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            challenges.xin = Fr.square(challenges.xin);\n        }\n\n        challenges.zh = Fr.sub(challenges.xin, Fr.one);\n\n        const L = [];\n\n        const n = Fr.e(zkey.domainSize);\n        let w = Fr.one;\n        for (let i = 1; i <= Math.max(1, zkey.nPublic); i++) {\n            L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        const eval_l1 = Fr.div(\n            Fr.sub(challenges.xin, Fr.one),\n            Fr.mul(n, Fr.sub(challenges.xi, Fr.one))\n        );\n\n        if (logger) {\n            logger.debug(\"Lagrange Evaluations: \");\n            for (let i=1; i<L.length; i++) {\n                logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n            }\n        }\n\n        let eval_pi = Fr.zero;\n        for (let i=0; i<publicSignals.length; i++) {\n            const w = Fr.e(publicSignals[i]);\n            eval_pi = Fr.sub(eval_pi, Fr.mul(w, L[i+1]));\n        }\n\n        if (logger) logger.debug(\"PI: \" + Fr.toString(eval_pi, 16));\n\n        // Compute constant parts of R(X)\n        const coef_ab = Fr.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);\n\n        let e2a = proof.evaluations.eval_a;\n        const betaxi = Fr.mul(challenges.beta, challenges.xi);\n        e2a = Fr.add(e2a, betaxi);\n        e2a = Fr.add(e2a, challenges.gamma);\n\n        let e2b = proof.evaluations.eval_b;\n        e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add(e2b, challenges.gamma);\n\n        let e2c = proof.evaluations.eval_c;\n        e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add(e2c, challenges.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), challenges.alpha);\n\n        let e3a = proof.evaluations.eval_a;\n        e3a = Fr.add(e3a, Fr.mul(challenges.beta, proof.evaluations.eval_s1));\n        e3a = Fr.add(e3a, challenges.gamma);\n\n        let e3b = proof.evaluations.eval_b;\n        e3b = Fr.add(e3b, Fr.mul(challenges.beta, proof.evaluations.eval_s2));\n        e3b = Fr.add(e3b, challenges.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, proof.evaluations.eval_zw);\n        e3 = Fr.mul(e3, challenges.alpha);\n\n        const e4 = Fr.mul(eval_l1, challenges.alpha2);\n\n        polynomials.R = new Polynomial(new BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.R.add(polynomials.QM, coef_ab);\n        polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);\n        polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);\n        polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);\n        polynomials.R.add(polynomials.QC);\n        polynomials.R.add(polynomials.Z, e2);\n        polynomials.R.sub(polynomials.Sigma3, Fr.mul(e3, challenges.beta));\n        polynomials.R.add(polynomials.Z, e4);\n\n        let tmp = Polynomial.fromPolynomial(polynomials.T3, curve, logger);\n        tmp.mulScalar(Fr.square(challenges.xin));\n        tmp.add(polynomials.T2, challenges.xin);\n        tmp.add(polynomials.T1);\n        tmp.mulScalar(challenges.zh);\n\n        polynomials.R.sub(tmp);\n\n        let r0 = Fr.sub(eval_pi, Fr.mul(e3, Fr.add(proof.evaluations.eval_c, challenges.gamma)));\n        r0 = Fr.sub(r0, e4);\n\n        if (logger) logger.debug(\"r0: \" + Fr.toString(r0, 16));\n\n        polynomials.R.addScalar(r0);\n    }\n\n    function computeWxi() {\n        polynomials.Wxi = new Polynomial(new BigBuffer(sDomain + 6 * n8r), curve, logger);\n\n        polynomials.Wxi.add(polynomials.R);\n        polynomials.Wxi.add(polynomials.A, challenges.v[1]);\n        polynomials.Wxi.add(polynomials.B, challenges.v[2]);\n        polynomials.Wxi.add(polynomials.C, challenges.v[3]);\n        polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);\n        polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);\n\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));\n\n        polynomials.Wxi.divByZerofier(1, challenges.xi);\n    }\n\n    async function computeWxiw() {\n        polynomials.Wxiw = Polynomial.fromPolynomial(polynomials.Z, curve, logger);\n        polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);\n\n        polynomials.Wxiw.divByZerofier(1, challenges.xiw);\n    }\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { log2 } from \"./misc.js\";\nimport { Scalar, utils, BigBuffer } from \"ffjavascript\";\nconst {stringifyBigInts} = utils;\n\nexport default async function groth16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey, undefined, options);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = log2(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await binFileUtils.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await binFileUtils.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await binFileUtils.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await binFileUtils.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buildABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof BigBuffer) {\n        outBuff = new BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as misc from \"./misc.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nconst sameRatio = misc.sameRatio;\nimport {hashG1, hashPubKey} from \"./zkey_utils.js\";\nimport { Scalar, ChaCha, BigBuffer } from \"ffjavascript\";\n\n\n\nexport default async function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    const {fd, sections} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await zkeyUtils.readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = blake2b.create({ dkLen: 64 });\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = misc.cloneHasher(accumulatedHasher);\n\n        hashG1(ourHasher, curve, c.delta.g1_s);\n        hashG1(ourHasher, curve, c.delta.g1_sx);\n\n        if (!misc.hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = hashToG2(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = await misc.rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        hashPubKey(accumulatedHasher, curve, c);\n\n        const contributionHasher = blake2b.create({ dkLen: 64 });\n        hashPubKey(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await binFileUtils.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await zkeyUtils.readHeader(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await zkeyUtils.readMPCParams(fdInit, curve, sectionsInit);\n    if (!misc.hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(misc.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(misc.formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${misc.byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils.startReadUniqueSection(fd1, sections1, idSection);\n        await binFileUtils.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = misc.getRandomBytes(4*n);\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await binFileUtils.endReadSection(fd1);\n        await binFileUtils.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await binFileUtils.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = misc.readUInt32BE(misc.getRandomBytes(4), 0);\n        }\n        const rng = new ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubtract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Calculate odd coefficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await binFileUtils.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await binFileUtils.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubtract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubtractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubtractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as curves from \"./curves.js\";\nimport { BigBuffer, utils } from \"ffjavascript\";\nimport { Proof } from \"./proof.js\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { Scalar } from \"ffjavascript\";\n\nconst { unstringifyBigInts } = utils;\n\nexport default async function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n\n    const curve = await curves.getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        if (logger) logger.error(\"Proof commitments are not valid\");\n        return false;\n    }\n\n    // STEP 2 - Validate that all evaluations  F\n    if (logger) logger.info(\"> Checking evaluations belong to F\");\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid.\");\n        return false;\n    }\n\n    // STEP 3 - Validate that w_i  F for i  [l]\n    if (logger) logger.info(\"> Checking public inputs belong to F\");\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return Scalar.geq(value, 0) && Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.evaluations.ql)\n        && checkEvaluationIsValid(curve, proof.evaluations.qr)\n        && checkEvaluationIsValid(curve, proof.evaluations.qm)\n        && checkEvaluationIsValid(curve, proof.evaluations.qo)\n        && checkEvaluationIsValid(curve, proof.evaluations.qc)\n        && checkEvaluationIsValid(curve, proof.evaluations.s1)\n        && checkEvaluationIsValid(curve, proof.evaluations.s2)\n        && checkEvaluationIsValid(curve, proof.evaluations.s3)\n        && checkEvaluationIsValid(curve, proof.evaluations.a)\n        && checkEvaluationIsValid(curve, proof.evaluations.b)\n        && checkEvaluationIsValid(curve, proof.evaluations.c)\n        && checkEvaluationIsValid(curve, proof.evaluations.z)\n        && checkEvaluationIsValid(curve, proof.evaluations.zw)\n        && checkEvaluationIsValid(curve, proof.evaluations.t1w)\n        && checkEvaluationIsValid(curve, proof.evaluations.t2w);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n    challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new BigBuffer(size * Fr.n8);\n    let denArr = new BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve);\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing r0(y)\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));\n\n        res = Fr.add(res, Fr.mul(c0, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve);\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 4; i++) {\n        let c1 = proof.evaluations.a;\n        c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n\n        res = Fr.add(res, Fr.mul(c1, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve);\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let res = Fr.zero;\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i]));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i + 3]));\n    }\n\n    return res;\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}\n\n\nexport function computeLagrangeLiSi(roots, x, xi, curve) {\n    const Fr = curve.Fr;\n    const len = roots.length;\n\n    const num = Fr.sub(Fr.exp(x, len), xi);\n    const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n\n    const Li = [];\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[((len - 1) * i) % len];\n        const den3 = Fr.sub(x, roots[i]);\n\n        Li[i] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));\n    }\n\n    return Li;\n}\n\nexport function computeLagrangeLiS2(roots, value, xi0, xi1, curve) {\n    const Fr = curve.Fr;\n\n    const Li = [];\n\n    const len = roots[0].length;\n    const n = len * roots.length;\n\n    const num1 = Fr.exp(value, n);\n    const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));\n    const num3 = Fr.mul(xi0, xi1);\n    const num = Fr.add(Fr.sub(num1, num2), num3);\n\n    let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[0][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[0][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i] = Fr.div(num, den);\n    }\n\n    den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[1][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[1][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i + len] = Fr.div(num, den);\n    }\n\n    return Li;\n}\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nimport * as fUtils from \"./futils.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return Scalar.gt(a, na);\n    }\n}\n\n\nexport default class EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nimport * as fUtils from \"./futils.js\";\nimport * as Scalar from \"./scalar.js\";\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return Scalar.gt(a, na);\n    }\n}\n\n\nexport default class EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return fUtils.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport {getCurveFromQ as getCurve} from \"./curves.js\";\nimport {utils} from \"ffjavascript\";\nimport {FFLONK_PROTOCOL_ID} from \"./zkey_constants.js\";\n\nconst {stringifyBigInts} = utils;\n\nexport default async function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await binFileUtils.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey, logger);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await getCurve(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await getCurve(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts(vKey);\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as keyPair from \"./keypair.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { ChaCha, BigBuffer } from \"ffjavascript\";\nimport * as misc from \"./misc.js\";\nconst sameRatio = misc.sameRatio;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = await utils.keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nexport default async function verify(tauFilename, logger) {\n    let sr;\n\n    const {fd, sections} = await binFileUtils.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fd, sections);\n    const contrs = await utils.readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: utils.calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: blake2b.create({ dkLen: 64 }).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = blake2b.create({ dkLen: 64 });\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!misc.hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(misc.formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr, logger);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(misc.formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        utils.toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher =  misc.fromPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(misc.formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(misc.formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${misc.byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = misc.getRandomBytes(4*(n-1));\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = misc.readUInt32BE(misc.getRandomBytes(4), 0);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await binFileUtils.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = misc.readUInt32BE(misc.getRandomBytes(4), 0);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await binFileUtils.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await binFileUtils.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new BigBuffer(nPoints * n8r);\n\n            rng = new ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await binFileUtils.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await binFileUtils.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as keyPair from \"./keypair.js\";\nimport * as misc from \"./misc.js\";\nimport { getCurveFromQ } from \"./curves.js\";\n\nexport async function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nexport async function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = Scalar.fromRprLE(buff);\n\n    const curve = await getCurveFromQ(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nexport async function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nexport function fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nexport function toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nexport async function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher =  misc.fromPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nexport async function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nexport async function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nexport function calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = blake2b.create({ dkLen: 64 });\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(blake2b.create({ dkLen: 64 }).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nexport async function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = await misc.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = keyPair.createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compressed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compressed size\n\n    const fdResponse = await fastFile.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (misc.hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!misc.hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. This contribution is not based on the previous hash\");\n\n    const hasherResponse = blake2b.create({ dkLen: 64 });\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = misc.toPartialHash(hasherResponse);\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = utils.fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(misc.formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await binFileUtils.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await binFileUtils.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as fastFile from \"fastfile\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\n\nexport default async function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await zkeyUtils.readHeader(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await zkeyUtils.readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastFile.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nContributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!misc.hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previous contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new contributions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await zkeyUtils.writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await binFileUtils.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await binFileUtils.endWriteSection(fdZKeyNew);\n\n    // C Section (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await binFileUtils.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await binFileUtils.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await zkeyUtils.writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!misc.hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { readR1csFd } from \"r1csfile\";\nimport { Scalar } from \"ffjavascript\";\nimport * as curves from \"./curves.js\";\n\nexport default async function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await binFileUtils.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await binFileUtils.readBinFile(wtnsFilename, \"wtns\", 2, 1 << 22, 1 << 24);\n    const wtnsHeader = await wtnsUtils.readHeader(fdWtns, wtnsSections);\n\n    if (!Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await binFileUtils.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await curves.getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await binFileUtils.readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Outputs:        ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}","/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\nimport * as curves from \"./curves.js\";\nimport { utils }   from \"ffjavascript\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { Scalar } from \"ffjavascript\";\n\nconst { unstringifyBigInts } = utils;\n\nexport default async function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n    let publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await curves.getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    if (logger) logger.info(\"PLONK VERIFIER STARTED\");\n\n    let proof = fromObjectProof(curve,_proof);\n    vk_verifier = fromObjectVk(curve, vk_verifier);\n\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    if (publicSignals.length != vk_verifier.nPublic) {\n        if (logger) logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid\");\n        return false;\n    }\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    const challenges = calculatechallenges(curve, proof, publicSignals, vk_verifier);\n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challenges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challenges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challenges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challenges.xi, 16));\n        for(let i=1;i<6;i++) {\n            if (logger) logger.debug(\"v: \" + Fr.toString(challenges.v[i], 16));\n        }\n        logger.debug(\"u: \" + Fr.toString(challenges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challenges, vk_verifier);\n    if (logger) {\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));\n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pi = calculatePI(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"PI(xi): \" + Fr.toString(pi, 16));\n    }\n    \n    const r0 = calculateR0(curve, proof, challenges, pi, L[1]);\n    if (logger) {\n        logger.debug(\"r0: \" + Fr.toString(r0, 16));\n    }\n\n    const D = calculateD(curve, proof, challenges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challenges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challenges, r0);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing(curve, proof, challenges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return Scalar.geq(value, 0) && Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.eval_a)\n        && checkEvaluationIsValid(curve, proof.eval_b)\n        && checkEvaluationIsValid(curve, proof.eval_c)\n        && checkEvaluationIsValid(curve, proof.eval_s1)\n        && checkEvaluationIsValid(curve, proof.eval_s2)\n        && checkEvaluationIsValid(curve, proof.eval_zw);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction calculatechallenges(curve, proof, publicSignals, vk) {\n    const Fr = curve.Fr;\n    const res = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Challenge round 2: beta and gamma\n    transcript.addPolCommitment(vk.Qm);\n    transcript.addPolCommitment(vk.Ql);\n    transcript.addPolCommitment(vk.Qr);\n    transcript.addPolCommitment(vk.Qo);\n    transcript.addPolCommitment(vk.Qc);\n    transcript.addPolCommitment(vk.S1);\n    transcript.addPolCommitment(vk.S2);\n    transcript.addPolCommitment(vk.S3);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.A);\n    transcript.addPolCommitment(proof.B);\n    transcript.addPolCommitment(proof.C);\n\n    res.beta = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    res.gamma = transcript.getChallenge();\n\n    // Challenge round 3: alpha\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    transcript.addScalar(res.gamma);\n    transcript.addPolCommitment(proof.Z);\n    res.alpha = transcript.getChallenge();\n\n    // Challenge round 4: xi\n    transcript.reset();\n    transcript.addScalar(res.alpha);\n    transcript.addPolCommitment(proof.T1);\n    transcript.addPolCommitment(proof.T2);\n    transcript.addPolCommitment(proof.T3);\n    res.xi = transcript.getChallenge();\n    \n    // Challenge round 5: v\n    transcript.reset();\n    transcript.addScalar(res.xi);\n    transcript.addScalar(proof.eval_a);\n    transcript.addScalar(proof.eval_b);\n    transcript.addScalar(proof.eval_c);\n    transcript.addScalar(proof.eval_s1);\n    transcript.addScalar(proof.eval_s2);\n    transcript.addScalar(proof.eval_zw);\n    res.v = [];\n    res.v[1] = transcript.getChallenge();\n\n    for (let i=2; i<6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    // Challenge: u\n    transcript.reset();\n    transcript.addPolCommitment(proof.Wxi);\n    transcript.addPolCommitment(proof.Wxiw);\n    res.u = transcript.getChallenge();\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challenges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challenges.xin = xin;\n\n    challenges.zh = Fr.sub(xin, Fr.one);\n\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {        \n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, L[i+1]));\n    }\n    return pi;\n}\n\nfunction calculateR0(curve, proof, challenges, pi, l1) {\n    const Fr = curve.Fr;\n\n    const e1 = pi;\n\n    const e2 = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));\n    e3a = Fr.add(e3a, challenges.gamma);\n\n    let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));\n    e3b = Fr.add(e3b, challenges.gamma);\n\n    let e3c = Fr.add(proof.eval_c, challenges.gamma);\n\n    let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);\n    e3 = Fr.mul(e3, proof.eval_zw);\n    e3 = Fr.mul(e3, challenges.alpha);\n\n    const r0 = Fr.sub(Fr.sub(e1, e2), e3);\n\n    return r0;\n}\n\nfunction calculateD(curve, proof, challenges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    \n    let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));\n    d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));\n    d1 = G1.add(d1, vk.Qc);\n\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n\n    const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);\n    const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);\n    const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);\n\n    const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);\n\n    const d2b = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));\n\n    const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);\n    const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);\n    const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);\n\n    const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));\n    \n    const d4low = proof.T1;\n    const d4mid = G1.timesFr(proof.T2, challenges.xin);\n    const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));\n    let d4 = G1.add(d4low, G1.add(d4mid, d4high));\n    d4 = G1.timesFr(d4, challenges.zh);\n\n    const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);\n\n    return d;\n}\n\nfunction calculateF(curve, proof, challenges, vk, D) {\n    const G1 = curve.G1;\n\n    let res = G1.add(D, G1.timesFr(proof.A, challenges.v[1]));\n    res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));\n    res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));\n\n    return res;\n}\n\nfunction calculateE(curve, proof, challenges, r0) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let e = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));\n    e = Fr.add(e, Fr.mul(challenges.v[2], proof.eval_b));\n    e = Fr.add(e, Fr.mul(challenges.v[3], proof.eval_c));\n    e = Fr.add(e, Fr.mul(challenges.v[4], proof.eval_s1));\n    e = Fr.add(e, Fr.mul(challenges.v[5], proof.eval_s2));\n    e = Fr.add(e, Fr.mul(challenges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, e);\n\n    return res;\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challenges.xi);\n    const s = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n}\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    evaluate(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.evaluate(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    evaluate(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.evaluate(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n","/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nexport default class FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the points in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nexport async function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await binFileUtils.startReadUniqueSection(fdOld, sections,idSection );\n    await binFileUtils.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await binFileUtils.endWriteSection(fdNew);\n    await binFileUtils.endReadSection(fdOld);\n}\n\n\n\nexport async function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// CPolynomial is a Combined Polynomial of the type :\n// CPolynomial(X) := P_0(X^n) + XP_1(X^n) + ... + X^{n-1}P_{n-1}(X^n)\n// We can use this class to avoid the allocation of a big memory buffer\n// for the coefficients because in some cases a big number of the coefficients are zero\n\nimport {BigBuffer} from \"ffjavascript\";\nimport {log2} from \"../misc.js\";\nimport {Polynomial} from \"./polynomial.js\";\n\nexport class CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** (log2(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new Polynomial(new BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nimport { applyKeyToSection } from \"./mpc_applykey.js\";\n\nexport default async function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n\n    const {fd: fdOld, sections: sections} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await misc.getRandomRng(entropy);\n\n    const transcriptHasher = blake2b.create({ dkLen: 64 });\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        utils.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await zkeyUtils.writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await zkeyUtils.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });\n    utils.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(misc.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nimport { applyKeyToSection } from \"./mpc_applykey.js\";\n\n\nexport default async function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    const beaconHash = misc.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await getCurve(zkey.q);\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await misc.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = blake2b.create({ dkLen: 64 });;\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        utils.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await zkeyUtils.writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await zkeyUtils.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });;\n    utils.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (uncompressed)\n//      2^N TauG2 Points (uncompressed)\n//      2^N AlphaTauG1 Points (uncompressed)\n//      2^N BetaTauG1 Points (uncompressed)\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as keyPair from \"./keypair.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await misc.getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = keyPair.createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = misc.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1csHeader} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {\n    readBinFile,\n    createBinFile,\n    readSection,\n    writeBigInt,\n    startWriteSection,\n    endWriteSection,\n} from \"@iden3/binfileutils\";\nimport { log2, formatHash } from \"./misc.js\";\nimport { Scalar, BigBuffer } from \"ffjavascript\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport BigArray from \"./bigarray.js\";\n\n\nexport default async function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    const csHasher = blake2b.create({ dkLen: 64 });\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await utils.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await readR1csHeader(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = log2(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await startWriteSection(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await endWriteSection(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await startWriteSection(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = Scalar.mod(Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(Scalar.mod(Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await writeBigInt(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await writeBigInt(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const A = new BigArray(r1cs.nVars);\n    const B1 = new BigArray(r1cs.nVars);\n    const B2 = new BigArray(r1cs.nVars);\n    const C = new BigArray(r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await readSection(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await readSection(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await readSection(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await startWriteSection(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(formatHash(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await startWriteSection(fdZKey, 9);\n        const buffOut = new BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`splitting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await endWriteSection(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new BigArray();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await startWriteSection(fdZKey, 4);\n\n        const buffSection = new BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await endWriteSection(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await startWriteSection(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await endWriteSection(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new BigBuffer(acc*sGin);\n            bScalars = new BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\n\n","/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\nimport {readR1csFd} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {\n    readBinFile,\n    createBinFile,\n    readSection,\n    writeBigInt,\n    startWriteSection,\n    endWriteSection,\n} from \"@iden3/binfileutils\";\nimport { log2  } from \"./misc.js\";\nimport { Scalar, BigBuffer } from \"ffjavascript\";\nimport BigArray from \"./bigarray.js\";\n\n\nexport default async function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await utils.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new BigArray();\n    const plonkAdditions = new BigArray();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = log2(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polynomial is n+5 we need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await startWriteSection(fdZKey, 14);\n    const buffOut = new BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await endWriteSection(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                const val = Fr.neg(linearComb2[s]);\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = val;\n                } else {\n                    res[s] = Fr.add(res[s], val);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]])\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await startWriteSection(fdZKey, sectionNum);\n        await writeP4(Q);\n        await endWriteSection(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is stored in Montgomery. stored = v*R\n            // so when montgomery multiplied by the witness, it's result = v*R*w/R = v*w\n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new BigArray(plonkNVars);\n        const firstPos = new BigArray(plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await startWriteSection(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await endWriteSection(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await startWriteSection(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await endWriteSection(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await startWriteSection(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await writeBigInt(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await writeBigInt(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await endWriteSection(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as misc from \"./misc.js\";\nimport { applyKeyToChallengeSection } from \"./mpc_applykey.js\";\nimport * as keyPair from \"./keypair.js\";\n\nexport default async function challengeContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const fdFrom = await fastFile.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await misc.getRandomRng(entropy);\n\n    const fdTo = await fastFile.createOverride(responseFileName);\n\n    // Calculate the hash\n    const challengeHasher = blake2b.create({ dkLen: 64 });\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(misc.formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(misc.formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = keyPair.createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(misc.formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./zkey_utils.js\";\nimport * as misc from \"./misc.js\";\nimport { applyKeyToChallengeSection } from \"./mpc_applykey.js\";\nimport { hashPubKey } from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\n\nexport default async function bellmanContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const rng = await misc.getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastFile.readExisting(challengeFilename);\n    const fdTo = await fastFile.createOverride(responseFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = blake2b.create({ dkLen: 64 });;\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nContributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        hashPubKey(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write Contribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });;\n    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { BigBuffer, Scalar, utils } from \"ffjavascript\";\nimport { FFLONK_PROTOCOL_ID } from \"./zkey_constants.js\";\nimport {\n    ZKEY_FF_A_MAP_SECTION,\n    ZKEY_FF_ADDITIONS_SECTION,\n    ZKEY_FF_B_MAP_SECTION,\n    ZKEY_FF_C0_SECTION,\n    ZKEY_FF_C_MAP_SECTION,\n    ZKEY_FF_LAGRANGE_SECTION,\n    ZKEY_FF_PTAU_SECTION,\n    ZKEY_FF_QC_SECTION,\n    ZKEY_FF_QL_SECTION,\n    ZKEY_FF_QM_SECTION,\n    ZKEY_FF_QO_SECTION,\n    ZKEY_FF_QR_SECTION,\n    ZKEY_FF_SIGMA1_SECTION,\n    ZKEY_FF_SIGMA2_SECTION,\n    ZKEY_FF_SIGMA3_SECTION,\n} from \"./fflonk_constants.js\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { Proof } from \"./proof.js\";\nimport { Polynomial } from \"./polynomial/polynomial.js\";\nimport { Evaluations } from \"./polynomial/evaluations.js\";\nimport { CPolynomial } from \"./polynomial/cpolynomial.js\";\n\nconst { stringifyBigInts } = utils;\n\n\nexport default async function fflonkProve(zkeyFileName, witnessFileName, logger, options) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1 << 25, 1 << 23);\n    const wtns = await wtnsUtils.readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1 << 25, 1 << 23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, zkeySections, undefined, options);\n\n    if (zkey.protocolId !== FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new BigBuffer(sDomain);\n            buffers.B = new BigBuffer(sDomain);\n            buffers.C = new BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${ZKEY_FF_QL_SECTION}, ${ZKEY_FF_QR_SECTION}` +\n                `, ${ZKEY_FF_QM_SECTION}, ${ZKEY_FF_QO_SECTION}, ${ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new BigBuffer(sDomain);\n            let denArr = new BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new BigBuffer(sDomain * 2);\n            buffers.T1z = new BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new BigBuffer(sDomain * 4);\n            buffers.T2z = new BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new Polynomial(new BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve);\n\n        computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve);\n\n        computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve);\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            if(Array.isArray(element)) {\n                for (const subElement of element) {\n                    mulAccumulator = Fr.mul(mulAccumulator, subElement);\n                }\n            } else {\n                mulAccumulator = Fr.mul(mulAccumulator, element);\n            }\n        }\n        return Fr.inv(mulAccumulator);\n\n        \n        function computeLiS0(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS0_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n            }\n        \n            return Li;\n        }\n\n        function computeLiS1(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS1_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n\n            }\n        \n            return Li;\n        }\n\n        function computeLiS2(toInverse, S2, S2p, value, xi, xiw, curve) {\n            const Fr = curve.Fr;\n        \n            const Li = [];\n        \n            const _3h2 = Fr.mul(Fr.e(3), S2[0]);\n            const xisubxiw = Fr.sub(xi, xiw);\n            let den1 = Fr.mul(_3h2, xisubxiw);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2[2 * i % 3];\n                const den3 = Fr.sub(value, S2[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1)]] = Fr.mul(den1,Fr.mul(den2, den3));\n                \n            }\n        \n            const _3h3 = Fr.mul(Fr.e(3), S2p[0]);\n            const xiwsubxi = Fr.sub(xiw, xi);\n            den1 = Fr.mul(_3h3, xiwsubxi);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2p[2 * i % 3];\n                const den3 = Fr.sub(value, S2p[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1 + 3)]] = Fr.mul(den1,Fr.mul(den2, den3));    \n            }\n        \n            return Li;\n        }\n    }\n}\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format\n// ======\n// Header(1)\n//      Prover Type 1 Groth\n// HeaderGroth(2)\n//      n8q\n//      q\n//      n8r\n//      r\n//      NVars\n//      NPub\n//      DomainSize  (multiple of 2\n//      alpha1\n//      beta1\n//      delta1\n//      beta2\n//      gamma2\n//      delta2\n// IC(3)\n// Coefs(4)\n// PointsA(5)\n// PointsB1(6)\n// PointsB2(7)\n// PointsC(8)\n// PointsH(9)\n// Contributions(10)\n\nimport { Scalar, F1Field } from \"ffjavascript\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { log2 } from \"./misc.js\";\nimport {FFLONK_PROTOCOL_ID, GROTH16_PROTOCOL_ID, PLONK_PROTOCOL_ID} from \"./zkey_constants.js\";\nimport {ZKEY_FF_HEADER_SECTION} from \"./fflonk_constants.js\";\n\nexport async function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await binFileUtils.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await binFileUtils.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await getCurve(zkey.q);\n\n    await binFileUtils.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await binFileUtils.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await binFileUtils.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await binFileUtils.endWriteSection(fd);\n\n\n}\n\nexport async function writeZKey(fileName, zkey) {\n\n    let curve = getCurve(zkey.q);\n\n    const fd = await binFileUtils.createBinFile(fileName,\"zkey\", 1, 9);\n\n    await writeHeader(fd, zkey);\n    const n8r = (Math.floor( (Scalar.bitLength(zkey.r) - 1) / 64) +1)*8;\n    const Rr = Scalar.mod(Scalar.shl(1, n8r*8), zkey.r);\n    const R2r = Scalar.mod(Scalar.mul(Rr,Rr), zkey.r);\n\n    // Write Pols (A and B (C can be omitted))\n    ///////////\n\n    zkey.ccoefs = zkey.ccoefs.filter(c => c.matrix<2);\n    zkey.ccoefs.sort( (a,b) => a.constraint - b.constraint );\n    await binFileUtils.startWriteSection(fd, 4);\n    await fd.writeULE32(zkey.ccoefs.length);\n    for (let i=0; i<zkey.ccoefs.length; i++) {\n        const coef = zkey.ccoefs[i];\n        await fd.writeULE32(coef.matrix);\n        await fd.writeULE32(coef.constraint);\n        await fd.writeULE32(coef.signal);\n        await writeFr2(coef.value);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write IC Section\n    ///////////\n    await binFileUtils.startWriteSection(fd, 3);\n    for (let i=0; i<= zkey.nPublic; i++) {\n        await writeG1(fd, curve, zkey.IC[i] );\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write A\n    ///////////\n    await binFileUtils.startWriteSection(fd, 5);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.A[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write B1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 6);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.B1[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write B2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 7);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG2(fd, curve, zkey.B2[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write C\n    ///////////\n    await binFileUtils.startWriteSection(fd, 8);\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.C[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write H points\n    ///////////\n    await binFileUtils.startWriteSection(fd, 9);\n    for (let i=0; i<zkey.domainSize; i++) {\n        await writeG1(fd, curve, zkey.hExps[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    await fd.close();\n\n    async function writeFr2(n) {\n        // Convert to montgomery\n        n = Scalar.mod( Scalar.mul(n, R2r), zkey.r);\n\n        await binFileUtils.writeBigInt(fd, n, n8r);\n    }\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nexport async function readHeader(fd, sections, toObject, options) {\n    // Read Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await binFileUtils.endReadSection(fd);\n\n    if (protocolId === GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject, options);\n    } else if (protocolId === PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject, options);\n    } else if (protocolId === FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject, options);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n    zkey.curve = await getCurve(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n    zkey.curve = await getCurve(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = FFLONK_PROTOCOL_ID;\n\n    await binFileUtils.startReadUniqueSection(fd, sections, ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n    zkey.curve = await getCurve(zkey.q, options);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n}\n\nexport async function readZKey(fileName, toObject) {\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader(fd, sections, toObject);\n\n    const Fr = new F1Field(zkey.r);\n    const Rr = Scalar.mod(Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await getCurve(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2(toObject);\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await binFileUtils.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await binFileUtils.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n}\n\n\nexport async function readMPCParams(fd, curve, sections) {\n    await binFileUtils.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution(fd, curve);\n        res.contributions.push(c);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nexport async function writeMPCParams(fd, curve, mpcParams) {\n    await binFileUtils.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution(fd, curve,mpcParams.contributions[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n}\n\nexport function hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nexport function hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nexport function hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n","/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1csFd} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {createBinFile, endWriteSection, readBinFile, startWriteSection, writeBigInt,} from \"@iden3/binfileutils\";\nimport {log2} from \"./misc.js\";\nimport {BigBuffer, Scalar} from \"ffjavascript\";\nimport BigArray from \"./bigarray.js\";\nimport {\n    ZKEY_FF_HEADER_SECTION,\n    ZKEY_FF_ADDITIONS_SECTION,\n    ZKEY_FF_A_MAP_SECTION,\n    ZKEY_FF_B_MAP_SECTION,\n    ZKEY_FF_C_MAP_SECTION,\n    ZKEY_FF_QL_SECTION,\n    ZKEY_FF_QR_SECTION,\n    ZKEY_FF_QM_SECTION,\n    ZKEY_FF_QO_SECTION,\n    ZKEY_FF_QC_SECTION,\n    ZKEY_FF_SIGMA1_SECTION,\n    ZKEY_FF_SIGMA2_SECTION,\n    ZKEY_FF_SIGMA3_SECTION,\n    ZKEY_FF_LAGRANGE_SECTION,\n    ZKEY_FF_PTAU_SECTION,\n    FF_T_POL_DEG_MIN,\n    ZKEY_FF_NSECTIONS,\n    ZKEY_FF_C0_SECTION,\n} from \"./fflonk_constants.js\";\nimport {FFLONK_PROTOCOL_ID, HEADER_ZKEY_SECTION} from \"./zkey_constants.js\";\nimport {\n    getFFlonkAdditionConstraint,\n    getFFlonkConstantConstraint,\n    getFFlonkMultiplicationConstraint\n} from \"./plonk_equation.js\";\nimport {r1csConstraintProcessor} from \"./r1cs_constraint_processor.js\";\nimport {Polynomial} from \"./polynomial/polynomial.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport {Evaluations} from \"./polynomial/evaluations.js\";\nimport {CPolynomial} from \"./polynomial/cpolynomial.js\";\n\n\nexport default async function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await readBinFile(ptauFilename, \"ptau\", 1, 1 << 22, 1 << 24);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await utils.readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new BigArray();\n    let plonkAdditions = new BigArray();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 we need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(FF_T_POL_DEG_MIN, log2((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push(getFFlonkConstantConstraint(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new r1csConstraintProcessor(Fr, getFFlonkConstantConstraint, getFFlonkAdditionConstraint, getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await binFileUtils.readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await createBinFile(zkeyFilename, \"zkey\", 1, ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await startWriteSection(fdZKey, HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(FFLONK_PROTOCOL_ID);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await startWriteSection(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new BigArray(settings.nVars);\n        const firstPos = new BigArray(settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? ZKEY_FF_SIGMA1_SECTION : 1 === i ? ZKEY_FF_SIGMA2_SECTION : ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await startWriteSection(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await endWriteSection(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await startWriteSection(fdZKey, ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await writeBigInt(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await writeBigInt(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = Scalar.div(orderRsub1, Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n\n","/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\nHeader(1)\n    n8\n    prime\n    power\ntauG1(2)\n    {(2 ** power)*2-1} [\n        G1, tau*G1, tau^2 * G1, ....\n    ]\ntauG2(3)\n    {2 ** power}[\n        G2, tau*G2, tau^2 * G2, ...\n    ]\nalphaTauG1(4)\n    {2 ** power}[\n        alpha*G1, alpha*tau*G1, alpha*tau^2*G1,....\n    ]\nbetaTauG1(5)\n    {2 ** power} []\n        beta*G1, beta*tau*G1, beta*tau^2*G1, ....\n    ]\nbetaG2(6)\n    {1}[\n        beta*G2\n    ]\ncontributions(7)\n    NContributions\n    {NContributions}[\n        tau*G1\n        tau*G2\n        alpha*G1\n        beta*G1\n        beta*G2\n        pubKey\n            tau_g1s\n            tau_g1sx\n            tau_g2spx\n            alpha_g1s\n            alpha_g1sx\n            alpha_g1spx\n            beta_g1s\n            beta_g1sx\n            beta_g1spx\n        partialHash (216 bytes) See https://github.com/mafintosh/blake2b-wasm/blob/23bee06945806309977af802bc374727542617c7/blake2b.wat#L9\n        hashNewChallenge\n    ]\n */\n\nimport * as ptauUtils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as misc from \"./misc.js\";\n\nexport default async function newAccumulator(curve, power, fileName, logger) {\n\n    const fd = await binFileUtils.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await ptauUtils.writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await binFileUtils.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await binFileUtils.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await binFileUtils.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = ptauUtils.calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(misc.formatHash(blake2b.create({ dkLen: 64 }).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(misc.formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172]}