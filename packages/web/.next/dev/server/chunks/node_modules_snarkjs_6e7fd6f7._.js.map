{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/curves.js"],"sourcesContent":["import { Scalar, buildBn128, buildBls12381} from \"ffjavascript\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nexport async function getCurveFromR(r, options) {\n    let curve;\n    // check that options param is defined and that options.singleThread is defined\n    let singleThread = options && options.singleThread;\n    if (Scalar.eq(r, bn128r)) {\n        curve = await buildBn128(singleThread);\n    } else if (Scalar.eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromQ(q, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    if (Scalar.eq(q, bn128q)) {\n        curve = await buildBn128(singleThread);\n    } else if (Scalar.eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nexport async function getCurveFromName(name, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;;AAEA,MAAM,YAAY,gKAAM,CAAC,CAAC,CAAC,oEAAoE;AAC/F,MAAM,SAAS,gKAAM,CAAC,CAAC,CAAC;AAExB,MAAM,YAAY,gKAAM,CAAC,CAAC,CAAC,oGAAoG;AAC/H,MAAM,SAAS,gKAAM,CAAC,CAAC,CAAC;AAEjB,eAAe,cAAc,CAAC,EAAE,OAAO;IAC1C,IAAI;IACJ,+EAA+E;IAC/E,IAAI,eAAe,WAAW,QAAQ,YAAY;IAClD,IAAI,gKAAM,CAAC,EAAE,CAAC,GAAG,SAAS;QACtB,QAAQ,MAAM,IAAA,qMAAU,EAAC;IAC7B,OAAO,IAAI,gKAAM,CAAC,EAAE,CAAC,GAAG,YAAY;QAChC,QAAQ,MAAM,IAAA,8MAAa,EAAC;IAChC,OAAO;QACH,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,gKAAM,CAAC,QAAQ,CAAC,IAAI;IAChE;IACA,OAAO;AACX;AAEO,eAAe,cAAc,CAAC,EAAE,OAAO;IAC1C,IAAI;IACJ,IAAI,eAAe,WAAW,QAAQ,YAAY;IAClD,IAAI,gKAAM,CAAC,EAAE,CAAC,GAAG,SAAS;QACtB,QAAQ,MAAM,IAAA,qMAAU,EAAC;IAC7B,OAAO,IAAI,gKAAM,CAAC,EAAE,CAAC,GAAG,YAAY;QAChC,QAAQ,MAAM,IAAA,8MAAa,EAAC;IAChC,OAAO;QACH,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,gKAAM,CAAC,QAAQ,CAAC,IAAI;IAChE;IACA,OAAO;AACX;AAEO,eAAe,iBAAiB,IAAI,EAAE,OAAO;IAChD,IAAI;IACJ,IAAI,eAAe,WAAW,QAAQ,YAAY;IAClD,MAAM,WAAW,cAAc;IAC/B,IAAI;QAAC;QAAS;QAAS;KAAW,CAAC,OAAO,CAAC,aAAa,GAAG;QACvD,QAAQ,MAAM,IAAA,qMAAU,EAAC;IAC7B,OAAO,IAAI;QAAC;KAAW,CAAC,OAAO,CAAC,aAAa,GAAG;QAC5C,QAAQ,MAAM,IAAA,8MAAa,EAAC;IAChC,OAAO;QACH,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,MAAM;IAClD;IACA,OAAO;;;IAEP,SAAS,cAAc,CAAC;QACpB,OAAO,EAAE,WAAW,GAAG,KAAK,CAAC,iBAAiB,IAAI,CAAC;IACvD;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/misc.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* global window */\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { u32 } from \"@noble/hashes/utils\";\nimport readline from \"readline\";\nimport { ChaCha } from \"ffjavascript\";\nimport crypto from \"crypto\";\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nexport function bitReverse(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\n\nexport function log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nexport function formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nexport function hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nexport function cloneHasher(h) {\n    return h.clone();\n}\n\nexport function fromPartialHash(partial) {\n    // NOTE: this is unsafe and uses internal API\n    const buf = partial.subarray(0, 128);\n    const rest = u32(partial.subarray(128));\n    const res = blake2b.create({ dkLen: 64 });\n    res.buffer.set(buf);\n    (res.v0l = rest[0] | 0), (res.v0h = rest[1] | 0);\n    (res.v1l = rest[2] | 0), (res.v1h = rest[3] | 0);\n    (res.v2l = rest[4] | 0), (res.v2h = rest[5] | 0);\n    (res.v3l = rest[6] | 0), (res.v3h = rest[7] | 0);\n    (res.v4l = rest[8] | 0), (res.v4h = rest[9] | 0);\n    (res.v5l = rest[10] | 0), (res.v5h = rest[11] | 0);\n    (res.v6l = rest[12] | 0), (res.v6h = rest[13] | 0);\n    (res.v7l = rest[14] | 0), (res.v7h = rest[15] | 0);\n    const shift = 2 ** 32;\n    const len = rest[16] + rest[17] * shift;\n    const pos = rest[18] + rest[19] * shift;\n    res.length = len + pos;\n    res.pos = pos;\n    return res;\n}\n\nexport function toPartialHash(hash){\n    // NOTE: this is unsafe and uses internal API\n    const res = new Uint8Array(216);\n    const res32 = u32(res.subarray(128));\n    res.set(hash.buffer);\n    (res32[0] = hash.v0l), (res32[1] = hash.v0h);\n    (res32[2] = hash.v1l), (res32[3] = hash.v1h);\n    (res32[4] = hash.v2l), (res32[5] = hash.v2h);\n    (res32[6] = hash.v3l), (res32[7] = hash.v3h);\n    (res32[8] = hash.v4l), (res32[9] = hash.v4h);\n    (res32[10] = hash.v5l), (res32[11] = hash.v5h);\n    (res32[12] = hash.v6l), (res32[13] = hash.v6h);\n    (res32[14] = hash.v7l), (res32[15] = hash.v7h);\n    res32[18] = hash.pos;\n    res32[16] = hash.length-hash.pos;\n    return res;\n}\n\nexport async function sameRatio(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nexport function askEntropy() {\n    if (process.browser) {\n        return window.prompt(\"Enter a random text. (Entropy): \", \"\");\n    } else {\n        const rl = readline.createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nexport function getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (process.browser) { // Supported\n        globalThis.crypto.getRandomValues(array);\n    } else { // NodeJS\n        crypto.randomFillSync(array);\n    }\n    return array;\n}\n\nexport async function sha256digest(data) {\n    if (process.browser) { // Supported\n        const buffer = await globalThis.crypto.subtle.digest(\"SHA-256\", data.buffer);\n        return new Uint8Array(buffer);\n    } else { // NodeJS\n        return crypto.createHash(\"sha256\").update(data).digest();\n    }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n */\nexport function readUInt32BE(data, offset) {\n    return new DataView(data.buffer).getUint32(offset, false);\n}\n\nexport async function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = blake2b.create(64);\n    hasher.update(getRandomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = hasher.digest();\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = readUInt32BE(hash, i*4);\n    }\n    const rng = new ChaCha(seed);\n    return rng;\n}\n\nexport async function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = await sha256digest(curHash);\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ChaCha(seed);\n\n    return rng;\n}\n\nexport function hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nexport function byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nexport function stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 339, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_constants.js"],"sourcesContent":["export const HEADER_ZKEY_SECTION = 1;\n\nexport const GROTH16_PROTOCOL_ID = 1;\nexport const PLONK_PROTOCOL_ID = 2;\nexport const FFLONK_PROTOCOL_ID = 10;\n"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,sBAAsB;AAE5B,MAAM,sBAAsB;AAC5B,MAAM,oBAAoB;AAC1B,MAAM,qBAAqB","ignoreList":[0]}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk_constants.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nexport const FF_T_POL_DEG_MIN = 3;\n\n// FFlonk A\nexport const A = 12;\n\n// ZKEY constants\nexport const ZKEY_FF_NSECTIONS = 17;\n\nexport const ZKEY_FF_HEADER_SECTION = 2;\nexport const ZKEY_FF_ADDITIONS_SECTION = 3;\nexport const ZKEY_FF_A_MAP_SECTION = 4;\nexport const ZKEY_FF_B_MAP_SECTION = 5;\nexport const ZKEY_FF_C_MAP_SECTION = 6;\nexport const ZKEY_FF_QL_SECTION = 7;\nexport const ZKEY_FF_QR_SECTION = 8;\nexport const ZKEY_FF_QM_SECTION = 9;\nexport const ZKEY_FF_QO_SECTION = 10;\nexport const ZKEY_FF_QC_SECTION = 11;\nexport const ZKEY_FF_SIGMA1_SECTION = 12;\nexport const ZKEY_FF_SIGMA2_SECTION = 13;\nexport const ZKEY_FF_SIGMA3_SECTION = 14;\nexport const ZKEY_FF_LAGRANGE_SECTION = 15;\nexport const ZKEY_FF_PTAU_SECTION = 16;\nexport const ZKEY_FF_C0_SECTION = 17;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA,mBAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACZ,MAAM,mBAAmB;AAGzB,MAAM,IAAI;AAGV,MAAM,oBAAoB;AAE1B,MAAM,yBAAyB;AAC/B,MAAM,4BAA4B;AAClC,MAAM,wBAAwB;AAC9B,MAAM,wBAAwB;AAC9B,MAAM,wBAAwB;AAC9B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,2BAA2B;AACjC,MAAM,uBAAuB;AAC7B,MAAM,qBAAqB","ignoreList":[0]}},
    {"offset": {"line": 438, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_utils.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format\n// ======\n// Header(1)\n//      Prover Type 1 Groth\n// HeaderGroth(2)\n//      n8q\n//      q\n//      n8r\n//      r\n//      NVars\n//      NPub\n//      DomainSize  (multiple of 2\n//      alpha1\n//      beta1\n//      delta1\n//      beta2\n//      gamma2\n//      delta2\n// IC(3)\n// Coefs(4)\n// PointsA(5)\n// PointsB1(6)\n// PointsB2(7)\n// PointsC(8)\n// PointsH(9)\n// Contributions(10)\n\nimport { Scalar, F1Field } from \"ffjavascript\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { log2 } from \"./misc.js\";\nimport {FFLONK_PROTOCOL_ID, GROTH16_PROTOCOL_ID, PLONK_PROTOCOL_ID} from \"./zkey_constants.js\";\nimport {ZKEY_FF_HEADER_SECTION} from \"./fflonk_constants.js\";\n\nexport async function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await binFileUtils.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await binFileUtils.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await getCurve(zkey.q);\n\n    await binFileUtils.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await binFileUtils.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await binFileUtils.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await binFileUtils.endWriteSection(fd);\n\n\n}\n\nexport async function writeZKey(fileName, zkey) {\n\n    let curve = getCurve(zkey.q);\n\n    const fd = await binFileUtils.createBinFile(fileName,\"zkey\", 1, 9);\n\n    await writeHeader(fd, zkey);\n    const n8r = (Math.floor( (Scalar.bitLength(zkey.r) - 1) / 64) +1)*8;\n    const Rr = Scalar.mod(Scalar.shl(1, n8r*8), zkey.r);\n    const R2r = Scalar.mod(Scalar.mul(Rr,Rr), zkey.r);\n\n    // Write Pols (A and B (C can be omitted))\n    ///////////\n\n    zkey.ccoefs = zkey.ccoefs.filter(c => c.matrix<2);\n    zkey.ccoefs.sort( (a,b) => a.constraint - b.constraint );\n    await binFileUtils.startWriteSection(fd, 4);\n    await fd.writeULE32(zkey.ccoefs.length);\n    for (let i=0; i<zkey.ccoefs.length; i++) {\n        const coef = zkey.ccoefs[i];\n        await fd.writeULE32(coef.matrix);\n        await fd.writeULE32(coef.constraint);\n        await fd.writeULE32(coef.signal);\n        await writeFr2(coef.value);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write IC Section\n    ///////////\n    await binFileUtils.startWriteSection(fd, 3);\n    for (let i=0; i<= zkey.nPublic; i++) {\n        await writeG1(fd, curve, zkey.IC[i] );\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write A\n    ///////////\n    await binFileUtils.startWriteSection(fd, 5);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.A[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write B1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 6);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.B1[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write B2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 7);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG2(fd, curve, zkey.B2[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write C\n    ///////////\n    await binFileUtils.startWriteSection(fd, 8);\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.C[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n\n    // Write H points\n    ///////////\n    await binFileUtils.startWriteSection(fd, 9);\n    for (let i=0; i<zkey.domainSize; i++) {\n        await writeG1(fd, curve, zkey.hExps[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    await fd.close();\n\n    async function writeFr2(n) {\n        // Convert to montgomery\n        n = Scalar.mod( Scalar.mul(n, R2r), zkey.r);\n\n        await binFileUtils.writeBigInt(fd, n, n8r);\n    }\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nexport async function readHeader(fd, sections, toObject, options) {\n    // Read Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await binFileUtils.endReadSection(fd);\n\n    if (protocolId === GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject, options);\n    } else if (protocolId === PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject, options);\n    } else if (protocolId === FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject, options);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n    zkey.curve = await getCurve(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n    zkey.curve = await getCurve(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = FFLONK_PROTOCOL_ID;\n\n    await binFileUtils.startReadUniqueSection(fd, sections, ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await binFileUtils.readBigInt(fd, n8q);\n    zkey.curve = await getCurve(zkey.q, options);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await binFileUtils.readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await binFileUtils.endReadSection(fd);\n\n    return zkey;\n}\n\nexport async function readZKey(fileName, toObject) {\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader(fd, sections, toObject);\n\n    const Fr = new F1Field(zkey.r);\n    const Rr = Scalar.mod(Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await getCurve(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2(toObject);\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await binFileUtils.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await binFileUtils.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await binFileUtils.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n}\n\n\nexport async function readMPCParams(fd, curve, sections) {\n    await binFileUtils.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution(fd, curve);\n        res.contributions.push(c);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nexport async function writeMPCParams(fd, curve, mpcParams) {\n    await binFileUtils.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution(fd, curve,mpcParams.contributions[i]);\n    }\n    await binFileUtils.endWriteSection(fd);\n}\n\nexport function hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nexport function hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nexport function hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 935, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/wtns_utils.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\n\nexport async function write(fd, witness, prime) {\n\n    await binFileUtils.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await binFileUtils.endWriteSection(fd);\n\n    await binFileUtils.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await binFileUtils.writeBigInt(fd, witness[i], n8);\n    }\n    await binFileUtils.endWriteSection(fd, 2);\n\n\n}\n\nexport async function writeBin(fd, witnessBin, prime) {\n\n    await binFileUtils.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await binFileUtils.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await binFileUtils.endWriteSection(fd);\n\n\n    await binFileUtils.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await binFileUtils.endWriteSection(fd);\n\n}\n\nexport async function readHeader(fd, sections) {\n\n    await binFileUtils.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await binFileUtils.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await binFileUtils.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nexport async function read(fileName) {\n\n    const {fd, sections} = await binFileUtils.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await binFileUtils.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await binFileUtils.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AAEA;;;AAGO,eAAe,MAAM,EAAE,EAAE,OAAO,EAAE,KAAK;IAE1C,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,KAAK,CAAC,KAAK,KAAK,CAAE,CAAC,gKAAM,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,MAAK,CAAC,IAAE;IAChE,MAAM,GAAG,UAAU,CAAC;IACpB,MAAM,+KAAwB,CAAC,IAAI,OAAO;IAC1C,MAAM,GAAG,UAAU,CAAC,QAAQ,MAAM;IAClC,MAAM,mLAA4B,CAAC;IAEnC,MAAM,qLAA8B,CAAC,IAAI;IACzC,IAAK,IAAI,IAAE,GAAG,IAAE,QAAQ,MAAM,EAAE,IAAK;QACjC,MAAM,+KAAwB,CAAC,IAAI,OAAO,CAAC,EAAE,EAAE;IACnD;IACA,MAAM,mLAA4B,CAAC,IAAI;AAG3C;AAEO,eAAe,SAAS,EAAE,EAAE,UAAU,EAAE,KAAK;IAEhD,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,KAAK,CAAC,KAAK,KAAK,CAAE,CAAC,gKAAM,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,MAAK,CAAC,IAAE;IAChE,MAAM,GAAG,UAAU,CAAC;IACpB,MAAM,+KAAwB,CAAC,IAAI,OAAO;IAC1C,IAAI,WAAW,UAAU,GAAG,MAAM,GAAG;QACjC,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,GAAG,UAAU,CAAC,WAAW,UAAU,GAAG;IAC5C,MAAM,mLAA4B,CAAC;IAGnC,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,GAAG,KAAK,CAAC;IACf,MAAM,mLAA4B,CAAC;AAEvC;AAEO,eAAe,WAAW,EAAE,EAAE,QAAQ;IAEzC,MAAM,0LAAmC,CAAC,IAAI,UAAU;IACxD,MAAM,KAAK,MAAM,GAAG,SAAS;IAC7B,MAAM,IAAI,MAAM,8KAAuB,CAAC,IAAI;IAC5C,MAAM,WAAW,MAAM,GAAG,SAAS;IACnC,MAAM,kLAA2B,CAAC;IAElC,OAAO;QAAC;QAAI;QAAG;IAAQ;AAE3B;AAEO,eAAe,KAAK,QAAQ;IAE/B,MAAM,EAAC,EAAE,EAAE,QAAQ,EAAC,GAAG,MAAM,+KAAwB,CAAC,UAAU,QAAQ;IAExE,MAAM,EAAC,EAAE,EAAE,QAAQ,EAAC,GAAG,MAAM,WAAW,IAAI;IAE5C,MAAM,0LAAmC,CAAC,IAAI,UAAU;IACxD,MAAM,MAAM,EAAE;IACd,IAAK,IAAI,IAAE,GAAG,IAAE,UAAU,IAAK;QAC3B,MAAM,IAAI,MAAM,8KAAuB,CAAC,IAAI;QAC5C,IAAI,IAAI,CAAC;IACb;IACA,MAAM,kLAA2B,CAAC;IAElC,MAAM,GAAG,KAAK;IAEd,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1022, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/groth16_prove.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { log2 } from \"./misc.js\";\nimport { Scalar, utils, BigBuffer } from \"ffjavascript\";\nconst {stringifyBigInts} = utils;\n\nexport default async function groth16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey, undefined, options);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = log2(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await binFileUtils.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await binFileUtils.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await binFileUtils.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await binFileUtils.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buildABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof BigBuffer) {\n        outBuff = new BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1395, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/wtns_calculate.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { WitnessCalculatorBuilder } from \"circom_runtime\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nexport default async function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastFile.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await WitnessCalculatorBuilder(wasm, options);\n    if (wc.circom_version() === 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await binFileUtils.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await wtnsUtils.writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastFile.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AAAA;AACA;AACA;AACA;;;;;;AACA,MAAM,EAAE,kBAAkB,EAAC,GAAG,+JAAK;AAEpB,eAAe,cAAc,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,OAAO;IACnF,MAAM,QAAQ,mBAAmB;IAEjC,MAAM,SAAS,MAAM,6JAAqB,CAAC;IAC3C,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,OAAO,SAAS;IAC/C,MAAM,OAAO,KAAK;IAElB,MAAM,KAAK,MAAM,IAAA,+OAAwB,EAAC,MAAM;IAChD,IAAI,GAAG,cAAc,OAAO,GAAG;QAC3B,MAAM,IAAI,MAAM,GAAG,mBAAmB,CAAC;QAEvC,MAAM,SAAS,MAAM,iLAA0B,CAAC,cAAc,QAAQ,GAAG;QAEzE,MAAM,0JAAkB,CAAC,QAAQ,GAAG,GAAG,KAAK;QAC5C,MAAM,OAAO,KAAK;IACtB,OAAO;QACH,MAAM,SAAS,MAAM,+JAAuB,CAAC;QAE7C,MAAM,IAAI,MAAM,GAAG,gBAAgB,CAAC;QAEpC,MAAM,OAAO,KAAK,CAAC;QACnB,MAAM,OAAO,KAAK;IACtB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1450, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/groth16_fullprove.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport groth16_prove from \"./groth16_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function groth16FullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtns_calculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await groth16_prove(zkeyFileName, wtns, logger, proverOptions);\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;;;;AACA,MAAM,EAAC,kBAAkB,EAAC,GAAG,+JAAK;AAEnB,eAAe,iBAAiB,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,EAAE,eAAe,EAAE,aAAa;IACjH,MAAM,QAAQ,mBAAmB;IAEjC,MAAM,OAAM;QACR,MAAM;IACV;IACA,MAAM,IAAA,6JAAc,EAAC,OAAO,UAAU,MAAM;IAC5C,OAAO,MAAM,IAAA,4JAAa,EAAC,cAAc,MAAM,QAAQ;AAC3D","ignoreList":[0]}},
    {"offset": {"line": 1490, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/groth16_verify.js"],"sourcesContent":["/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */\nimport { Scalar } from \"ffjavascript\";\nimport * as curves from \"./curves.js\";\nimport {  utils }   from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts(_vk_verifier);\n    const proof = unstringifyBigInts(_proof);\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await curves.getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    if (!isWellConstructed(curve, {pi_a, pi_b, pi_c})) {\n        if(logger) logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    return G1.isValid(proof.pi_a)\n        && G2.isValid(proof.pi_b)\n        && G1.isValid(proof.pi_c);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return Scalar.geq(value, 0) && Scalar.lt(value, curve.r);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1584, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/groth16_exportsoliditycalldata.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nexport default async function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GACA;;AACA,MAAM,EAAE,kBAAkB,EAAC,GAAG,+JAAK;AAEnC,SAAS,KAAK,CAAC;IACX,IAAI,OAAO,EAAE,QAAQ,CAAC;IACtB,MAAO,KAAK,MAAM,GAAG,GAAI,OAAO,MAAI;IACpC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACpB,OAAO;AACX;AAEe,eAAe,8BAA8B,MAAM,EAAE,IAAI;IACpE,MAAM,QAAQ,mBAAmB;IACjC,MAAM,MAAM,mBAAmB;IAE/B,IAAI,SAAS;IACb,IAAK,IAAI,IAAE,GAAG,IAAE,IAAI,MAAM,EAAE,IAAK;QAC7B,IAAI,UAAU,IAAI,SAAS,SAAS;QACpC,SAAS,SAAS,KAAK,GAAG,CAAC,EAAE;IACjC;IAEA,IAAI;IACJ,IAAE,CAAC,CAAC,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,GACjD,CAAC,EAAE,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,GAClH,CAAC,CAAC,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,GACnD,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;IAEjB,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1630, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/groth16.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as fullProve} from \"./groth16_fullprove.js\";\nexport {default as prove} from \"./groth16_prove.js\";\nexport {default as verify} from \"./groth16_verify.js\";\nexport {default as exportSolidityCallData} from \"./groth16_exportsoliditycalldata.js\";\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 1660, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/keypair.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\n\nimport { ChaCha } from \"ffjavascript\";\n\nexport function hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nexport function getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = blake2b.create({ dkLen: 64 });\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nexport function createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\nexport function createDeltaKey(curve, transcript, rng) {\n    const delta = {};\n    delta.prvKey = curve.Fr.fromRng(rng);\n    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));\n    delta.g2_sp = hashToG2(curve, transcript);\n    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));\n    return delta;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AAEA;AAAA;;;AAEO,SAAS,SAAS,KAAK,EAAE,IAAI;IAChC,MAAM,QAAQ,IAAI,SAAS,KAAK,MAAM,EAAE,KAAK,UAAU,EAAE,KAAK,UAAU;IACxE,MAAM,OAAO,EAAE;IACf,IAAK,IAAI,IAAE,GAAG,IAAE,GAAG,IAAK;QACpB,IAAI,CAAC,EAAE,GAAG,MAAM,SAAS,CAAC,IAAE;IAChC;IAEA,MAAM,MAAM,IAAI,8LAAM,CAAC;IAEvB,MAAM,QAAQ,MAAM,EAAE,CAAC,OAAO,CAAC;IAE/B,OAAO;AACX;AAEO,SAAS,QAAQ,KAAK,EAAE,eAAe,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI;IAEhE,MAAM,IAAI,2LAAO,CAAC,MAAM,CAAC;QAAE,OAAO;IAAG;IACrC,MAAM,KAAK,IAAI,WAAW;QAAC;KAAgB;IAC3C,EAAE,MAAM,CAAC;IACT,EAAE,MAAM,CAAC;IACT,MAAM,KAAK,MAAM,EAAE,CAAC,cAAc,CAAC;IACnC,EAAE,MAAM,CAAE;IACV,MAAM,KAAK,MAAM,EAAE,CAAC,cAAc,CAAC;IACnC,EAAE,MAAM,CAAE;IACV,MAAM,OAAM,EAAE,MAAM;IAEpB,OAAO,SAAS,OAAO;AAC3B;AAEA,SAAS,gBAAgB,CAAC,EAAE,KAAK,EAAE,eAAe,EAAE,aAAa,EAAE,GAAG;IAClE,EAAE,IAAI,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC;IAC5C,EAAE,KAAK,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,EAAE,MAAM;IAC7D,EAAE,KAAK,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,QAAQ,OAAO,iBAAiB,eAAe,EAAE,IAAI,EAAE,EAAE,KAAK;IAC1F,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC,EAAE,KAAK,EAAE,EAAE,MAAM;IAC/D,OAAO;AACX;AAEO,SAAS,cAAc,KAAK,EAAE,aAAa,EAAE,GAAG;IACnD,MAAM,MAAM;QACR,KAAK,CAAC;QACN,OAAO,CAAC;QACR,MAAM,CAAC;IACX;IACA,IAAI,GAAG,CAAC,MAAM,GAAG,MAAM,EAAE,CAAC,OAAO,CAAC;IAClC,IAAI,KAAK,CAAC,MAAM,GAAG,MAAM,EAAE,CAAC,OAAO,CAAC;IACpC,IAAI,IAAI,CAAC,MAAM,GAAG,MAAM,EAAE,CAAC,OAAO,CAAC;IACnC,gBAAgB,IAAI,GAAG,EAAE,OAAO,GAAG,eAAe;IAClD,gBAAgB,IAAI,KAAK,EAAE,OAAO,GAAG,eAAe;IACpD,gBAAgB,IAAI,IAAI,EAAE,OAAO,GAAG,eAAe;IACnD,OAAO;AACX;AAEO,SAAS,eAAe,KAAK,EAAE,UAAU,EAAE,GAAG;IACjD,MAAM,QAAQ,CAAC;IACf,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,OAAO,CAAC;IAChC,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC;IAChD,MAAM,KAAK,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,WAAW,CAAC,MAAM,IAAI,EAAE,MAAM,MAAM;IAC7E,MAAM,KAAK,GAAG,SAAS,OAAO;IAC9B,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,WAAW,CAAC,MAAM,KAAK,EAAE,MAAM,MAAM;IAC/E,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_utils.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as keyPair from \"./keypair.js\";\nimport * as misc from \"./misc.js\";\nimport { getCurveFromQ } from \"./curves.js\";\n\nexport async function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nexport async function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = Scalar.fromRprLE(buff);\n\n    const curve = await getCurveFromQ(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nexport async function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nexport function fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nexport function toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nexport async function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher =  misc.fromPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nexport async function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nexport async function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nexport function calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = blake2b.create({ dkLen: 64 });\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(blake2b.create({ dkLen: 64 }).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nexport async function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = await misc.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = keyPair.createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2093, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_new.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\nHeader(1)\n    n8\n    prime\n    power\ntauG1(2)\n    {(2 ** power)*2-1} [\n        G1, tau*G1, tau^2 * G1, ....\n    ]\ntauG2(3)\n    {2 ** power}[\n        G2, tau*G2, tau^2 * G2, ...\n    ]\nalphaTauG1(4)\n    {2 ** power}[\n        alpha*G1, alpha*tau*G1, alpha*tau^2*G1,....\n    ]\nbetaTauG1(5)\n    {2 ** power} []\n        beta*G1, beta*tau*G1, beta*tau^2*G1, ....\n    ]\nbetaG2(6)\n    {1}[\n        beta*G2\n    ]\ncontributions(7)\n    NContributions\n    {NContributions}[\n        tau*G1\n        tau*G2\n        alpha*G1\n        beta*G1\n        beta*G2\n        pubKey\n            tau_g1s\n            tau_g1sx\n            tau_g2spx\n            alpha_g1s\n            alpha_g1sx\n            alpha_g1spx\n            beta_g1s\n            beta_g1sx\n            beta_g1spx\n        partialHash (216 bytes) See https://github.com/mafintosh/blake2b-wasm/blob/23bee06945806309977af802bc374727542617c7/blake2b.wat#L9\n        hashNewChallenge\n    ]\n */\n\nimport * as ptauUtils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as misc from \"./misc.js\";\n\nexport default async function newAccumulator(curve, power, fileName, logger) {\n\n    const fd = await binFileUtils.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await ptauUtils.writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await binFileUtils.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await binFileUtils.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await binFileUtils.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await binFileUtils.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await binFileUtils.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await binFileUtils.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = ptauUtils.calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(misc.formatHash(blake2b.create({ dkLen: 64 }).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(misc.formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8CC,GAED;AACA;AACA;AACA;;;;;AAEe,eAAe,eAAe,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM;IAEvE,MAAM,KAAK,MAAM,iLAA0B,CAAC,UAAU,QAAQ,GAAG;IAEjE,MAAM,wKAAyB,CAAC,IAAI,OAAO,OAAO;IAElD,MAAM,SAAS,MAAM,EAAE,CAAC,SAAS;IACjC,MAAM,SAAS,MAAM,EAAE,CAAC,SAAS;IAEjC,cAAc;IACd,WAAW;IACX,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,SAAS,AAAC,KAAK,QAAS,IAAG;IACjC,IAAK,IAAI,IAAE,GAAG,IAAG,QAAQ,IAAK;QAC1B,MAAM,GAAG,KAAK,CAAC;QACf,IAAI,AAAC,UAAU,AAAC,IAAE,UAAW,KAAI,GAAG,OAAO,GAAG,CAAC,YAAY;IAC/D;IACA,MAAM,mLAA4B,CAAC;IAEnC,cAAc;IACd,WAAW;IACX,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,SAAU,KAAK;IACrB,IAAK,IAAI,IAAE,GAAG,IAAG,QAAQ,IAAK;QAC1B,MAAM,GAAG,KAAK,CAAC;QACf,IAAI,AAAC,UAAU,AAAC,IAAE,UAAW,KAAI,GAAG,OAAO,GAAG,CAAC,YAAY;IAC/D;IACA,MAAM,mLAA4B,CAAC;IAEnC,mBAAmB;IACnB,WAAW;IACX,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,aAAc,KAAK;IACzB,IAAK,IAAI,IAAE,GAAG,IAAG,YAAY,IAAK;QAC9B,MAAM,GAAG,KAAK,CAAC;QACf,IAAI,AAAC,UAAU,AAAC,IAAE,UAAW,KAAI,GAAG,OAAO,GAAG,CAAC,iBAAiB;IACpE;IACA,MAAM,mLAA4B,CAAC;IAEnC,kBAAkB;IAClB,WAAW;IACX,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,aAAc,KAAK;IACzB,IAAK,IAAI,IAAE,GAAG,IAAG,YAAY,IAAK;QAC9B,MAAM,GAAG,KAAK,CAAC;QACf,IAAI,AAAC,UAAU,AAAC,IAAE,UAAW,KAAI,GAAG,OAAO,GAAG,CAAC,gBAAgB;IACnE;IACA,MAAM,mLAA4B,CAAC;IAEnC,eAAe;IACf,WAAW;IACX,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,GAAG,KAAK,CAAC;IACf,MAAM,mLAA4B,CAAC;IAEnC,gBAAgB;IAChB,WAAW;IACX,MAAM,qLAA8B,CAAC,IAAI;IACzC,MAAM,GAAG,UAAU,CAAC,IAAI,kBAAkB;IAC1C,MAAM,mLAA4B,CAAC;IAEnC,MAAM,GAAG,KAAK;IAEd,MAAM,qBAAqB,oLAAqC,CAAC,OAAO,OAAO;IAE/E,IAAI,QAAQ,OAAO,KAAK,CAAC,sJAAe,CAAC,2LAAO,CAAC,MAAM,CAAC;QAAE,OAAO;IAAG,GAAG,MAAM,IAAI;IAEjF,IAAI,QAAQ,OAAO,IAAI,CAAC,sJAAe,CAAC,oBAAoB;IAE5D,OAAO;AAEX","ignoreList":[0]}},
    {"offset": {"line": 2231, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_export_challenge.js"],"sourcesContent":["// Format of the outpu\n//     Hash of the last contribution  64Bytes\n//     2^N * 2 -1  TauG1 points (uncompressed)\n//     2^N  TauG2 Points (uncompressed)\n//     2^N  AlphaTauG1 Points (uncompressed)\n//     2^N  BetaTauG1 Points (uncompressed)\n//     BetaG2 (uncompressed)\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function exportChallenge(pTauFilename, challengeFilename, logger) {\n    const {fd: fdFrom, sections} = await binFileUtils.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await utils.readPTauHeader(fdFrom, sections);\n\n    const contributions = await utils.readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = blake2b.create({ dkLen: 64 }).digest();\n        curChallengeHash = utils.calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(misc.formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(misc.formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastFile.createOverride(challengeFilename);\n\n    const toHash = blake2b.create({ dkLen: 64 });\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!misc.hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(misc.formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await binFileUtils.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await binFileUtils.endReadSection(fdFrom);\n    }\n\n\n}\n\n"],"names":[],"mappings":";;;;AAAA,sBAAsB;AACtB,6CAA6C;AAC7C,8CAA8C;AAC9C,uCAAuC;AACvC,4CAA4C;AAC5C,2CAA2C;AAC3C,4BAA4B;AAE5B;AACA;AACA;AACA;AACA;;;;;;AAEe,eAAe,gBAAgB,YAAY,EAAE,iBAAiB,EAAE,MAAM;IACjF,MAAM,EAAC,IAAI,MAAM,EAAE,QAAQ,EAAC,GAAG,MAAM,+KAAwB,CAAC,cAAc,QAAQ;IAEpF,MAAM,EAAC,KAAK,EAAE,KAAK,EAAC,GAAG,MAAM,uKAAoB,CAAC,QAAQ;IAE1D,MAAM,gBAAgB,MAAM,0KAAuB,CAAC,QAAQ,OAAO;IACnE,IAAI,kBAAkB;IACtB,IAAI,cAAc,MAAM,IAAI,GAAG;QAC3B,mBAAmB,2LAAO,CAAC,MAAM,CAAC;YAAE,OAAO;QAAG,GAAG,MAAM;QACvD,mBAAmB,oLAAiC,CAAC,OAAO;IAChE,OAAO;QACH,mBAAmB,aAAa,CAAC,cAAc,MAAM,GAAC,EAAE,CAAC,YAAY;QACrE,mBAAmB,aAAa,CAAC,cAAc,MAAM,GAAC,EAAE,CAAC,aAAa;IAC1E;IAEA,IAAI,QAAQ,OAAO,IAAI,CAAC,sJAAe,CAAC,kBAAkB;IAE1D,IAAI,QAAQ,OAAO,IAAI,CAAC,sJAAe,CAAC,kBAAkB;IAG1D,MAAM,OAAO,MAAM,+JAAuB,CAAC;IAE3C,MAAM,SAAS,2LAAO,CAAC,MAAM,CAAC;QAAE,OAAO;IAAG;IAC1C,MAAM,KAAK,KAAK,CAAC;IACjB,OAAO,MAAM,CAAC;IAEd,MAAM,cAAc,GAAG,MAAM,AAAC,KAAK,QAAS,IAAG,GAAG;IAClD,MAAM,cAAc,GAAG,MAAO,KAAK,OAAe;IAClD,MAAM,cAAc,GAAG,MAAO,KAAK,OAAe;IAClD,MAAM,cAAc,GAAG,MAAO,KAAK,OAAe;IAClD,MAAM,cAAc,GAAG,MAAM,GAAqB;IAElD,MAAM,OAAO,KAAK;IAClB,MAAM,KAAK,KAAK;IAEhB,MAAM,uBAAuB,OAAO,MAAM;IAE1C,IAAI,CAAC,uJAAgB,CAAE,kBAAkB,uBAAuB;QAC5D,IAAI,QAAQ,OAAO,IAAI,CAAC,sJAAe,CAAC,sBAAsB;QAE9D,IAAI,QAAQ,OAAO,KAAK,CAAC;QACzB,MAAM,IAAI,MAAM;IACpB;IAEA,OAAO;;;IAEP,eAAe,cAAc,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,WAAW;QACnE,MAAM,IAAI,KAAK,CAAC,UAAU;QAC1B,MAAM,KAAK,EAAE,CAAC,CAAC,EAAE,GAAC;QAClB,MAAM,eAAe,KAAK,KAAK,CAAC,CAAC,KAAG,EAAE,IAAE;QAExC,MAAM,0LAAmC,CAAC,QAAQ,UAAU;QAC5D,IAAK,IAAI,IAAE,GAAG,IAAG,SAAS,KAAI,aAAc;YACxC,IAAI,QAAQ,OAAO,KAAK,CAAC,CAAC,UAAU,EAAE,YAAY,EAAE,EAAE,EAAE,CAAC,EAAE,SAAS;YACpE,MAAM,IAAI,KAAK,GAAG,CAAC,UAAQ,GAAG;YAC9B,IAAI;YACJ,OAAO,MAAM,OAAO,IAAI,CAAC,IAAE;YAC3B,OAAO,MAAM,EAAE,WAAW,CAAC;YAC3B,MAAM,KAAK,KAAK,CAAC;YACjB,OAAO,MAAM,CAAC;QAClB;QACA,MAAM,kLAA2B,CAAC;IACtC;AAGJ","ignoreList":[0]}},
    {"offset": {"line": 2311, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_import.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compressed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compressed size\n\n    const fdResponse = await fastFile.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (misc.hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!misc.hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. This contribution is not based on the previous hash\");\n\n    const hasherResponse = blake2b.create({ dkLen: 64 });\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = misc.toPartialHash(hasherResponse);\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = utils.fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(misc.formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await binFileUtils.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await binFileUtils.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2499, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_verify.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as keyPair from \"./keypair.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { ChaCha, BigBuffer } from \"ffjavascript\";\nimport * as misc from \"./misc.js\";\nconst sameRatio = misc.sameRatio;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = await utils.keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(keyPair.getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nexport default async function verify(tauFilename, logger) {\n    let sr;\n\n    const {fd, sections} = await binFileUtils.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fd, sections);\n    const contrs = await utils.readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: utils.calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: blake2b.create({ dkLen: 64 }).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = blake2b.create({ dkLen: 64 });\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!misc.hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(misc.formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr, logger);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(misc.formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        utils.toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher =  misc.fromPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(misc.formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(misc.formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${misc.byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = misc.getRandomBytes(4*(n-1));\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = misc.readUInt32BE(misc.getRandomBytes(4), 0);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await binFileUtils.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = misc.readUInt32BE(misc.getRandomBytes(4), 0);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await binFileUtils.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await binFileUtils.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new BigBuffer(nPoints * n8r);\n\n            rng = new ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await binFileUtils.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await binFileUtils.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2930, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/mpc_applykey.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the points in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nexport async function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await binFileUtils.startReadUniqueSection(fdOld, sections,idSection );\n    await binFileUtils.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await binFileUtils.endWriteSection(fdNew);\n    await binFileUtils.endReadSection(fdOld);\n}\n\n\n\nexport async function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;;AASO,eAAe,kBAAkB,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM;IACxH,MAAM,iBAAiB,KAAK;IAC5B,MAAM,IAAI,KAAK,CAAC,UAAU;IAC1B,MAAM,KAAK,EAAE,CAAC,CAAC,EAAE,GAAC;IAClB,MAAM,UAAU,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,IAAI,GAAG;IAE9C,MAAM,0LAAmC,CAAC,OAAO,UAAS;IAC1D,MAAM,qLAA8B,CAAC,OAAO;IAE5C,IAAI,IAAI;IACR,IAAK,IAAI,IAAE,GAAG,IAAE,SAAS,KAAK,eAAgB;QAC1C,IAAI,QAAQ,OAAO,KAAK,CAAC,CAAC,cAAc,EAAE,YAAY,EAAE,EAAE,EAAE,CAAC,EAAE,SAAS;QACxE,MAAM,IAAG,KAAK,GAAG,CAAC,UAAU,GAAG;QAC/B,IAAI;QACJ,OAAO,MAAM,MAAM,IAAI,CAAC,IAAE;QAC1B,OAAO,MAAM,EAAE,aAAa,CAAC,MAAM,GAAG;QACtC,MAAM,MAAM,KAAK,CAAC;QAClB,IAAI,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,CAAC,KAAK;IAC1C;IAEA,MAAM,mLAA4B,CAAC;IACnC,MAAM,kLAA2B,CAAC;AACtC;AAIO,eAAe,2BAA2B,KAAK,EAAE,KAAK,EAAE,cAAc,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM;IAChJ,MAAM,IAAI,KAAK,CAAC,UAAU;IAC1B,MAAM,KAAK,EAAE,CAAC,CAAC,EAAE,GAAC;IAClB,MAAM,YAAY,KAAK,KAAK,CAAC,CAAC,KAAG,EAAE,IAAI,KAAO,eAAe;IAC7D,IAAI,IAAI;IACR,IAAK,IAAI,IAAE,GAAI,IAAE,SAAU,KAAI,UAAW;QACtC,IAAI,QAAQ,OAAO,KAAK,CAAC,CAAC,aAAa,EAAE,YAAY,EAAE,EAAE,EAAE,CAAC,EAAE,SAAS;QACvE,MAAM,IAAG,KAAK,GAAG,CAAC,UAAQ,GAAG;QAC7B,MAAM,UAAU,MAAM,MAAM,IAAI,CAAC,IAAI;QACrC,MAAM,YAAY,MAAM,EAAE,WAAW,CAAC;QACtC,MAAM,aAAa,MAAM,EAAE,aAAa,CAAC,WAAW,GAAG;QACvD,IAAI;QACJ,IAAI,aAAa,cAAc;YAC3B,UAAU,MAAM,EAAE,WAAW,CAAC;QAClC,OAAO;YACH,UAAU,MAAM,EAAE,WAAW,CAAC;QAClC;QAEA,IAAI,gBAAgB,eAAe,MAAM,CAAC;QAC1C,MAAM,MAAM,KAAK,CAAC;QAClB,IAAI,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,CAAC,KAAK;IAC1C;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3001, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_challenge_contribute.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as misc from \"./misc.js\";\nimport { applyKeyToChallengeSection } from \"./mpc_applykey.js\";\nimport * as keyPair from \"./keypair.js\";\n\nexport default async function challengeContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const fdFrom = await fastFile.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await misc.getRandomRng(entropy);\n\n    const fdTo = await fastFile.createOverride(responseFileName);\n\n    // Calculate the hash\n    const challengeHasher = blake2b.create({ dkLen: 64 });\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(misc.formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(misc.formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = keyPair.createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(misc.formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3118, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_beacon.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as misc from \"./misc.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\n\nexport default async function beacon(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = misc.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = await utils.keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = misc.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_contribute.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (uncompressed)\n//      2^N TauG2 Points (uncompressed)\n//      2^N AlphaTauG1 Points (uncompressed)\n//      2^N BetaTauG1 Points (uncompressed)\n\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as keyPair from \"./keypair.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as misc from \"./misc.js\";\n\nexport default async function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await utils.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await misc.getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = utils.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = keyPair.createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = misc.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    utils.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await utils.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await binFileUtils.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3428, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_preparephase2.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {BigBuffer} from \"ffjavascript\";\n\nexport default async function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    await binFileUtils.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const Fr = curve.Fr;\n            const sGin = G.F.n8*2;\n            const sGmid = G.F.n8*3;\n\n            let buff;\n            buff = new BigBuffer(nPoints*sGin);\n\n            await binFileUtils.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;AAAA;;;;AAEe,eAAe,cAAc,eAAe,EAAE,eAAe,EAAE,MAAM;IAEhF,MAAM,EAAC,IAAI,KAAK,EAAE,QAAQ,EAAC,GAAG,MAAM,+KAAwB,CAAC,iBAAiB,QAAQ;IACtF,MAAM,EAAC,KAAK,EAAE,KAAK,EAAC,GAAG,MAAM,uKAAoB,CAAC,OAAO;IAEzD,MAAM,QAAQ,MAAM,iLAA0B,CAAC,iBAAiB,QAAQ,GAAG;IAC3E,MAAM,wKAAqB,CAAC,OAAO,OAAO;IAE1C,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IAEvD,MAAM,eAAe,GAAG,IAAI,MAAM;IAClC,MAAM,eAAe,GAAG,IAAI,MAAM;IAClC,MAAM,eAAe,GAAG,IAAI,MAAM;IAClC,MAAM,eAAe,GAAG,IAAI,MAAM;IAElC,MAAM,MAAM,KAAK;IACjB,MAAM,MAAM,KAAK;IAEjB,qDAAqD;IAErD;;;IAEA,eAAe,eAAe,YAAY,EAAE,YAAY,EAAE,IAAI,EAAE,WAAW;QACvE,IAAI,QAAQ,OAAO,KAAK,CAAC,uBAAqB;QAE9C,MAAM,qLAA8B,CAAC,OAAO;QAE5C,IAAK,IAAI,IAAE,GAAG,KAAG,OAAO,IAAK;YACzB,MAAM,oBAAoB;QAC9B;QAEA,IAAI,gBAAgB,GAAG;YACnB,MAAM,oBAAoB,QAAM;QACpC;QAEA,MAAM,mLAA4B,CAAC;QAGnC,eAAe,oBAAoB,CAAC;YAChC,MAAM,UAAU,KAAK;YACrB,MAAM,IAAI,KAAK,CAAC,KAAK;YACrB,MAAM,KAAK,MAAM,EAAE;YACnB,MAAM,OAAO,EAAE,CAAC,CAAC,EAAE,GAAC;YACpB,MAAM,QAAQ,EAAE,CAAC,CAAC,EAAE,GAAC;YAErB,IAAI;YACJ,OAAO,IAAI,uMAAS,CAAC,UAAQ;YAE7B,MAAM,0LAAmC,CAAC,OAAO,UAAU;YAC3D,IAAI,AAAC,gBAAgB,KAAK,KAAG,QAAM,GAAI;gBACnC,MAAM,MAAM,YAAY,CAAC,MAAM,GAAE,CAAC,UAAQ,CAAC,IAAE;gBAC7C,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC,UAAU,EAAE,CAAC,UAAQ,CAAC,IAAE;YAC9C,OAAO;gBACH,MAAM,MAAM,YAAY,CAAC,MAAM,GAAE,UAAQ;YAC7C;YACA,MAAM,kLAA2B,CAAC,OAAO;YAGzC,OAAO,MAAM,EAAE,mBAAmB,CAAC,MAAM,UAAU,UAAU,QAAQ;YACrE,MAAM,MAAM,KAAK,CAAC;QAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA,GACQ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3560, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_truncate.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\n\nexport default async function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await utils.readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await binFileUtils.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await utils.writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await binFileUtils.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 7); // contributions\n        await binFileUtils.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await binFileUtils.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await binFileUtils.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;;;AAEe,eAAe,SAAS,YAAY,EAAE,QAAQ,EAAE,MAAM;IAEjE,MAAM,EAAC,IAAI,KAAK,EAAE,QAAQ,EAAC,GAAG,MAAM,+KAAwB,CAAC,cAAc,QAAQ;IACnF,MAAM,EAAC,KAAK,EAAE,KAAK,EAAE,aAAa,EAAC,GAAG,MAAM,uKAAoB,CAAC,OAAO;IAExE,MAAM,MAAM,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,GAAC;IAC1B,MAAM,MAAM,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,GAAC;IAE1B,IAAK,IAAI,IAAE,GAAG,IAAE,OAAO,IAAK;QACxB,MAAM,iBAAiB;IAC3B;IAEA,MAAM,MAAM,KAAK;IAEjB,OAAO;;;IAEP,eAAe,iBAAiB,CAAC;QAE7B,IAAI,KAAK,EAAE,QAAQ;QACnB,MAAO,GAAG,MAAM,GAAC,EAAG,KAAK,MAAM;QAE/B,IAAI,QAAQ,OAAO,KAAK,CAAC,oBAAkB;QAE3C,MAAM,QAAQ,MAAM,iLAA0B,CAAC,WAAW,KAAK,SAAS,QAAQ,GAAG;QACnF,MAAM,wKAAqB,CAAC,OAAO,OAAO,GAAG;QAE7C,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,GAAG,CAAC,AAAC,KAAK,IAAG,IAAE,CAAC,IAAI,MAAO,QAAQ;QAC1F,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,GAAG,AAAC,KAAK,IAAK,MAAM,QAAQ;QACnF,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,GAAG,AAAC,KAAK,IAAK,MAAM,YAAY;QACvF,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,GAAG,AAAC,KAAK,IAAK,MAAM,YAAY;QACvF,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,GAAI,MAAM,YAAY;QAC7E,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,IAAI,gBAAgB;QAC3E,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,IAAI,CAAC,AAAC,KAAK,CAAC,IAAE,CAAC,IAAG,IAAG,CAAC,IAAI,MAAM,UAAU;QACjG,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,IAAI,CAAC,AAAC,KAAK,IAAG,IAAG,CAAC,IAAI,MAAM,UAAU;QAC7F,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,IAAI,CAAC,AAAC,KAAK,IAAG,IAAG,CAAC,IAAI,MAAM,cAAc;QACjG,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO,IAAI,CAAC,AAAC,KAAK,IAAG,IAAG,CAAC,IAAI,MAAM,cAAc;QAEjG,MAAM,MAAM,KAAK;IACrB;AAGJ","ignoreList":[0]}},
    {"offset": {"line": 3620, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_convert.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as fastFile from \"fastfile\";\nimport {BigBuffer} from \"ffjavascript\";\n\nexport default async function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await binFileUtils.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await utils.readPTauHeader(fdOld, sections);\n\n    const fdNew = await binFileUtils.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await utils.writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await binFileUtils.copySection(fdOld, sections, fdNew, 2);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await binFileUtils.copySection(fdOld, sections, fdNew, 13);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 14);\n    await binFileUtils.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await binFileUtils.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await binFileUtils.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await binFileUtils.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await binFileUtils.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new BigBuffer(nPoints*sGin);\n\n            await binFileUtils.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await binFileUtils.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;AACA;AAAA;;;;;AAEe,eAAe,QAAQ,eAAe,EAAE,eAAe,EAAE,MAAM;IAE1E,MAAM,EAAC,IAAI,KAAK,EAAE,QAAQ,EAAC,GAAG,MAAM,+KAAwB,CAAC,iBAAiB,QAAQ;IACtF,MAAM,EAAC,KAAK,EAAE,KAAK,EAAC,GAAG,MAAM,uKAAoB,CAAC,OAAO;IAEzD,MAAM,QAAQ,MAAM,iLAA0B,CAAC,iBAAiB,QAAQ,GAAG;IAC3E,MAAM,wKAAqB,CAAC,OAAO,OAAO;IAE1C,wEAAwE;IAExE,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IAEvD,MAAM,eAAe,GAAG,IAAI,MAAM;IAClC,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IACvD,MAAM,+KAAwB,CAAC,OAAO,UAAU,OAAO;IAEvD,MAAM,MAAM,KAAK;IACjB,MAAM,MAAM,KAAK;IAEjB,qDAAqD;IAErD;;;IAEA,eAAe,eAAe,YAAY,EAAE,YAAY,EAAE,IAAI,EAAE,WAAW;QACvE,IAAI,QAAQ,OAAO,KAAK,CAAC,uBAAqB;QAE9C,MAAM,qLAA8B,CAAC,OAAO;QAE5C,MAAM,OAAO,QAAQ,CAAC,aAAa,CAAC,EAAE,CAAC,IAAI;QAC3C,MAAM,YAAY,MAAM,QAAQ;QAChC,MAAM,0LAAmC,CAAC,OAAO,UAAU;QAC3D,IAAK,IAAI,IAAE,GAAG,IAAE,MAAM,KAAG,UAAW;YAChC,MAAM,IAAI,KAAK,GAAG,CAAC,OAAM,GAAG;YAC5B,MAAM,OAAO,MAAM,MAAM,IAAI,CAAC;YAC9B,MAAM,MAAM,KAAK,CAAC;QACtB;QACA,MAAM,kLAA2B,CAAC;QAElC,IAAI,gBAAgB,GAAG;YACnB,MAAM,oBAAoB,QAAM;QACpC;QAEA,MAAM,mLAA4B,CAAC;QAEnC,eAAe,oBAAoB,CAAC;YAChC,MAAM,UAAU,KAAK;YACrB,MAAM,IAAI,KAAK,CAAC,KAAK;YACrB,MAAM,OAAO,EAAE,CAAC,CAAC,EAAE,GAAC;YAEpB,IAAI;YACJ,OAAO,IAAI,uMAAS,CAAC,UAAQ;YAE7B,MAAM,0LAAmC,CAAC,OAAO,UAAU;YAC3D,IAAI,AAAC,gBAAgB,KAAK,KAAG,QAAM,GAAI;gBACnC,MAAM,MAAM,YAAY,CAAC,MAAM,GAAE,CAAC,UAAQ,CAAC,IAAE;gBAC7C,KAAK,GAAG,CAAC,MAAM,EAAE,CAAC,UAAU,EAAE,CAAC,UAAQ,CAAC,IAAE;YAC9C,OAAO;gBACH,MAAM,MAAM,YAAY,CAAC,MAAM,GAAE,UAAQ;YAC7C;YACA,MAAM,kLAA2B,CAAC,OAAO;YAEzC,OAAO,MAAM,EAAE,mBAAmB,CAAC,MAAM,UAAU,UAAU,QAAQ;YACrE,MAAM,MAAM,KAAK,CAAC;QAE9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA,GACQ;IAGJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3760, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau_export_json.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as utils from \"./powersoftau_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport { stringifyBigIntsWithField } from \"./misc.js\";\n\nexport default async function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await binFileUtils.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await utils.readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await utils.readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return stringifyBigIntsWithField(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await binFileUtils.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await binFileUtils.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await binFileUtils.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;;;;AAEe,eAAe,WAAW,YAAY,EAAE,OAAO;IAC1D,MAAM,EAAC,EAAE,EAAE,QAAQ,EAAC,GAAG,MAAM,+KAAwB,CAAC,cAAc,QAAQ;IAE5E,MAAM,EAAC,KAAK,EAAE,KAAK,EAAC,GAAG,MAAM,uKAAoB,CAAC,IAAI;IAEtD,MAAM,OAAO,CAAC;IACd,KAAK,CAAC,GAAG,MAAM,CAAC;IAChB,KAAK,KAAK,GAAG;IACb,KAAK,aAAa,GAAG,MAAM,0KAAuB,CAAC,IAAI,OAAO;IAE9D,KAAK,KAAK,GAAG,MAAM,cAAc,GAAG,MAAM,AAAC,KAAK,QAAO,IAAG,GAAG;IAC7D,KAAK,KAAK,GAAG,MAAM,cAAc,GAAG,MAAO,KAAK,OAAQ;IACxD,KAAK,UAAU,GAAG,MAAM,cAAc,GAAG,MAAO,KAAK,OAAQ;IAC7D,KAAK,SAAS,GAAG,MAAM,cAAc,GAAG,MAAO,KAAK,OAAQ;IAC5D,KAAK,MAAM,GAAG,MAAM,cAAc,GAAG,MAAM,GAAG;IAE9C,KAAK,MAAM,GAAG,MAAM,eAAe,IAAI,MAAM;IAC7C,KAAK,MAAM,GAAG,MAAM,eAAe,IAAI,MAAM;IAC7C,KAAK,WAAW,GAAG,MAAM,eAAe,IAAI,MAAM;IAClD,KAAK,UAAU,GAAG,MAAM,eAAe,IAAI,MAAM;IAEjD,MAAM,GAAG,KAAK;IAEd,OAAO,IAAA,qKAAyB,EAAC,MAAM,EAAE,EAAE;;;IAI3C,eAAe,cAAc,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,WAAW;QACnE,MAAM,IAAI,KAAK,CAAC,UAAU;QAC1B,MAAM,KAAK,EAAE,CAAC,CAAC,EAAE,GAAC;QAElB,MAAM,MAAM,EAAE;QACd,MAAM,0LAAmC,CAAC,IAAI,UAAU;QACxD,IAAK,IAAI,IAAE,GAAG,IAAG,SAAS,IAAK;YAC3B,IAAI,AAAC,WAAU,KAAI,IAAE,SAAS,GAAI,QAAQ,GAAG,CAAC,GAAG,YAAY,EAAE,CAAC,GAAG;YACnE,MAAM,OAAO,MAAM,GAAG,IAAI,CAAC;YAC3B,IAAI,IAAI,CAAC,EAAE,UAAU,CAAC,MAAM;QAChC;QACA,MAAM,kLAA2B,CAAC;QAElC,OAAO;IACX;IAEA,eAAe,eAAe,SAAS,EAAE,SAAS,EAAE,WAAW;QAC3D,MAAM,IAAI,KAAK,CAAC,UAAU;QAC1B,MAAM,KAAK,EAAE,CAAC,CAAC,EAAE,GAAC;QAElB,MAAM,MAAM,EAAE;QACd,MAAM,0LAAmC,CAAC,IAAI,UAAU;QACxD,IAAK,IAAI,IAAE,GAAG,KAAG,OAAO,IAAK;YACzB,IAAI,SAAS,QAAQ,GAAG,CAAC,GAAG,YAAY,SAAS,EAAE,GAAG;YACtD,GAAG,CAAC,EAAE,GAAG,EAAE;YACX,MAAM,UAAW,KAAK;YACtB,IAAK,IAAI,IAAE,GAAG,IAAE,SAAS,IAAK;gBAC1B,IAAI,AAAC,WAAU,KAAI,IAAE,SAAS,GAAI,QAAQ,GAAG,CAAC,GAAG,YAAY,EAAE,EAAE,EAAE,CAAC,EAAE,SAAS;gBAC/E,MAAM,OAAO,MAAM,GAAG,IAAI,CAAC;gBAC3B,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,UAAU,CAAC,MAAM;YACnC;QACJ;QACA,MAAM,kLAA2B,CAAC,IAAI;QACtC,OAAO;IACX;AAGJ","ignoreList":[0]}},
    {"offset": {"line": 3843, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/powersoftau.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as newAccumulator} from \"./powersoftau_new.js\";\nexport {default as exportChallenge} from \"./powersoftau_export_challenge.js\";\nexport {default as importResponse} from \"./powersoftau_import.js\";\nexport {default as verify} from \"./powersoftau_verify.js\";\nexport {default as challengeContribute} from \"./powersoftau_challenge_contribute.js\";\nexport {default as beacon} from \"./powersoftau_beacon.js\";\nexport {default as contribute} from \"./powersoftau_contribute.js\";\nexport {default as preparePhase2} from \"./powersoftau_preparephase2.js\";\nexport {default as truncate} from \"./powersoftau_truncate.js\";\nexport {default as convert} from \"./powersoftau_convert.js\";\nexport {default as exportJson} from \"./powersoftau_export_json.js\";\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 3887, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/r1cs_print.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport default function r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAiBA;;;;AAEe,SAAS,UAAU,IAAI,EAAE,IAAI,EAAE,MAAM;IAChD,IAAK,IAAI,IAAE,GAAG,IAAE,KAAK,WAAW,CAAC,MAAM,EAAE,IAAK;QAC1C,eAAe,KAAK,WAAW,CAAC,EAAE;IACtC;IACA,SAAS,eAAe,CAAC;QACrB,MAAM,SAAS,CAAC;YACZ,IAAI,IAAI;YACR,MAAM,OAAO,OAAO,IAAI,CAAC;YACzB,KAAK,OAAO,CAAE,CAAC;gBACX,IAAI,OAAO,KAAK,WAAW,CAAC,EAAE;gBAC9B,IAAI,QAAQ,OAAO,OAAO;gBAE1B,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE;gBACrC,IAAI,MAAM,KAAK,KAAK,IAAK,mBAAmB;gBAC5C,IAAI,MAAM,MAAM,KAAK,KAAM,mBAAmB;gBAC9C,IAAI,AAAC,KAAG,MAAM,EAAE,CAAC,EAAE,IAAE,KAAM,KAAK,MAAI;gBACpC,IAAI,KAAG,IAAI,KAAK,MAAI;gBACpB,IAAG,IAAI,KAAO;YAClB;YACA,OAAO;QACX;QACA,MAAM,IAAI,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC;QAC/E,IAAI,QAAQ,OAAO,IAAI,CAAC;IAC5B;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 3936, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/r1cs_info.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { Scalar } from \"ffjavascript\";\nimport { readR1cs }  from \"r1csfile\";\n\nconst bls12381r = Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nexport default async function r1csInfo(r1csName, logger) {\n\n    const cir = await readR1cs(r1csName);\n\n    if (Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;;;AAEA,MAAM,YAAY,gKAAM,CAAC,CAAC,CAAC,oEAAoE;AAC/F,MAAM,SAAS,gKAAM,CAAC,CAAC,CAAC;AAET,eAAe,SAAS,QAAQ,EAAE,MAAM;IAEnD,MAAM,MAAM,MAAM,IAAA,yJAAQ,EAAC;IAE3B,IAAI,gKAAM,CAAC,EAAE,CAAC,IAAI,KAAK,EAAE,SAAS;QAC9B,IAAI,QAAQ,OAAO,IAAI,CAAC;IAC5B,OAAO,IAAI,gKAAM,CAAC,EAAE,CAAC,IAAI,KAAK,EAAE,YAAY;QACxC,IAAI,QAAQ,OAAO,IAAI,CAAC;IAC5B,OAAO;QACH,IAAI,QAAQ,OAAO,IAAI,CAAC,CAAC,sBAAsB,EAAE,gKAAM,CAAC,QAAQ,CAAC,IAAI,KAAK,GAAG;IACjF;IACA,IAAI,QAAQ,OAAO,IAAI,CAAC,CAAC,YAAY,EAAE,IAAI,KAAK,EAAE;IAClD,IAAI,QAAQ,OAAO,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,YAAY,EAAE;IAC/D,IAAI,QAAQ,OAAO,IAAI,CAAC,CAAC,qBAAqB,EAAE,IAAI,UAAU,EAAE;IAChE,IAAI,QAAQ,OAAO,IAAI,CAAC,CAAC,oBAAoB,EAAE,IAAI,UAAU,EAAE;IAC/D,IAAI,QAAQ,OAAO,IAAI,CAAC,CAAC,aAAa,EAAE,IAAI,OAAO,EAAE;IACrD,IAAI,QAAQ,OAAO,IAAI,CAAC,CAAC,cAAc,EAAE,IAAI,QAAQ,EAAE;IAEvD,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 3984, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/r1cs_export_json.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1cs}  from \"r1csfile\";\nimport { stringifyBigIntsWithField } from \"./misc.js\";\n\n\nexport default async function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await readR1cs(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return stringifyBigIntsWithField(Fr, cir);\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;;;AAGe,eAAe,eAAe,YAAY,EAAE,MAAM;IAE7D,MAAM,MAAM,MAAM,IAAA,yJAAQ,EAAC,cAAc,MAAM,MAAM,MAAM;IAC3D,MAAM,KAAG,IAAI,KAAK,CAAC,EAAE;IACrB,OAAO,IAAI,KAAK;IAChB,OAAO,IAAI,CAAC;IAEZ,OAAO,IAAA,qKAAyB,EAAC,IAAI;AACzC","ignoreList":[0]}},
    {"offset": {"line": 4020, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/r1cs.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as print} from \"./r1cs_print.js\";\nexport {default as info} from \"./r1cs_info.js\";\nexport {default as exportJson} from \"./r1cs_export_json.js\";\n\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 4048, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/loadsyms.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\n\nexport default async function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastFile.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;;AAEe,eAAe,YAAY,WAAW;IACjD,MAAM,MAAM;QACR,eAAe;YAAE;SAAO;QACxB,aAAa;YAAE;SAAO;QACtB,mBAAmB,EAAE;IACzB;IACA,MAAM,KAAK,MAAM,6JAAqB,CAAC;IACvC,MAAM,OAAO,MAAM,GAAG,IAAI,CAAC,GAAG,SAAS;IACvC,MAAM,UAAU,IAAI,YAAY,SAAS,MAAM,CAAC;IAChD,MAAM,QAAQ,QAAQ,KAAK,CAAC;IAC5B,IAAK,IAAI,IAAE,GAAG,IAAE,MAAM,MAAM,EAAE,IAAK;QAC/B,MAAM,MAAM,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC;QAC3B,IAAI,IAAI,MAAM,IAAE,GAAG;QACnB,IAAI,IAAI,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YACzB,IAAI,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,MAAM,GAAG,CAAC,EAAE;QAC3C,OAAO;YACH,IAAI,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE;QACpC;QACA,IAAI,aAAa,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE;QAClC,IAAI,CAAC,IAAI,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YAChC,IAAI,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,GAAG,CAAC,EAAE;QAC3D;IACJ;IAEA,MAAM,GAAG,KAAK;IAEd,OAAO;;;IAEP,SAAS,iBAAiB,IAAI;QAC1B,MAAM,MAAM,KAAK,KAAK,CAAC;QACvB,IAAI,GAAG,IAAI,0BAA0B;QACrC,OAAO,IAAI,IAAI,CAAC;IACpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/wtns_debug.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as fastFile from \"fastfile\";\nimport { WitnessCalculatorBuilder } from \"circom_runtime\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport loadSyms from \"./loadsyms.js\";\nimport {  utils }   from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\n\nexport default async function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastFile.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wcOps = {...options, sanityCheck: true};\n    let sym = await loadSyms(symName);\n    if (options.set) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await loadSyms(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await WitnessCalculatorBuilder(wasm, wcOps);\n    const w = await wc.calculateWitness(input, true);\n\n    const fdWtns = await binFileUtils.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await wtnsUtils.write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AACA,MAAM,EAAC,kBAAkB,EAAC,GAAG,+JAAK;AAGnB,eAAe,UAAU,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM;IAEhG,MAAM,QAAQ,mBAAmB;IAEjC,MAAM,SAAS,MAAM,6JAAqB,CAAC;IAC3C,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,OAAO,SAAS;IAC/C,MAAM,OAAO,KAAK;IAElB,MAAM,QAAQ;QAAC,GAAG,OAAO;QAAE,aAAa;IAAI;IAC5C,IAAI,MAAM,MAAM,IAAA,uJAAQ,EAAC;IACzB,IAAI,QAAQ,GAAG,EAAE;QACb,IAAI,CAAC,KAAK,MAAM,MAAM,IAAA,uJAAQ,EAAC;QAC/B,MAAM,YAAY,GAAE,SAAS,QAAQ,EAAE,KAAK;YACxC,4FAA4F;YAC5F,IAAI,QAAQ,OAAO,IAAI,CAAC,SAAS,IAAI,aAAa,CAAC,SAAS,GAAG,OAAO,QAAQ,MAAM,QAAQ;QAChG;IACJ;IACA,IAAI,QAAQ,GAAG,EAAE;QACb,IAAI,CAAC,KAAK,MAAM,MAAM,IAAA,uJAAQ,EAAC;QAC/B,MAAM,YAAY,GAAE,SAAS,MAAM,EAAE,KAAK;YACtC,4FAA4F;YAC5F,IAAI,QAAQ,OAAO,IAAI,CAAC,SAAS,IAAI,aAAa,CAAC,OAAO,GAAG,QAAQ,OAAO,MAAM,QAAQ;QAC9F;IACJ;IACA,IAAI,QAAQ,OAAO,EAAE;QACjB,IAAI,CAAC,KAAK,MAAM,MAAM,IAAA,uJAAQ,EAAC;QAC/B,MAAM,iBAAiB,GAAE,SAAS,IAAI;YAClC,IAAI,QAAQ,OAAO,IAAI,CAAC,YAAY,IAAI,iBAAiB,CAAC,KAAK;QACnE;QACA,MAAM,kBAAkB,GAAE,SAAS,IAAI;YACnC,IAAI,QAAQ,OAAO,IAAI,CAAC,aAAa,IAAI,iBAAiB,CAAC,KAAK;QACpE;IACJ;IACA,MAAM,GAAG,GAAG;IAEZ,MAAM,KAAK,MAAM,IAAA,+OAAwB,EAAC,MAAM;IAChD,MAAM,IAAI,MAAM,GAAG,gBAAgB,CAAC,OAAO;IAE3C,MAAM,SAAS,MAAM,iLAA0B,CAAC,cAAc,QAAQ,GAAG;IAEzE,MAAM,uJAAe,CAAC,QAAQ,GAAG,GAAG,KAAK;IAEzC,MAAM,OAAO,KAAK;AACtB","ignoreList":[0]}},
    {"offset": {"line": 4191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/wtns_export_json.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {read} from \"./wtns_utils.js\";\n\nexport default async function wtnsExportJson(wtnsFileName) {\n\n    const w = await read(wtnsFileName);\n\n    return w;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;;AAEe,eAAe,eAAe,YAAY;IAErD,MAAM,IAAI,MAAM,IAAA,sJAAI,EAAC;IAErB,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 4222, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/wtns_check.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { readR1csFd } from \"r1csfile\";\nimport { Scalar } from \"ffjavascript\";\nimport * as curves from \"./curves.js\";\n\nexport default async function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await binFileUtils.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await binFileUtils.readBinFile(wtnsFilename, \"wtns\", 2, 1 << 22, 1 << 24);\n    const wtnsHeader = await wtnsUtils.readHeader(fdWtns, wtnsSections);\n\n    if (!Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await binFileUtils.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await curves.getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await binFileUtils.readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Outputs:        ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4357, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/wtns.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport {default as calculate} from \"./wtns_calculate.js\";\nexport {default as debug} from \"./wtns_debug.js\";\nexport {default as exportJson} from \"./wtns_export_json.js\";\nexport {default as check} from \"./wtns_check.js\";"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 4387, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/bigarray.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\nexport default BigArray;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA,MAAM,gBAAgB;AAEtB,MAAM,kBAAkB;IACpB,KAAK,SAAS,GAAG,EAAE,IAAI;QACnB,IAAI,CAAC,MAAM,OAAO;YACd,OAAO,IAAI,UAAU,CAAC;QAC1B,OAAO,OAAO,GAAG,CAAC,KAAK;IAC3B;IACA,KAAK,SAAS,GAAG,EAAE,IAAI,EAAE,KAAK;QAC1B,IAAI,CAAC,MAAM,OAAO;YACd,OAAO,IAAI,UAAU,CAAC,MAAM;QAChC,OAAO;YACH,GAAG,CAAC,KAAK,GAAG;YACZ,OAAO;QACX;IACJ;AACJ;AAEA,MAAM;IACF,YAAa,QAAQ,CAAE;QACnB,IAAI,CAAC,MAAM,GAAG,YAAY;QAC1B,IAAI,CAAC,GAAG,GAAG,IAAI,MAAM;QAErB,IAAK,IAAI,IAAE,GAAG,IAAE,UAAU,KAAG,cAAe;YACxC,IAAI,CAAC,GAAG,CAAC,IAAE,cAAc,GAAG,IAAI,MAAM,KAAK,GAAG,CAAC,eAAe,WAAW;QAC7E;QACA,OAAO,IAAI;IACf;IACA,OAAQ;QACJ,IAAK,IAAI,IAAE,GAAG,IAAE,UAAU,MAAM,EAAE,IAAK;YACnC,IAAI,CAAC,UAAU,CAAE,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE;QAC9C;IACJ;IAEA,MAAO,CAAC,EAAE,CAAC,EAAE;QACT,MAAM,MAAM,IAAI,MAAM,IAAE;QACxB,IAAK,IAAI,IAAE,GAAG,IAAG,GAAG,IAAK,GAAG,CAAC,IAAE,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC;QACpD,OAAO;IACX;IACA,WAAW,GAAG,EAAE;QACZ,MAAM,SAAS;QACf,MAAM,OAAO,KAAK,KAAK,CAAC,MAAM;QAC9B,MAAM,OAAO,MAAM;QACnB,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG;IACnD;IACA,WAAW,GAAG,EAAE,KAAK,EAAE;QACnB,MAAM,SAAS;QACf,MAAM,OAAO,KAAK,KAAK,CAAC,MAAM;QAC9B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE;YACjB,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,MAAM;QAC/B;QACA,MAAM,OAAO,MAAM;QACnB,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG;QACvB,IAAI,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,MAAI;QAC1C,OAAO;IACX;IACA,UAAU;QACN,MAAM,OAAO,IAAI;QACjB,IAAK,IAAI,IAAE,GAAG,IAAE,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,IAAK;YAClC,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE;gBACb,IAAK,IAAI,IAAE,GAAG,IAAE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,EAAE,IAAK;oBACrC,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,KAAK,aAAa;wBACvC,KAAK,IAAI,CAAC,IAAE,gBAAc;oBAC9B;gBACJ;YACJ;QACJ;QACA,OAAO;IACX;AACJ;AAEA,MAAM;IACF,YAAa,QAAQ,CAAG;QACpB,MAAM,MAAM,IAAI,UAAU;QAC1B,MAAM,SAAS,IAAI,MAAM,KAAK;QAC9B,OAAO;IACX;AACJ;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 4486, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_new.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1csHeader} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {\n    readBinFile,\n    createBinFile,\n    readSection,\n    writeBigInt,\n    startWriteSection,\n    endWriteSection,\n} from \"@iden3/binfileutils\";\nimport { log2, formatHash } from \"./misc.js\";\nimport { Scalar, BigBuffer } from \"ffjavascript\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport BigArray from \"./bigarray.js\";\n\n\nexport default async function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    const csHasher = blake2b.create({ dkLen: 64 });\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await utils.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await readR1csHeader(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = log2(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await startWriteSection(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await endWriteSection(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await startWriteSection(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = Scalar.mod(Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(Scalar.mod(Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await writeBigInt(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await writeBigInt(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const A = new BigArray(r1cs.nVars);\n    const B1 = new BigArray(r1cs.nVars);\n    const B2 = new BigArray(r1cs.nVars);\n    const C = new BigArray(r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await readSection(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await readSection(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await readSection(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await startWriteSection(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(formatHash(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await startWriteSection(fdZKey, 9);\n        const buffOut = new BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`splitting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await endWriteSection(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new BigArray();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await startWriteSection(fdZKey, 4);\n\n        const buffSection = new BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await endWriteSection(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await startWriteSection(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await endWriteSection(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new BigBuffer(acc*sGin);\n            bScalars = new BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5161, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_export_bellman.js"],"sourcesContent":["\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as fastFile from \"fastfile\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\n\nexport default async function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await binFileUtils.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastFile.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await binFileUtils.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await binFileUtils.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be always m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await binFileUtils.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await binFileUtils.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await binFileUtils.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await binFileUtils.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5283, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_import_bellman.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as fastFile from \"fastfile\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\n\nexport default async function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await zkeyUtils.readHeader(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await zkeyUtils.readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastFile.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nContributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!misc.hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previous contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new contributions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await zkeyUtils.writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await binFileUtils.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await binFileUtils.endWriteSection(fdZKeyNew);\n\n    // C Section (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await binFileUtils.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await binFileUtils.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await binFileUtils.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await zkeyUtils.writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!misc.hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5486, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_verify_frominit.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as misc from \"./misc.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nconst sameRatio = misc.sameRatio;\nimport {hashG1, hashPubKey} from \"./zkey_utils.js\";\nimport { Scalar, ChaCha, BigBuffer } from \"ffjavascript\";\n\n\n\nexport default async function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    const {fd, sections} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await zkeyUtils.readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = blake2b.create({ dkLen: 64 });\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = misc.cloneHasher(accumulatedHasher);\n\n        hashG1(ourHasher, curve, c.delta.g1_s);\n        hashG1(ourHasher, curve, c.delta.g1_sx);\n\n        if (!misc.hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = hashToG2(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = await misc.rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        hashPubKey(accumulatedHasher, curve, c);\n\n        const contributionHasher = blake2b.create({ dkLen: 64 });\n        hashPubKey(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await binFileUtils.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await zkeyUtils.readHeader(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await zkeyUtils.readMPCParams(fdInit, curve, sectionsInit);\n    if (!misc.hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await binFileUtils.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(misc.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(misc.formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${misc.byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await binFileUtils.startReadUniqueSection(fd1, sections1, idSection);\n        await binFileUtils.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = misc.getRandomBytes(4*n);\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await binFileUtils.endReadSection(fd1);\n        await binFileUtils.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await binFileUtils.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = misc.readUInt32BE(misc.getRandomBytes(4), 0);\n        }\n        const rng = new ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubtract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Calculate odd coefficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await binFileUtils.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await binFileUtils.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubtract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubtractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubtractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5872, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_verify_fromr1cs.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport newZKey from \"./zkey_new.js\";\nimport phase2verifyFromInit from \"./zkey_verify_frominit.js\";\n\nexport default async function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await newZKey(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;;;AAEe,eAAe,qBAAqB,YAAY,EAAE,YAAY,EAAE,YAAY,EAAE,MAAM;IAE/F,qDAAqD;IACrD,MAAM,eAAe;QAAC,MAAM;IAAQ;IACpC,MAAM,IAAA,uJAAO,EAAC,cAAc,cAAc,cAAc;IAExD,OAAO,MAAM,IAAA,mKAAoB,EAAC,cAAc,cAAc,cAAc;AAChF","ignoreList":[0]}},
    {"offset": {"line": 5909, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_contribute.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nimport { applyKeyToSection } from \"./mpc_applykey.js\";\n\nexport default async function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n\n    const {fd: fdOld, sections: sections} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurve(zkey.q);\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await misc.getRandomRng(entropy);\n\n    const transcriptHasher = blake2b.create({ dkLen: 64 });\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        utils.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await zkeyUtils.writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await zkeyUtils.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });\n    utils.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(misc.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6008, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_beacon.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport { getCurveFromQ as getCurve } from \"./curves.js\";\nimport * as misc from \"./misc.js\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\nimport { applyKeyToSection } from \"./mpc_applykey.js\";\n\n\nexport default async function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    const beaconHash = misc.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await binFileUtils.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await getCurve(zkey.q);\n\n    const mpcParams = await zkeyUtils.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await binFileUtils.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await misc.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = blake2b.create({ dkLen: 64 });;\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        utils.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await zkeyUtils.writeHeader(fdNew, zkey);\n\n    // IC\n    await binFileUtils.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await binFileUtils.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await binFileUtils.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await zkeyUtils.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });;\n    utils.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_export_json.js"],"sourcesContent":["import { readZKey as readZKey } from \"./zkey_utils.js\";\nimport { utils } from \"ffjavascript\";\n\nexport default async function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await readZKey(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return utils.stringifyBigInts(zKey);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEe,eAAe,eAAe,YAAY;IAErD,MAAM,OAAO,MAAM,IAAA,0JAAQ,EAAC,cAAc;IAC1C,OAAO,KAAK,KAAK;IACjB,OAAO,KAAK,CAAC;IAEb,OAAO,+JAAK,CAAC,gBAAgB,CAAC;AAClC","ignoreList":[0]}},
    {"offset": {"line": 6142, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_bellman_contribute.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\nimport * as fastFile from \"fastfile\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport * as utils from \"./zkey_utils.js\";\nimport * as misc from \"./misc.js\";\nimport { applyKeyToChallengeSection } from \"./mpc_applykey.js\";\nimport { hashPubKey } from \"./zkey_utils.js\";\nimport { hashToG2 as hashToG2 } from \"./keypair.js\";\n\nexport default async function bellmanContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const rng = await misc.getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastFile.readExisting(challengeFilename);\n    const fdTo = await fastFile.createOverride(responseFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = blake2b.create({ dkLen: 64 });;\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nContributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        hashPubKey(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    utils.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write Contribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });;\n    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(misc.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6329, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_export_verificationkey.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport {getCurveFromQ as getCurve} from \"./curves.js\";\nimport {utils} from \"ffjavascript\";\nimport {FFLONK_PROTOCOL_ID} from \"./zkey_constants.js\";\n\nconst {stringifyBigInts} = utils;\n\nexport default async function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await binFileUtils.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await zkeyUtils.readHeader(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey, logger);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await getCurve(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await binFileUtils.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await binFileUtils.endReadSection(fd);\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await getCurve(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await getCurve(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts(vKey);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6454, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk_export_solidity_verifier.js"],"sourcesContent":["/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport ejs from \"ejs\";\nimport {getCurveFromName} from \"./curves.js\";\nimport {utils} from \"ffjavascript\";\n\nconst {unstringifyBigInts, stringifyBigInts} = utils;\n\nexport default async function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await getCurveFromName(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs.render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts(str);\n    }\n}\n\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;;;;AAEA,MAAM,EAAC,kBAAkB,EAAE,gBAAgB,EAAC,GAAG,+JAAK;AAErC,eAAe,6BAA6B,EAAE,EAAE,SAAS,EAAE,MAAM;IAC5E,IAAI,QAAQ,OAAO,IAAI,CAAC;IAExB,MAAM,QAAQ,MAAM,IAAA,8JAAgB,EAAC,GAAG,KAAK;IAE7C,iCAAiC;IACjC,IAAI,KAAK,SAAS,GAAG,EAAE;IACvB,GAAG,IAAI,GAAG,OAAO,MAAM,EAAE,CAAC,MAAM,CAAC;IAEjC,IAAI,KAAK,SAAS,GAAG,EAAE;IACvB,GAAG,IAAI,GAAG,OAAO,MAAM,EAAE,CAAC,MAAM,CAAC;IACjC,GAAG,IAAI,GAAG,OAAO,MAAM,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,KAAK;IAEnD,IAAI,KAAK,SAAS,GAAG,EAAE;IACvB,IAAI,MAAM,MAAM,EAAE,CAAC,GAAG;IAEtB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;QACxB,MAAM,MAAM,EAAE,CAAC,GAAG,CAAC,KAAK;QACxB,EAAE,CAAC,QAAQ,EAAE,GAAG,OAAO;IAC3B;IAEA,IAAI,WAAW,SAAS,CAAC,GAAG,QAAQ,CAAC;IAErC,IAAI,QAAQ,OAAO,IAAI,CAAC;IAExB,OAAO,8IAAG,CAAC,MAAM,CAAC,UAAU;;;IAE5B,SAAS,SAAS,GAAG;QACjB,MAAM,MAAM,mBAAmB;QAC/B,OAAO,MAAM,EAAE,CAAC,UAAU,CAAC;IAC/B;IAEA,SAAS,OAAO,GAAG;QACf,MAAM,MAAM,MAAM,EAAE,CAAC,QAAQ,CAAC;QAC9B,OAAO,iBAAiB;IAC5B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 6515, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey_export_solidityverifier.js"],"sourcesContent":["import ejs from \"ejs\";\n\nimport exportVerificationKey from \"./zkey_export_verificationkey.js\";\nimport fflonkExportSolidityVerifierCmd from \"./fflonk_export_solidity_verifier.js\";\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nexport default async function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await exportVerificationKey(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return fflonkExportSolidityVerifierCmd(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs.render(template, verificationKey);\n}\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;;;;AAIe,eAAe,uBAAuB,QAAQ,EAAE,SAAS,EAAE,MAAM;IAE5E,MAAM,kBAAkB,MAAM,IAAA,0KAAqB,EAAC,UAAU;IAE9D,IAAI,aAAa,gBAAgB,QAAQ,EAAE;QACvC,OAAO,IAAA,8KAA+B,EAAC,iBAAiB,WAAW;IACvE;IAEA,IAAI,WAAW,SAAS,CAAC,gBAAgB,QAAQ,CAAC;IAElD,OAAO,8IAAG,CAAC,MAAM,CAAC,UAAU;AAChC","ignoreList":[0]}},
    {"offset": {"line": 6537, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/zkey.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nexport {default as newZKey} from \"./zkey_new.js\";\nexport {default as exportBellman} from \"./zkey_export_bellman.js\";\nexport {default as importBellman} from \"./zkey_import_bellman.js\";\nexport {default as verifyFromR1cs} from \"./zkey_verify_fromr1cs.js\";\nexport {default as verifyFromInit} from \"./zkey_verify_frominit.js\";\nexport {default as contribute} from \"./zkey_contribute.js\";\nexport {default as beacon} from \"./zkey_beacon.js\";\nexport {default as exportJson} from \"./zkey_export_json.js\";\nexport {default as bellmanContribute} from \"./zkey_bellman_contribute.js\";\nexport {default as exportVerificationKey} from \"./zkey_export_verificationkey.js\";\nexport {default as exportSolidityVerifier} from \"./zkey_export_solidityverifier.js\";\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;AAiBA,GAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 6581, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk_setup.js"],"sourcesContent":["/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\nimport {readR1csFd} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {\n    readBinFile,\n    createBinFile,\n    readSection,\n    writeBigInt,\n    startWriteSection,\n    endWriteSection,\n} from \"@iden3/binfileutils\";\nimport { log2  } from \"./misc.js\";\nimport { Scalar, BigBuffer } from \"ffjavascript\";\nimport BigArray from \"./bigarray.js\";\n\n\nexport default async function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await utils.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new BigArray();\n    const plonkAdditions = new BigArray();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = log2(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polynomial is n+5 we need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await startWriteSection(fdZKey, 14);\n    const buffOut = new BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await endWriteSection(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                const val = Fr.neg(linearComb2[s]);\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = val;\n                } else {\n                    res[s] = Fr.add(res[s], val);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]])\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await startWriteSection(fdZKey, sectionNum);\n        await writeP4(Q);\n        await endWriteSection(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is stored in Montgomery. stored = v*R\n            // so when montgomery multiplied by the witness, it's result = v*R*w/R = v*w\n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new BigArray(plonkNVars);\n        const firstPos = new BigArray(plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await startWriteSection(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await endWriteSection(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await startWriteSection(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await endWriteSection(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await startWriteSection(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await writeBigInt(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await writeBigInt(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await endWriteSection(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7121, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/proof.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport class Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof(splitFields = true) {\n        let res = splitFields ? {polynomials: {}, evaluations: {}} : {};\n\n        Object.keys(this.polynomials).forEach(key => {\n            const value = this.curve.G1.toObject(this.polynomials[key]);\n            if(splitFields) {\n                res.polynomials[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            const value = this.curve.Fr.toObject(this.evaluations[key]);\n            if(splitFields) {\n                res.evaluations[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAiBA;;;;AAEO,MAAM;IACT,YAAY,KAAK,EAAE,MAAM,CAAE;QACvB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QAEd,IAAI,CAAC,UAAU;IACnB;IAEA,aAAa;QACT,IAAI,CAAC,WAAW,GAAG,CAAC;QACpB,IAAI,CAAC,WAAW,GAAG,CAAC;IACxB;IAEA,cAAc,GAAG,EAAE,UAAU,EAAE;QAC3B,IAAI,OAAO,IAAI,CAAC,WAAW,EAAE;YACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,uBAAuB,CAAC;QACtE;QACA,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG;IAC5B;IAEA,cAAc,GAAG,EAAE;QACf,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,WAAW,GAAG;YAC5B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,wBAAwB,CAAC;QACvE;QACA,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI;IAChC;IAEA,cAAc,GAAG,EAAE,UAAU,EAAE;QAC3B,IAAI,OAAO,IAAI,CAAC,WAAW,EAAE;YACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,mBAAmB,EAAE,IAAI,uBAAuB,CAAC;QACvE;QACA,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG;IAC5B;IAEA,cAAc,GAAG,EAAE;QACf,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,WAAW,GAAG;YAC5B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,wBAAwB,CAAC;QACvE;QACA,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI;IAChC;IAEA,cAAc,cAAc,IAAI,EAAE;QAC9B,IAAI,MAAM,cAAc;YAAC,aAAa,CAAC;YAAG,aAAa,CAAC;QAAC,IAAI,CAAC;QAE9D,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,CAAA;YAClC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI;YAC1D,IAAG,aAAa;gBACZ,IAAI,WAAW,CAAC,IAAI,GAAG;YAC3B,OAAO;gBACH,GAAG,CAAC,IAAI,GAAG;YACf;QACJ;QAEA,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,CAAA;YAClC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI;YAC1D,IAAG,aAAa;gBACZ,IAAI,WAAW,CAAC,IAAI,GAAG;YAC3B,OAAO;gBACH,GAAG,CAAC,IAAI,GAAG;YACf;QACJ;QAEA,OAAO;IACX;IAEA,gBAAgB,WAAW,EAAE;QACzB,IAAI,CAAC,UAAU;QAEf,OAAO,IAAI,CAAC,YAAY,WAAW,EAAE,OAAO,CAAC,CAAA;YACzC,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,UAAU,CAAC,YAAY,WAAW,CAAC,IAAI;QACjF;QAEA,OAAO,IAAI,CAAC,YAAY,WAAW,EAAE,OAAO,CAAC,CAAA;YACzC,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,UAAU,CAAC,YAAY,WAAW,CAAC,IAAI;QACjF;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7213, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/Keccak256Transcript.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {Scalar} from \"ffjavascript\";\nimport {keccak_256} from \"@noble/hashes/sha3\";\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nexport class Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = Scalar.fromRprBE(keccak_256(buffer));\n        return this.Fr.e(value);\n    }\n}"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;;;AAEA,MAAM,aAAa;AACnB,MAAM,SAAS;AAER,MAAM;IACT,YAAY,KAAK,CAAE;QACf,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;QAClB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;QAElB,IAAI,CAAC,KAAK;IACd;IAEA,QAAQ;QACJ,IAAI,CAAC,IAAI,GAAG,EAAE;IAClB;IAEA,iBAAiB,oBAAoB,EAAE;QACnC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;YAAC,MAAM;YAAY,MAAM;QAAoB;IAChE;IAEA,UAAU,MAAM,EAAE;QACd,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;YAAC,MAAM;YAAQ,MAAM;QAAM;IAC9C;IAEA,eAAe;QACX,IAAG,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACvB,MAAM,IAAI,MAAM;QACpB;QAEA,IAAI,eAAe;QACnB,IAAI,WAAW;QAEf,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA,UAAW,eAAe,QAAQ,IAAI,GAAG,iBAAiB;QAE5E,IAAI,SAAS,IAAI,WAAW,WAAW,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,eAAe,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG;QAClF,IAAI,SAAS;QAEb,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAK;YACvC,IAAI,eAAe,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE;gBAClC,IAAI,CAAC,EAAE,CAAC,iBAAiB,CAAC,QAAQ,QAAQ,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;gBAC3D,UAAU,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG;YAC7B,OAAO;gBACH,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,QAAQ,QAAQ,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;gBACjD,UAAU,IAAI,CAAC,EAAE,CAAC,EAAE;YACxB;QACJ;QAEA,MAAM,QAAQ,gKAAM,CAAC,SAAS,CAAC,IAAA,2LAAU,EAAC;QAC1C,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IACrB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 7287, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/mul_z.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport class MulZ {\n    static getZ1(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n    }\n\n    static getZ2(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n    }\n\n    static getZ3(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n    }\n\n    static mul2(a, b, ap, bp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = a_b;\n\n        let a0 = Fr.add(a_bp, ap_b);\n\n        let a1 = ap_bp;\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n        }\n\n        return [r, rz];\n    }\n\n    static mul3(a, b, c, ap, bp, cp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = Fr.mul(a_b, c);\n\n        let a0 = Fr.mul(ap_b, c);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp));\n\n        let a1 = Fr.mul(ap_bp, c);\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp));\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp));\n\n        rz = a0;\n        if (p) {\n            const a2 = Fr.mul(ap_bp, cp);\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n        }\n\n        return [r, rz];\n    }\n\n    static mul4(a, b, c, d, ap, bp, cp, dp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        const Z3 = this.getZ3(Fr);\n\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        const c_d = Fr.mul(c, d);\n        const c_dp = Fr.mul(c, dp);\n        const cp_d = Fr.mul(cp, d);\n        const cp_dp = Fr.mul(cp, dp);\n\n        r = Fr.mul(a_b, c_d);\n\n        let a0 = Fr.mul(ap_b, c_d);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n        let a1 = Fr.mul(ap_bp, c_d);\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n        let a2 = Fr.mul(a_bp, cp_dp);\n        a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n        let a3 = Fr.mul(ap_bp, cp_dp);\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n            rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n        }\n\n        return [r, rz];\n    }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk_constants.js"],"sourcesContent":["export const ZKEY_PL_NSECTIONS = 13;\n\nexport const ZKEY_PL_HEADER_SECTION = 2;\nexport const ZKEY_PL_ADDITIONS_SECTION = 3;\nexport const ZKEY_PL_A_MAP_SECTION = 4;\nexport const ZKEY_PL_B_MAP_SECTION = 5;\nexport const ZKEY_PL_C_MAP_SECTION = 6;\nexport const ZKEY_PL_QM_SECTION = 7;\nexport const ZKEY_PL_QL_SECTION = 8;\nexport const ZKEY_PL_QR_SECTION = 9;\nexport const ZKEY_PL_QO_SECTION = 10;\nexport const ZKEY_PL_QC_SECTION = 11;\nexport const ZKEY_PL_SIGMA_SECTION = 12;\nexport const ZKEY_PL_LAGRANGE_SECTION = 13;\nexport const ZKEY_PL_PTAU_SECTION = 14;\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAM,oBAAoB;AAE1B,MAAM,yBAAyB;AAC/B,MAAM,4BAA4B;AAClC,MAAM,wBAAwB;AAC9B,MAAM,wBAAwB;AAC9B,MAAM,wBAAwB;AAC9B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,wBAAwB;AAC9B,MAAM,2BAA2B;AACjC,MAAM,uBAAuB","ignoreList":[0]}},
    {"offset": {"line": 7471, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/polynomial/polynomial.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {BigBuffer} from \"ffjavascript\";\n\nexport class Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n\n        let j = 0;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n                j = (j + 1) % m;\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        const upperBound = this.coef.byteLength / this.Fr.n8;\n        for (let i = domainSize; i < upperBound; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8231, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/polynomial/evaluations.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {BigBuffer} from \"ffjavascript\";\n\nexport class Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AAAA;;AAEO,MAAM;IACT,YAAY,WAAW,EAAE,KAAK,EAAE,MAAM,CAAE;QACpC,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;QAClB,IAAI,CAAC,MAAM,GAAG;IAClB;IAEA,aAAa,eAAe,UAAU,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE;QAC9D,MAAM,gBAAgB,IAAI,uMAAS,CAAC,WAAW,MAAM,KAAK,YAAY,MAAM,EAAE,CAAC,EAAE;QACjF,cAAc,GAAG,CAAC,WAAW,IAAI,EAAE;QAEnC,MAAM,cAAc,MAAM,MAAM,EAAE,CAAC,GAAG,CAAC;QAEvC,OAAO,IAAI,YAAY,aAAa,OAAO;IAC/C;IAEA,cAAc,KAAK,EAAE;QACjB,MAAM,OAAO,QAAQ,IAAI,CAAC,EAAE,CAAC,EAAE;QAE/B,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAC1C,MAAM,IAAI,MAAM;QACpB;QAEA,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,EAAE;IAClD;IAEA,SAAS;QACL,IAAI,SAAS,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE;QAC9C,IAAI,WAAW,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG;YAC1D,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,MAAM,QAAQ;YACd,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QACrB;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 8290, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk_prove.js"],"sourcesContent":["/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { Scalar, utils, BigBuffer } from \"ffjavascript\";\nconst {stringifyBigInts} = utils;\nimport { Proof } from \"./proof.js\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { MulZ } from \"./mul_z.js\";\nimport {  ZKEY_PL_HEADER_SECTION,\n    ZKEY_PL_ADDITIONS_SECTION,\n    ZKEY_PL_A_MAP_SECTION,\n    ZKEY_PL_B_MAP_SECTION,\n    ZKEY_PL_C_MAP_SECTION,\n    ZKEY_PL_QM_SECTION,\n    ZKEY_PL_QL_SECTION,\n    ZKEY_PL_QR_SECTION,\n    ZKEY_PL_QO_SECTION,\n    ZKEY_PL_QC_SECTION,\n    ZKEY_PL_SIGMA_SECTION,\n    ZKEY_PL_LAGRANGE_SECTION,\n    ZKEY_PL_PTAU_SECTION,\n} from \"./plonk_constants.js\";\nimport { Polynomial } from \"./polynomial/polynomial.js\";\nimport { Evaluations } from \"./polynomial/evaluations.js\";\n    \nexport default async function plonk16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    // Read witness file\n    if (logger) logger.debug(\"> Reading witness file\");\n    const wtns = await wtnsUtils.readHeader(fdWtns, sectionsWtns);\n\n    // Read zkey file\n    if (logger) logger.debug(\"> Reading zkey file\");\n    const {fd: fdZKey, sections: zkeySections} = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, zkeySections, undefined, options);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const sDomain = zkey.domainSize * n8r;\n\n    if (logger) {\n        logger.debug(\"----------------------------\");\n        logger.debug(\"  PLONK PROVE SETTINGS\");\n        logger.debug(`  Curve:         ${curve.name}`);\n        logger.debug(`  Circuit power: ${zkey.power}`);\n        logger.debug(`  Domain size:   ${zkey.domainSize}`);\n        logger.debug(`  Vars:          ${zkey.nVars}`);\n        logger.debug(`  Public vars:   ${zkey.nPublic}`);\n        logger.debug(`  Constraints:   ${zkey.nConstraints}`);\n        logger.debug(`  Additions:     ${zkey.nAdditions}`);\n        logger.debug(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.debug(\"> Reading witness file data\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, sectionsWtns, 2);\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new BigBuffer(n8r*zkey.nAdditions);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    let challenges = {};\n    let proof = new Proof(curve, logger);\n    const transcript = new Keccak256Transcript(curve);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.debug(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);\n\n    if (logger) logger.debug(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_PTAU_SECTION}. Powers of Tau`);\n    const PTau = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_PTAU_SECTION);\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.debug(\"\");\n    if (logger) logger.debug(\"> ROUND 1\");\n    await round1();\n\n    if (logger) logger.debug(\"> ROUND 2\");\n    await round2();\n\n    if (logger) logger.debug(\"> ROUND 3\");\n    await round3();\n\n    if (logger) logger.debug(\"> ROUND 4\");\n    await round4();\n\n    if (logger) logger.debug(\"> ROUND 5\");\n    await round5();\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    // Prepare proof\n    let _proof = proof.toObjectProof(false);\n    _proof.protocol = \"plonk\";\n    _proof.curve = curve.name;\n    \n    if (logger) logger.debug(\"PLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.debug(\" Computing additions\");\n        const additionsBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + n8r * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.debug(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + n8r);\n            offset += n8r;\n            const factor2 = additionsBuff.slice(offset, offset + n8r);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, n8r * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b1, ..., b11)  F\n        challenges.b = [];\n        for (let i=1; i<=11; i++) {\n            challenges.b[i] = curve.Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.debug(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute [a]_1, [b]_1, [c]_1\n        if (logger) logger.debug(\"> Computing A, B, C MSM\");\n        let commitA = await polynomials.A.multiExponentiation(PTau, \"A\");\n        let commitB = await polynomials.B.multiExponentiation(PTau, \"B\");\n        let commitC = await polynomials.C.multiExponentiation(PTau, \"C\");\n\n        // First output of the prover is ([A]_1, [B]_1, [C]_1)\n        proof.addPolynomial(\"A\", commitA);\n        proof.addPolynomial(\"B\", commitB);\n        proof.addPolynomial(\"C\", commitC);\n\n        return 0;\n    }\n\n    async function computeWirePolynomials() {\n        if (logger) logger.debug(\" Reading data from zkey file\");\n\n        // Build A, B and C evaluations buffer from zkey and witness files\n        buffers.A = new BigBuffer(sDomain);\n        buffers.B = new BigBuffer(sDomain);\n        buffers.C = new BigBuffer(sDomain);\n\n        // Read zkey file to the buffers\n        const aMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_A_MAP_SECTION);\n        const bMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_B_MAP_SECTION);\n        const cMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_PL_C_MAP_SECTION);\n\n        // Compute all witness from signal ids and set them to A,B & C buffers\n        for (let i = 0; i < zkey.nConstraints; i++) {\n            const i_sFr = i * n8r;\n            const offset = i * 4;\n\n            // Compute A value from a signal id\n            const signalIdA = readUInt32(aMapBuff, offset);\n            buffers.A.set(getWitness(signalIdA), i_sFr);\n\n            // Compute B value from a signal id\n            const signalIdB = readUInt32(bMapBuff, offset);\n            buffers.B.set(getWitness(signalIdB), i_sFr);\n\n            // Compute C value from a signal id\n            const signalIdC = readUInt32(cMapBuff, offset);\n            buffers.C.set(getWitness(signalIdC), i_sFr);\n        }\n\n        buffers.A = await Fr.batchToMontgomery(buffers.A);\n        buffers.B = await Fr.batchToMontgomery(buffers.B);\n        buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n        // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n        if (logger) logger.debug(\" Computing A ifft\");\n        polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n        if (logger) logger.debug(\" Computing B ifft\");\n        polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n        if (logger) logger.debug(\" Computing C ifft\");\n        polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n        // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n        if (logger) logger.debug(\" Computing A fft\");\n        evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n        if (logger) logger.debug(\" Computing B fft\");\n        evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n        if (logger) logger.debug(\" Computing C fft\");\n        evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n        // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n        polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);\n        polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);\n        polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);\n\n        // Check degrees\n        if (polynomials.A.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"A Polynomial is not well calculated\");\n        }\n        if (polynomials.B.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"B Polynomial is not well calculated\");\n        }\n        if (polynomials.C.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"C Polynomial is not well calculated\");\n        }        \n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.debug(\"> Computing challenges beta and gamma\");\n        transcript.reset();\n\n        transcript.addPolCommitment(zkey.Qm);\n        transcript.addPolCommitment(zkey.Ql);\n        transcript.addPolCommitment(zkey.Qr);\n        transcript.addPolCommitment(zkey.Qo);\n        transcript.addPolCommitment(zkey.Qc);\n        transcript.addPolCommitment(zkey.S1);\n        transcript.addPolCommitment(zkey.S2);\n        transcript.addPolCommitment(zkey.S3);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * n8r, i * n8r + n8r));\n        }\n\n        // Add A, B, C to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"A\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"B\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"C\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.beta: \" + Fr.toString(challenges.beta, 16));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.gamma: \" + Fr.toString(challenges.gamma, 16));\n    \n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.debug(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute permutation [z]_1\n        if (logger) logger.debug(\"> Computing Z MSM\");\n        let commitZ = await polynomials.Z.multiExponentiation(PTau, \"Z\");\n\n        // Second output of the prover is ([Z]_1)\n        proof.addPolynomial(\"Z\", commitZ);\n    }\n\n    async function computeZ() {\n        if (logger) logger.debug(\" Computing Z evaluations\");\n\n        let numArr = new BigBuffer(sDomain);\n        let denArr = new BigBuffer(sDomain);\n\n        // Set the first values to 1\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        // Set initial omega\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_n8r = i * n8r;\n            \n            const a = buffers.A.slice(i_n8r, i_n8r + n8r);\n            const b = buffers.B.slice(i_n8r, i_n8r + n8r);\n            const c = buffers.C.slice(i_n8r, i_n8r + n8r);\n\n            // Z(X) := numArr / denArr\n            // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n            const betaw = Fr.mul(challenges.beta, w);\n\n            let n1 = Fr.add(a, betaw);\n            n1 = Fr.add(n1, challenges.gamma);\n\n            let n2 = Fr.add(b, Fr.mul(zkey.k1, betaw));\n            n2 = Fr.add(n2, challenges.gamma);\n\n            let n3 = Fr.add(c, Fr.mul(zkey.k2, betaw));\n            n3 = Fr.add(n3, challenges.gamma);\n\n            let num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n            let d1 = Fr.add(a, Fr.mul(evaluations.Sigma1.getEvaluation(i * 4), challenges.beta));\n            d1 = Fr.add(d1, challenges.gamma);\n\n            let d2 = Fr.add(b, Fr.mul(evaluations.Sigma2.getEvaluation(i * 4), challenges.beta));\n            d2 = Fr.add(d2, challenges.gamma);\n\n            let d3 = Fr.add(c, Fr.mul(evaluations.Sigma3.getEvaluation(i * 4), challenges.beta));\n            d3 = Fr.add(d3, challenges.gamma);\n\n            let den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            // Multiply current num value with the previous one saved in numArr\n            num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);\n            numArr.set(num, ((i + 1) % zkey.domainSize) * n8r);\n\n            // Multiply current den value with the previous one saved in denArr\n            den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);\n            denArr.set(den, ((i + 1) % zkey.domainSize) * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        // Compute the inverse of denArr to compute in the next command the\n        // division numArr/denArr by multiplying num  1/denArr\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        // Multiply numArr  denArr where denArr was inverted in the previous command\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_sFr = i * n8r;\n\n            const z = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));\n            numArr.set(z, i_sFr);\n        }\n\n        // From now on the values saved on numArr will be Z(X) buffer\n        buffers.Z = numArr;\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        // Compute polynomial coefficients z(X) from buffers.Z\n        if (logger) logger.debug(\" Computing Z ifft\");\n        polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n        // Compute extended evaluations of z(X) polynomial\n        if (logger) logger.debug(\" Computing Z fft\");\n        evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n        // Blind z(X) polynomial coefficients with blinding scalars b\n        polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n        // Check degree\n        if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n            throw new Error(\"Z Polynomial is not well calculated\");\n        }\n\n        delete buffers.Z;\n    }\n\n    async function round3() {\n        if (logger) logger.debug(\"> Computing challenge alpha\");\n\n        // STEP 3.1 - Compute evaluation challenge alpha  F\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"Z\"));\n\n        challenges.alpha = transcript.getChallenge();\n        challenges.alpha2 = Fr.square(challenges.alpha);\n        if (logger) logger.debug(\" challenges.alpha: \" + Fr.toString(challenges.alpha, 16));\n\n        // Compute quotient polynomial T(X)\n        if (logger) logger.debug(\"> Computing T polynomial\");\n        await computeT();\n\n        // Compute [T1]_1, [T2]_1, [T3]_1\n        if (logger) logger.debug(\"> Computing T MSM\");\n        let commitT1 = await polynomials.T1.multiExponentiation(PTau, \"T1\");\n        let commitT2 = await polynomials.T2.multiExponentiation(PTau, \"T2\");\n        let commitT3 = await polynomials.T3.multiExponentiation(PTau, \"T3\");\n\n        // Third output of the prover is ([T1]_1, [T2]_1, [T3]_1)\n        proof.addPolynomial(\"T1\", commitT1);\n        proof.addPolynomial(\"T2\", commitT2);\n        proof.addPolynomial(\"T3\", commitT3);        \n    }\n\n    async function computeT() {\n        if (logger)\n            logger.debug(` Reading sections ${ZKEY_PL_QL_SECTION}, ${ZKEY_PL_QR_SECTION}` +\n                `, ${ZKEY_PL_QM_SECTION}, ${ZKEY_PL_QO_SECTION}, ${ZKEY_PL_QC_SECTION}. Q selectors`);\n        // Reserve memory for Q's evaluations\n        evaluations.QL = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QR = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QM = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QO = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QC = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QL_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QR_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QM_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QO_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QC_SECTION][0].p + sDomain);\n\n        // Read Lagrange polynomials & evaluations from zkey file\n        evaluations.Lagrange = new Evaluations(new BigBuffer(sDomain * 4 * zkey.nPublic), curve, logger);\n\n        for (let i = 0; i < zkey.nPublic; i++) {\n            await fdZKey.readToBuffer(evaluations.Lagrange.eval, i * sDomain * 4, sDomain * 4, zkeySections[ZKEY_PL_LAGRANGE_SECTION][0].p + i * 5 * sDomain + sDomain);\n        }\n\n        buffers.T = new BigBuffer(sDomain * 4);\n        buffers.Tz = new BigBuffer(sDomain * 4);\n\n        if (logger) logger.debug(\" Computing T evaluations\");\n\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize * 4; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0))\n                logger.debug(`      T evaluation ${i}/${zkey.domainSize * 4}`);\n\n            const a = evaluations.A.getEvaluation(i);\n            const b = evaluations.B.getEvaluation(i);\n            const c = evaluations.C.getEvaluation(i);\n            const z = evaluations.Z.getEvaluation(i);\n            const zw = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n            const qm = evaluations.QM.getEvaluation(i);\n            const ql = evaluations.QL.getEvaluation(i);\n            const qr = evaluations.QR.getEvaluation(i);\n            const qo = evaluations.QO.getEvaluation(i);\n            const qc = evaluations.QC.getEvaluation(i);\n            const s1 = evaluations.Sigma1.getEvaluation(i);\n            const s2 = evaluations.Sigma2.getEvaluation(i);\n            const s3 = evaluations.Sigma3.getEvaluation(i);\n\n            const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w));\n            const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w));\n            const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w));\n\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w2), Fr.mul(challenges.b[8], w)), challenges.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);\n\n            let pi = Fr.zero;\n            for (let j = 0; j < zkey.nPublic; j++) {\n                const offset = (j * 4 * zkey.domainSize) + i;\n\n                const lPol = evaluations.Lagrange.getEvaluation(offset);\n                const aVal = buffers.A.slice(j * n8r, (j + 1) * n8r);\n\n                pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n            }\n\n            // e1 := a(X)b(X)qM(X) + a(X)qL(X) + b(X)qR(X) + c(X)qO(X) + PI(X) + qC(X)\n            let [e1, e1z] = MulZ.mul2(a, b, ap, bp, i % 4, Fr);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pi);\n            e1 = Fr.add(e1, qc);\n\n            // e2 := [(a(X) + X + )(b(X) + k1X + )(c(X) + k2X + )z(X)]\n            const betaw = Fr.mul(challenges.beta, w);\n            let e2a = a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, challenges.gamma);\n\n            let e2b = b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, challenges.gamma);\n\n            let e2c = c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, challenges.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i % 4, Fr);\n            e2 = Fr.mul(e2, challenges.alpha);\n            e2z = Fr.mul(e2z, challenges.alpha);\n\n            // e3 := [(a(X) + S1(X) + )(b(X) + S2(X) + )(c(X) + S3(X) + )z(X)]\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));\n            e3a = Fr.add(e3a, challenges.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));\n            e3b = Fr.add(e3b, challenges.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));\n            e3c = Fr.add(e3c, challenges.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i % 4, Fr);\n\n            e3 = Fr.mul(e3, challenges.alpha);\n            e3z = Fr.mul(e3z, challenges.alpha);\n\n            // e4 := ^2(z(X)1)L1(X)\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i));\n            e4 = Fr.mul(e4, challenges.alpha2);\n\n            let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i));\n            e4z = Fr.mul(e4z, challenges.alpha2);\n\n\n            let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            buffers.T.set(t, i * n8r);\n            buffers.Tz.set(tz, i * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power + 2]);\n        }\n\n        // Compute the coefficients of the polynomial T0(X) from buffers.T0\n        if (logger)\n            logger.debug(\" Computing T ifft\");\n        polynomials.T = await Polynomial.fromEvaluations(buffers.T, curve, logger);\n\n        // Divide the polynomial T0 by Z_H(X)\n        if (logger)\n            logger.debug(\" Computing T / ZH\");\n        polynomials.T.divZh(zkey.domainSize, 4);\n\n        // Compute the coefficients of the polynomial Tz(X) from buffers.Tz\n        if (logger)\n            logger.debug(\" Computing Tz ifft\");\n        polynomials.Tz = await Polynomial.fromEvaluations(buffers.Tz, curve, logger);\n\n        // Add the polynomial T1z to T1 to get the final polynomial T1\n        polynomials.T.add(polynomials.Tz);\n\n        // Check degree\n        if (polynomials.T.degree() >= zkey.domainSize * 3 + 6) {\n            throw new Error(\"T Polynomial is not well calculated\");\n        }\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // T1' and T2'  with a degree < n and T3' with a degree n+5\n        // such that t(x) = T1'(X) + X^n T2'(X) + X^{2n} T3'(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // T1(X) = T1'(X) + b_10 X^n\n        // T2(X) = T2'(X) - b_10 + b_11 X^n\n        // T3(X) = T3'(X) - b_11\n        // such that\n        // t(X) = T1(X) + X^n T2(X) + X^2n T3(X)\n        if (logger) logger.debug(\" Computing T1, T2, T3 polynomials\");\n        polynomials.T1 = new Polynomial(new BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T2 = new Polynomial(new BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T3 = new Polynomial(new BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);\n        polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);\n        polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);\n\n        // Add blinding scalar b_10 as a new coefficient n\n        polynomials.T1.setCoef(zkey.domainSize, challenges.b[10]);\n\n        // compute t_mid(X)\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);\n        polynomials.T2.setCoef(0, lowestMid);\n        polynomials.T2.setCoef(zkey.domainSize, challenges.b[11]);\n\n        // compute t_high(X)\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);\n        polynomials.T3.setCoef(0, lowestHigh);\n    }\n\n    async function round4() {\n        if (logger) logger.debug(\"> Computing challenge xi\");\n\n        // STEP 4.1 - Compute evaluation challenge xi  F\n        transcript.reset();\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"T1\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T2\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T3\"));\n\n        challenges.xi = transcript.getChallenge();\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        \n        if (logger) logger.debug(\" challenges.xi: \" + Fr.toString(challenges.xi, 16));  \n\n        // Fourth output of the prover is ( a(xi), b(xi), c(xi), s1(xi), s2(xi), z(xiw) )\n        proof.addEvaluation(\"eval_a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_zw\", polynomials.Z.evaluate(challenges.xiw));\n    }\n\n    async function round5() {\n        if (logger) logger.debug(\"> Computing challenge v\");\n        \n        // STEP 5.1 - Compute evaluation challenge v  F\n        transcript.reset();\n        transcript.addScalar(challenges.xi);\n        transcript.addScalar(proof.getEvaluation(\"eval_a\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_b\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_c\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s1\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s2\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_zw\"));\n\n        challenges.v = [];\n        challenges.v[1] = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.v: \" + Fr.toString(challenges.v[1], 16));\n\n        for (let i = 2; i < 6; i++) {\n            challenges.v[i] = Fr.mul(challenges.v[i - 1], challenges.v[1]);\n        }\n\n        // STEP 5.2 Compute linearisation polynomial r(X)\n        if (logger) logger.debug(\"> Computing linearisation polynomial R(X)\");\n        await computeR();\n\n        //STEP 5.3 Compute opening proof polynomial Wxi(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxi(X) polynomial\");\n        computeWxi();\n\n        //STEP 5.4 Compute opening proof polynomial Wxiw(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxiw(X) polynomial\");\n        computeWxiw();\n\n        if (logger) logger.debug(\"> Computing Wxi, Wxiw MSM\");\n        let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, \"Wxi\");\n        let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, \"Wxiw\");\n\n        // Fifth output of the prover is ([Wxi]_1, [Wxiw]_1)\n        proof.addPolynomial(\"Wxi\", commitWxi);\n        proof.addPolynomial(\"Wxiw\", commitWxiw);\n    }\n\n    async function computeR() {\n        const Fr = curve.Fr;\n    \n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_PL_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_PL_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_PL_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_PL_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_PL_QC_SECTION][0].p);   \n        \n        challenges.xin = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            challenges.xin = Fr.square(challenges.xin);\n        }\n\n        challenges.zh = Fr.sub(challenges.xin, Fr.one);\n\n        const L = [];\n\n        const n = Fr.e(zkey.domainSize);\n        let w = Fr.one;\n        for (let i = 1; i <= Math.max(1, zkey.nPublic); i++) {\n            L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        const eval_l1 = Fr.div(\n            Fr.sub(challenges.xin, Fr.one),\n            Fr.mul(n, Fr.sub(challenges.xi, Fr.one))\n        );\n\n        if (logger) {\n            logger.debug(\"Lagrange Evaluations: \");\n            for (let i=1; i<L.length; i++) {\n                logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n            }\n        }\n\n        let eval_pi = Fr.zero;\n        for (let i=0; i<publicSignals.length; i++) {\n            const w = Fr.e(publicSignals[i]);\n            eval_pi = Fr.sub(eval_pi, Fr.mul(w, L[i+1]));\n        }\n\n        if (logger) logger.debug(\"PI: \" + Fr.toString(eval_pi, 16));\n\n        // Compute constant parts of R(X)\n        const coef_ab = Fr.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);\n\n        let e2a = proof.evaluations.eval_a;\n        const betaxi = Fr.mul(challenges.beta, challenges.xi);\n        e2a = Fr.add(e2a, betaxi);\n        e2a = Fr.add(e2a, challenges.gamma);\n\n        let e2b = proof.evaluations.eval_b;\n        e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add(e2b, challenges.gamma);\n\n        let e2c = proof.evaluations.eval_c;\n        e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add(e2c, challenges.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), challenges.alpha);\n\n        let e3a = proof.evaluations.eval_a;\n        e3a = Fr.add(e3a, Fr.mul(challenges.beta, proof.evaluations.eval_s1));\n        e3a = Fr.add(e3a, challenges.gamma);\n\n        let e3b = proof.evaluations.eval_b;\n        e3b = Fr.add(e3b, Fr.mul(challenges.beta, proof.evaluations.eval_s2));\n        e3b = Fr.add(e3b, challenges.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, proof.evaluations.eval_zw);\n        e3 = Fr.mul(e3, challenges.alpha);\n\n        const e4 = Fr.mul(eval_l1, challenges.alpha2);\n\n        polynomials.R = new Polynomial(new BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.R.add(polynomials.QM, coef_ab);\n        polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);\n        polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);\n        polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);\n        polynomials.R.add(polynomials.QC);\n        polynomials.R.add(polynomials.Z, e2);\n        polynomials.R.sub(polynomials.Sigma3, Fr.mul(e3, challenges.beta));\n        polynomials.R.add(polynomials.Z, e4);\n\n        let tmp = Polynomial.fromPolynomial(polynomials.T3, curve, logger);\n        tmp.mulScalar(Fr.square(challenges.xin));\n        tmp.add(polynomials.T2, challenges.xin);\n        tmp.add(polynomials.T1);\n        tmp.mulScalar(challenges.zh);\n\n        polynomials.R.sub(tmp);\n\n        let r0 = Fr.sub(eval_pi, Fr.mul(e3, Fr.add(proof.evaluations.eval_c, challenges.gamma)));\n        r0 = Fr.sub(r0, e4);\n\n        if (logger) logger.debug(\"r0: \" + Fr.toString(r0, 16));\n\n        polynomials.R.addScalar(r0);\n    }\n\n    function computeWxi() {\n        polynomials.Wxi = new Polynomial(new BigBuffer(sDomain + 6 * n8r), curve, logger);\n\n        polynomials.Wxi.add(polynomials.R);\n        polynomials.Wxi.add(polynomials.A, challenges.v[1]);\n        polynomials.Wxi.add(polynomials.B, challenges.v[2]);\n        polynomials.Wxi.add(polynomials.C, challenges.v[3]);\n        polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);\n        polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);\n\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));\n\n        polynomials.Wxi.divByZerofier(1, challenges.xi);\n    }\n\n    async function computeWxiw() {\n        polynomials.Wxiw = Polynomial.fromPolynomial(polynomials.Z, curve, logger);\n        polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);\n\n        polynomials.Wxiw.divByZerofier(1, challenges.xiw);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8996, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk_fullprove.js"],"sourcesContent":["/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport plonk_prove from \"./plonk_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function plonkFullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtns_calculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await plonk_prove(zkeyFileName, wtns, logger, proverOptions);\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;;;;AACA,MAAM,EAAC,kBAAkB,EAAC,GAAG,+JAAK;AAEnB,eAAe,eAAe,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,EAAE,eAAe,EAAE,aAAa;IAC/G,MAAM,QAAQ,mBAAmB;IAEjC,MAAM,OAAM;QACR,MAAM;IACV;IACA,MAAM,IAAA,6JAAc,EAAC,OAAO,UAAU,MAAM;IAC5C,OAAO,MAAM,IAAA,0JAAW,EAAC,cAAc,MAAM,QAAQ;AACzD","ignoreList":[0]}},
    {"offset": {"line": 9036, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk_verify.js"],"sourcesContent":["/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\nimport * as curves from \"./curves.js\";\nimport { utils }   from \"ffjavascript\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { Scalar } from \"ffjavascript\";\n\nconst { unstringifyBigInts } = utils;\n\nexport default async function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n    let publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await curves.getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    if (logger) logger.info(\"PLONK VERIFIER STARTED\");\n\n    let proof = fromObjectProof(curve,_proof);\n    vk_verifier = fromObjectVk(curve, vk_verifier);\n\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    if (publicSignals.length != vk_verifier.nPublic) {\n        if (logger) logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid\");\n        return false;\n    }\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    const challenges = calculatechallenges(curve, proof, publicSignals, vk_verifier);\n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challenges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challenges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challenges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challenges.xi, 16));\n        for(let i=1;i<6;i++) {\n            if (logger) logger.debug(\"v: \" + Fr.toString(challenges.v[i], 16));\n        }\n        logger.debug(\"u: \" + Fr.toString(challenges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challenges, vk_verifier);\n    if (logger) {\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));\n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pi = calculatePI(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"PI(xi): \" + Fr.toString(pi, 16));\n    }\n    \n    const r0 = calculateR0(curve, proof, challenges, pi, L[1]);\n    if (logger) {\n        logger.debug(\"r0: \" + Fr.toString(r0, 16));\n    }\n\n    const D = calculateD(curve, proof, challenges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challenges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challenges, r0);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing(curve, proof, challenges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return Scalar.geq(value, 0) && Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.eval_a)\n        && checkEvaluationIsValid(curve, proof.eval_b)\n        && checkEvaluationIsValid(curve, proof.eval_c)\n        && checkEvaluationIsValid(curve, proof.eval_s1)\n        && checkEvaluationIsValid(curve, proof.eval_s2)\n        && checkEvaluationIsValid(curve, proof.eval_zw);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction calculatechallenges(curve, proof, publicSignals, vk) {\n    const Fr = curve.Fr;\n    const res = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Challenge round 2: beta and gamma\n    transcript.addPolCommitment(vk.Qm);\n    transcript.addPolCommitment(vk.Ql);\n    transcript.addPolCommitment(vk.Qr);\n    transcript.addPolCommitment(vk.Qo);\n    transcript.addPolCommitment(vk.Qc);\n    transcript.addPolCommitment(vk.S1);\n    transcript.addPolCommitment(vk.S2);\n    transcript.addPolCommitment(vk.S3);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.A);\n    transcript.addPolCommitment(proof.B);\n    transcript.addPolCommitment(proof.C);\n\n    res.beta = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    res.gamma = transcript.getChallenge();\n\n    // Challenge round 3: alpha\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    transcript.addScalar(res.gamma);\n    transcript.addPolCommitment(proof.Z);\n    res.alpha = transcript.getChallenge();\n\n    // Challenge round 4: xi\n    transcript.reset();\n    transcript.addScalar(res.alpha);\n    transcript.addPolCommitment(proof.T1);\n    transcript.addPolCommitment(proof.T2);\n    transcript.addPolCommitment(proof.T3);\n    res.xi = transcript.getChallenge();\n    \n    // Challenge round 5: v\n    transcript.reset();\n    transcript.addScalar(res.xi);\n    transcript.addScalar(proof.eval_a);\n    transcript.addScalar(proof.eval_b);\n    transcript.addScalar(proof.eval_c);\n    transcript.addScalar(proof.eval_s1);\n    transcript.addScalar(proof.eval_s2);\n    transcript.addScalar(proof.eval_zw);\n    res.v = [];\n    res.v[1] = transcript.getChallenge();\n\n    for (let i=2; i<6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    // Challenge: u\n    transcript.reset();\n    transcript.addPolCommitment(proof.Wxi);\n    transcript.addPolCommitment(proof.Wxiw);\n    res.u = transcript.getChallenge();\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challenges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challenges.xin = xin;\n\n    challenges.zh = Fr.sub(xin, Fr.one);\n\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {        \n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, L[i+1]));\n    }\n    return pi;\n}\n\nfunction calculateR0(curve, proof, challenges, pi, l1) {\n    const Fr = curve.Fr;\n\n    const e1 = pi;\n\n    const e2 = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));\n    e3a = Fr.add(e3a, challenges.gamma);\n\n    let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));\n    e3b = Fr.add(e3b, challenges.gamma);\n\n    let e3c = Fr.add(proof.eval_c, challenges.gamma);\n\n    let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);\n    e3 = Fr.mul(e3, proof.eval_zw);\n    e3 = Fr.mul(e3, challenges.alpha);\n\n    const r0 = Fr.sub(Fr.sub(e1, e2), e3);\n\n    return r0;\n}\n\nfunction calculateD(curve, proof, challenges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    \n    let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));\n    d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));\n    d1 = G1.add(d1, vk.Qc);\n\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n\n    const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);\n    const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);\n    const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);\n\n    const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);\n\n    const d2b = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));\n\n    const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);\n    const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);\n    const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);\n\n    const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));\n    \n    const d4low = proof.T1;\n    const d4mid = G1.timesFr(proof.T2, challenges.xin);\n    const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));\n    let d4 = G1.add(d4low, G1.add(d4mid, d4high));\n    d4 = G1.timesFr(d4, challenges.zh);\n\n    const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);\n\n    return d;\n}\n\nfunction calculateF(curve, proof, challenges, vk, D) {\n    const G1 = curve.G1;\n\n    let res = G1.add(D, G1.timesFr(proof.A, challenges.v[1]));\n    res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));\n    res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));\n\n    return res;\n}\n\nfunction calculateE(curve, proof, challenges, r0) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let e = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));\n    e = Fr.add(e, Fr.mul(challenges.v[2], proof.eval_b));\n    e = Fr.add(e, Fr.mul(challenges.v[3], proof.eval_c));\n    e = Fr.add(e, Fr.mul(challenges.v[4], proof.eval_s1));\n    e = Fr.add(e, Fr.mul(challenges.v[5], proof.eval_s2));\n    e = Fr.add(e, Fr.mul(challenges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, e);\n\n    return res;\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challenges.xi);\n    const s = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9374, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk_exportsoliditycalldata.js"],"sourcesContent":["/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport { getCurveFromName } from \"./curves.js\";\nimport {  utils }   from \"ffjavascript\";\nconst { unstringifyBigInts} = utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nexport default async function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await getCurveFromName(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.A[0])}, ${p256(proof.A[1])},` +\n    `${p256(proof.B[0])},${p256(proof.B[1])},` +\n    `${p256(proof.C[0])},${p256(proof.C[1])},` +\n    `${p256(proof.Z[0])},${p256(proof.Z[1])},` +\n    `${p256(proof.T1[0])},${p256(proof.T1[1])},` +\n    `${p256(proof.T2[0])},${p256(proof.T2[1])},` +\n    `${p256(proof.T3[0])},${p256(proof.T3[1])},` +\n    `${p256(proof.Wxi[0])},${p256(proof.Wxi[1])},` +\n    `${p256(proof.Wxiw[0])},${p256(proof.Wxiw[1])},` +\n    `${p256(proof.eval_a)},` + \n    `${p256(proof.eval_b)},` + \n    `${p256(proof.eval_c)},` + \n    `${p256(proof.eval_s1)},` + \n    `${p256(proof.eval_s2)},` + \n    `${p256(proof.eval_zw)}]` + \n    `[${inputs}]`;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;;;AACA,MAAM,EAAE,kBAAkB,EAAC,GAAG,+JAAK;AAEnC,SAAS,MAAM,CAAC;IACZ,OAAO,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AACzC;AAEA,SAAS,KAAK,CAAC;IACX,IAAI,OAAO,EAAE,QAAQ,CAAC;IACtB,MAAO,KAAK,MAAM,GAAG,GAAI,OAAO,MAAI;IACpC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IACpB,OAAO;AACX;AAEe,eAAe,4BAA4B,MAAM,EAAE,IAAI;IAClE,MAAM,QAAQ,mBAAmB;IACjC,MAAM,MAAM,mBAAmB;IAE/B,MAAM,QAAQ,MAAM,IAAA,8JAAgB,EAAC,MAAM,KAAK;IAChD,MAAM,KAAK,MAAM,EAAE;IACnB,MAAM,KAAK,MAAM,EAAE;IAEnB,IAAI,SAAS;IACb,IAAK,IAAI,IAAE,GAAG,IAAE,IAAI,MAAM,EAAE,IAAK;QAC7B,IAAI,UAAU,IAAI,SAAS,SAAS;QACpC,SAAS,SAAS,KAAK,GAAG,CAAC,EAAE;IACjC;IAEA,OAAO,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,GACnD,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,GAC1C,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,GAC1C,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,GAC1C,GAAG,KAAK,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAC5C,GAAG,KAAK,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAC5C,GAAG,KAAK,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAC5C,GAAG,KAAK,MAAM,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC,GAC9C,GAAG,KAAK,MAAM,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,GAChD,GAAG,KAAK,MAAM,MAAM,EAAE,CAAC,CAAC,GACxB,GAAG,KAAK,MAAM,MAAM,EAAE,CAAC,CAAC,GACxB,GAAG,KAAK,MAAM,MAAM,EAAE,CAAC,CAAC,GACxB,GAAG,KAAK,MAAM,OAAO,EAAE,CAAC,CAAC,GACzB,GAAG,KAAK,MAAM,OAAO,EAAE,CAAC,CAAC,GACzB,GAAG,KAAK,MAAM,OAAO,EAAE,CAAC,CAAC,GACzB,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;AACjB","ignoreList":[0]}},
    {"offset": {"line": 9426, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk.js"],"sourcesContent":["/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// ZKEY constants\nexport {default as setup} from \"./plonk_setup.js\";\nexport {default as fullProve} from \"./plonk_fullprove.js\";\nexport {default as prove} from \"./plonk_prove.js\";\nexport {default as verify} from \"./plonk_verify.js\";\nexport {default as exportSolidityCallData} from \"./plonk_exportsoliditycalldata.js\";\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 9459, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/plonk_equation.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nexport function getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nexport function getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nexport function getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA,iFAAiF;AAEjF,8CAA8C;AAC9C,yCAAyC;;;;;;;;;AAElC,SAAS,4BAA4B,OAAO,EAAE,EAAE;IACnD,OAAO;QAAC;QAAS;QAAG;QAAG,GAAG,GAAG;QAAE,GAAG,IAAI;QAAE,GAAG,IAAI;QAAE,GAAG,IAAI;QAAE,GAAG,IAAI;KAAC;AACtE;AAEO,SAAS,4BAA4B,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;IACvF,OAAO;QAAC;QAAS;QAAS;QAAW;QAAI;QAAI;QAAI;QAAI;KAAG;AAC5D;AAEO,SAAS,kCAAkC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;IACjG,OAAO;QAAC;QAAS;QAAS;QAAW;QAAI;QAAI;QAAI;QAAI;KAAG;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 9527, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/r1cs_constraint_processor.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nexport class r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            const val = this.Fr.neg(linCom2[s]);\n            if (typeof res[s] == \"undefined\") {\n                res[s] = val;\n            } else {\n                res[s] = this.Fr.add(res[s], val);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA,MAAM,8BAA8B;AACpC,MAAM,8BAA8B;AACpC,MAAM,8BAA8B;AAE7B,MAAM;IACT,YAAY,EAAE,EAAE,uBAAuB,EAAE,uBAAuB,EAAE,6BAA6B,EAAE,MAAM,CAAE;QACrG,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,uBAAuB,GAAG;QAC/B,IAAI,CAAC,6BAA6B,GAAG;IACzC;IAEA,sBAAsB,QAAQ,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;QAC3C,IAAI,CAAC,0BAA0B,CAAC;QAChC,IAAI,CAAC,0BAA0B,CAAC;QAChC,IAAI,CAAC,0BAA0B,CAAC;QAEhC,MAAM,OAAO,IAAI,CAAC,wBAAwB,CAAC;QAC3C,MAAM,OAAO,IAAI,CAAC,wBAAwB,CAAC;QAE3C,IAAI,AAAC,SAAS,+BAAiC,SAAS,6BAA8B;YAClF,OAAO,IAAI,CAAC,6BAA6B,CAAC,UAAU;QACxD,OAAO,IAAI,SAAS,6BAA6B;YAC7C,MAAM,OAAO,IAAI,CAAC,sBAAsB,CAAC,KAAK,KAAK,GAAG,CAAC,EAAE;YACzD,OAAO,IAAI,CAAC,6BAA6B,CAAC,UAAU;QACxD,OAAO,IAAI,SAAS,6BAA6B;YAC7C,MAAM,OAAO,IAAI,CAAC,sBAAsB,CAAC,KAAK,KAAK,GAAG,CAAC,EAAE;YACzD,OAAO,IAAI,CAAC,6BAA6B,CAAC,UAAU;QACxD,OAAO;YACH,OAAO,IAAI,CAAC,mCAAmC,CAAC,UAAU,KAAK,KAAK;QACxE;IACJ;IAEA,yBAAyB,MAAM,EAAE;QAC7B,wBAAwB;QACxB,EAAE;QACF,yCAAyC;QACzC,+CAA+C;QAC/C,kCAAkC;QAClC,oDAAoD;QACpD,eAAe;QACf,8CAA8C;QAC9C,QAAQ;QACR,IAAI;QACJ,EAAE;QACF,wEAAwE;QACxE,EAAE;QACF,sCAAsC;QAEtC,IAAI,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI;QACpB,IAAI,IAAI;QACR,MAAM,KAAK,OAAO,IAAI,CAAC;QACvB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,MAAM,EAAE,IAAK;YAChC,IAAI,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE;gBACrB,OAAO,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC;YACxB,OAAO,IAAI,EAAE,CAAC,EAAE,IAAI,GAAG;gBACnB,IAAI,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC;YACpC,OAAO;gBACH;YACJ;QACJ;QACA,IAAI,IAAI,GAAG,OAAO;QAClB,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,OAAO;QAC/B,OAAO;IACX;IAEA,2BAA2B,MAAM,EAAE;QAC/B,MAAM,YAAY,OAAO,IAAI,CAAC;QAC9B,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;YACvC,IAAI,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,OAAO,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;QACzE;QAEA,OAAO;IACX;IAEA,uBAAuB,OAAO,EAAE,OAAO,EAAE,CAAC,EAAE;QACxC,MAAM,MAAM,CAAC;QAEb,IAAK,IAAI,KAAK,QAAS;YACnB,IAAI,OAAO,GAAG,CAAC,EAAE,IAAI,aAAa;gBAC9B,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,EAAE;YACtC,OAAO;gBACH,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,EAAE;YAC1D;QACJ;QAEA,IAAK,IAAI,KAAK,QAAS;YACnB,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YAClC,IAAI,OAAO,GAAG,CAAC,EAAE,IAAI,aAAa;gBAC9B,GAAG,CAAC,EAAE,GAAG;YACb,OAAO;gBACH,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE;YACjC;QACJ;QAEA,OAAO,IAAI,CAAC,0BAA0B,CAAC;IAC3C;IAEA,YAAY,QAAQ,EAAE,cAAc,EAAE,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE;QAC9D,MAAM,MAAM;YACR,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI;YACf,SAAS,EAAE;YACX,OAAO,EAAE;QACb;QACA,MAAM,KAAK,EAAE;QAEb,IAAK,IAAI,YAAY,OAAQ;YACzB,IAAI,YAAY,GAAG;gBACf,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,SAAS;YAC/C,OAAO,IAAI,MAAM,CAAC,SAAS,IAAI,EAAE,EAAE;gBAC/B,GAAG,IAAI,CAAC;oBAAC,OAAO;oBAAW,MAAM,CAAC,SAAS;iBAAC;YAChD;QACJ;QAEA,MAAO,GAAG,MAAM,GAAG,KAAM;YACrB,MAAM,KAAK,GAAG,KAAK;YACnB,MAAM,KAAK,GAAG,KAAK;YACnB,MAAM,KAAK,SAAS,KAAK;YAEzB,MAAM,cAAc,IAAI,CAAC,uBAAuB,CAC5C,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,IACd,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI;YAEnF,eAAe,IAAI,CAAC;YACpB,aAAa,IAAI,CAAC;gBAAC,EAAE,CAAC,EAAE;gBAAE,EAAE,CAAC,EAAE;gBAAE,EAAE,CAAC,EAAE;gBAAE,EAAE,CAAC,EAAE;aAAC;YAE9C,GAAG,IAAI,CAAC;gBAAC;gBAAI,IAAI,CAAC,EAAE,CAAC,GAAG;aAAC;QAC7B;QAEA,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,MAAM,EAAE,IAAK;YAChC,IAAI,OAAO,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE;YACzB,IAAI,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE;QAC3B;QAEA,MAAO,IAAI,KAAK,CAAC,MAAM,GAAG,KAAM;YAC5B,IAAI,OAAO,CAAC,IAAI,CAAC;YACjB,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;QAC/B;QAEA,OAAO;IACX;IAEA,8BAA8B,QAAQ,EAAE,MAAM,EAAE;QAC5C,MAAM,iBAAiB,EAAE;QACzB,MAAM,eAAe,EAAE;QAEvB,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,gBAAgB,cAAc,QAAQ;QAE3E,MAAM,cAAc,IAAI,CAAC,uBAAuB,CAC5C,EAAE,OAAO,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,EAAE,EACxC,EAAE,KAAK,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;QAEzD,eAAe,IAAI,CAAC;QAEpB,OAAO;YAAC;YAAgB;SAAa;IACzC;IAEA,oCAAoC,QAAQ,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;QACzD,MAAM,iBAAiB,EAAE;QACzB,MAAM,eAAe,EAAE;QAEvB,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,gBAAgB,cAAc,KAAK;QACxE,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,gBAAgB,cAAc,KAAK;QACxE,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,gBAAgB,cAAc,KAAK;QAExE,MAAM,cAAc,IAAI,CAAC,6BAA6B,CAClD,EAAE,OAAO,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,EAAE,EACxC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,GAC3B,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,GAC3B,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,GAClC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,EAAE,GACtB,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE,CAAC;QAE1C,eAAe,IAAI,CAAC;QAEpB,OAAO;YAAC;YAAgB;SAAa;IACzC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 9706, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/polynomial/cpolynomial.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// CPolynomial is a Combined Polynomial of the type :\n// CPolynomial(X) := P_0(X^n) + XP_1(X^n) + ... + X^{n-1}P_{n-1}(X^n)\n// We can use this class to avoid the allocation of a big memory buffer\n// for the coefficients because in some cases a big number of the coefficients are zero\n\nimport {BigBuffer} from \"ffjavascript\";\nimport {log2} from \"../misc.js\";\nimport {Polynomial} from \"./polynomial.js\";\n\nexport class CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** (log2(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new Polynomial(new BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA,qDAAqD;AACrD,uEAAuE;AACvE,uEAAuE;AACvE,uFAAuF;AAEvF;AAAA;AACA;AACA;;;;AAEO,MAAM;IACT,YAAY,CAAC,EAAE,KAAK,EAAE,MAAM,CAAE;QAC1B,IAAI,CAAC,CAAC,GAAG;QACT,IAAI,CAAC,WAAW,GAAG,MAAM,GAAG,IAAI,CAAC;QACjC,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;QAClB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;QAClB,IAAI,CAAC,MAAM,GAAG;IAClB;IAEA,cAAc,QAAQ,EAAE,UAAU,EAAE;QAChC,IAAI,WAAW,IAAI,CAAC,CAAC,GAAG,GAAG;YACvB,MAAM,IAAI,MAAM;QACpB;QAEA,IAAI,CAAC,WAAW,CAAC,SAAS,GAAG;IACjC;IAEA,SAAS;QACL,IAAI,UAAU,IAAI,CAAC,WAAW,CAAC,GAAG,CAC9B,CAAC,YAAY,QAAU,eAAe,YAAY,IAAI,WAAW,MAAM,KAAK,IAAI,CAAC,CAAC,GAAG;QACzF,OAAO,KAAK,GAAG,IAAI;IACvB;IAEA,gBAAgB;QACZ,IAAI,UAAU,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA,aAAc,eAAe,YAAY,IAAI,WAAW,MAAM;QACjG,MAAM,YAAY,IAAI,CAAC,MAAM;QAC7B,MAAM,eAAe,KAAK,CAAC,IAAA,gJAAI,EAAC,YAAY,KAAK,CAAC;QAClD,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,EAAE;QAEtB,IAAI,aAAa,IAAI,0KAAU,CAAC,IAAI,uMAAS,CAAC,eAAe,MAAM,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;QAE1F,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAAK;YAChC,MAAM,OAAO,IAAI;YACjB,MAAM,QAAQ,OAAO,IAAI,CAAC,CAAC;YAE3B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,CAAC,EAAE,IAAK;gBAC7B,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE,KAAK,WAAW;oBACnC,IAAI,KAAK,OAAO,CAAC,EAAE,EAAE,WAAW,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,OAAO,MAAM,QAAQ,IAAI;gBAC3G;YACJ;QACJ;QAEA,OAAO;IACX;IAEA,MAAM,oBAAoB,IAAI,EAAE,IAAI,EAAE;QAClC,IAAI,aAAa,IAAI,CAAC,aAAa;QACnC,MAAM,IAAI,WAAW,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE;QACjD,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG;QAC/C,MAAM,KAAK,MAAM,IAAI,CAAC,EAAE,CAAC,mBAAmB,CAAC,WAAW,IAAI;QAC5D,IAAI,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,OAAO,IAAI,IAAI,CAAC,MAAM,EAAE;QAC/D,MAAM,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC;QACvB,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 9788, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk_setup.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {readR1csFd} from \"r1csfile\";\nimport * as utils from \"./powersoftau_utils.js\";\nimport {createBinFile, endWriteSection, readBinFile, startWriteSection, writeBigInt,} from \"@iden3/binfileutils\";\nimport {log2} from \"./misc.js\";\nimport {BigBuffer, Scalar} from \"ffjavascript\";\nimport BigArray from \"./bigarray.js\";\nimport {\n    ZKEY_FF_HEADER_SECTION,\n    ZKEY_FF_ADDITIONS_SECTION,\n    ZKEY_FF_A_MAP_SECTION,\n    ZKEY_FF_B_MAP_SECTION,\n    ZKEY_FF_C_MAP_SECTION,\n    ZKEY_FF_QL_SECTION,\n    ZKEY_FF_QR_SECTION,\n    ZKEY_FF_QM_SECTION,\n    ZKEY_FF_QO_SECTION,\n    ZKEY_FF_QC_SECTION,\n    ZKEY_FF_SIGMA1_SECTION,\n    ZKEY_FF_SIGMA2_SECTION,\n    ZKEY_FF_SIGMA3_SECTION,\n    ZKEY_FF_LAGRANGE_SECTION,\n    ZKEY_FF_PTAU_SECTION,\n    FF_T_POL_DEG_MIN,\n    ZKEY_FF_NSECTIONS,\n    ZKEY_FF_C0_SECTION,\n} from \"./fflonk_constants.js\";\nimport {FFLONK_PROTOCOL_ID, HEADER_ZKEY_SECTION} from \"./zkey_constants.js\";\nimport {\n    getFFlonkAdditionConstraint,\n    getFFlonkConstantConstraint,\n    getFFlonkMultiplicationConstraint\n} from \"./plonk_equation.js\";\nimport {r1csConstraintProcessor} from \"./r1cs_constraint_processor.js\";\nimport {Polynomial} from \"./polynomial/polynomial.js\";\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport {Evaluations} from \"./polynomial/evaluations.js\";\nimport {CPolynomial} from \"./polynomial/cpolynomial.js\";\n\n\nexport default async function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await readBinFile(ptauFilename, \"ptau\", 1, 1 << 22, 1 << 24);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await utils.readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new BigArray();\n    let plonkAdditions = new BigArray();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 we need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(FF_T_POL_DEG_MIN, log2((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push(getFFlonkConstantConstraint(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new r1csConstraintProcessor(Fr, getFFlonkConstantConstraint, getFFlonkAdditionConstraint, getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await binFileUtils.readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await createBinFile(zkeyFilename, \"zkey\", 1, ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await startWriteSection(fdZKey, HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(FFLONK_PROTOCOL_ID);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await startWriteSection(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new BigArray(settings.nVars);\n        const firstPos = new BigArray(settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? ZKEY_FF_SIGMA1_SECTION : 1 === i ? ZKEY_FF_SIGMA2_SECTION : ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await startWriteSection(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await endWriteSection(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await startWriteSection(fdZKey, ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await writeBigInt(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await writeBigInt(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = Scalar.div(orderRsub1, Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10256, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk_prove.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as binFileUtils from \"@iden3/binfileutils\";\nimport * as zkeyUtils from \"./zkey_utils.js\";\nimport * as wtnsUtils from \"./wtns_utils.js\";\nimport { BigBuffer, Scalar, utils } from \"ffjavascript\";\nimport { FFLONK_PROTOCOL_ID } from \"./zkey_constants.js\";\nimport {\n    ZKEY_FF_A_MAP_SECTION,\n    ZKEY_FF_ADDITIONS_SECTION,\n    ZKEY_FF_B_MAP_SECTION,\n    ZKEY_FF_C0_SECTION,\n    ZKEY_FF_C_MAP_SECTION,\n    ZKEY_FF_LAGRANGE_SECTION,\n    ZKEY_FF_PTAU_SECTION,\n    ZKEY_FF_QC_SECTION,\n    ZKEY_FF_QL_SECTION,\n    ZKEY_FF_QM_SECTION,\n    ZKEY_FF_QO_SECTION,\n    ZKEY_FF_QR_SECTION,\n    ZKEY_FF_SIGMA1_SECTION,\n    ZKEY_FF_SIGMA2_SECTION,\n    ZKEY_FF_SIGMA3_SECTION,\n} from \"./fflonk_constants.js\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { Proof } from \"./proof.js\";\nimport { Polynomial } from \"./polynomial/polynomial.js\";\nimport { Evaluations } from \"./polynomial/evaluations.js\";\nimport { CPolynomial } from \"./polynomial/cpolynomial.js\";\n\nconst { stringifyBigInts } = utils;\n\n\nexport default async function fflonkProve(zkeyFileName, witnessFileName, logger, options) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await binFileUtils.readBinFile(witnessFileName, \"wtns\", 2, 1 << 25, 1 << 23);\n    const wtns = await wtnsUtils.readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await binFileUtils.readBinFile(zkeyFileName, \"zkey\", 2, 1 << 25, 1 << 23);\n\n    const zkey = await zkeyUtils.readHeader(fdZKey, zkeySections, undefined, options);\n\n    if (zkey.protocolId !== FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await binFileUtils.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new BigBuffer(sDomain);\n            buffers.B = new BigBuffer(sDomain);\n            buffers.C = new BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${ZKEY_FF_QL_SECTION}, ${ZKEY_FF_QR_SECTION}` +\n                `, ${ZKEY_FF_QM_SECTION}, ${ZKEY_FF_QO_SECTION}, ${ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new Evaluations(new BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await binFileUtils.readSection(fdZKey, zkeySections, ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new BigBuffer(sDomain);\n            let denArr = new BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new BigBuffer(sDomain * 2);\n            buffers.T1z = new BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new BigBuffer(sDomain * 4);\n            buffers.T2z = new BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new Polynomial(new BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve);\n\n        computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve);\n\n        computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve);\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            if(Array.isArray(element)) {\n                for (const subElement of element) {\n                    mulAccumulator = Fr.mul(mulAccumulator, subElement);\n                }\n            } else {\n                mulAccumulator = Fr.mul(mulAccumulator, element);\n            }\n        }\n        return Fr.inv(mulAccumulator);\n\n        \n        function computeLiS0(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS0_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n            }\n        \n            return Li;\n        }\n\n        function computeLiS1(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS1_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n\n            }\n        \n            return Li;\n        }\n\n        function computeLiS2(toInverse, S2, S2p, value, xi, xiw, curve) {\n            const Fr = curve.Fr;\n        \n            const Li = [];\n        \n            const _3h2 = Fr.mul(Fr.e(3), S2[0]);\n            const xisubxiw = Fr.sub(xi, xiw);\n            let den1 = Fr.mul(_3h2, xisubxiw);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2[2 * i % 3];\n                const den3 = Fr.sub(value, S2[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1)]] = Fr.mul(den1,Fr.mul(den2, den3));\n                \n            }\n        \n            const _3h3 = Fr.mul(Fr.e(3), S2p[0]);\n            const xiwsubxi = Fr.sub(xiw, xi);\n            den1 = Fr.mul(_3h3, xiwsubxi);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2p[2 * i % 3];\n                const den3 = Fr.sub(value, S2p[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1 + 3)]] = Fr.mul(den1,Fr.mul(den2, den3));    \n            }\n        \n            return Li;\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11352, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk_full_prove.js"],"sourcesContent":["/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport fflonkProve from \"./fflonk_prove.js\";\nimport wtns_calculate from \"./wtns_calculate.js\";\nimport {utils} from \"ffjavascript\";\nconst {unstringifyBigInts} = utils;\n\nexport default async function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await wtns_calculate(input, wasmFilename, wtns, wtnsCalcOptions);\n\n    // Compute the proof\n    return await fflonkProve(zkeyFilename, wtns, logger, proverOptions);\n}"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;AAeA,GAEA;AACA;AACA;;;;AACA,MAAM,EAAC,kBAAkB,EAAC,GAAG,+JAAK;AAEnB,eAAe,gBAAgB,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,MAAM,EAAE,eAAe,EAAE,aAAa;IACpH,MAAM,QAAQ,mBAAmB;IAEjC,MAAM,OAAM;QAAC,MAAM;IAAK;IAExB,sBAAsB;IACtB,MAAM,IAAA,6JAAc,EAAC,OAAO,cAAc,MAAM;IAEhD,oBAAoB;IACpB,OAAO,MAAM,IAAA,2JAAW,EAAC,cAAc,MAAM,QAAQ;AACzD","ignoreList":[0]}},
    {"offset": {"line": 11392, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk_verify.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as curves from \"./curves.js\";\nimport { BigBuffer, utils } from \"ffjavascript\";\nimport { Proof } from \"./proof.js\";\nimport { Keccak256Transcript } from \"./Keccak256Transcript.js\";\nimport { Scalar } from \"ffjavascript\";\n\nconst { unstringifyBigInts } = utils;\n\nexport default async function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n\n    const curve = await curves.getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        if (logger) logger.error(\"Proof commitments are not valid\");\n        return false;\n    }\n\n    // STEP 2 - Validate that all evaluations  F\n    if (logger) logger.info(\"> Checking evaluations belong to F\");\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid.\");\n        return false;\n    }\n\n    // STEP 3 - Validate that w_i  F for i  [l]\n    if (logger) logger.info(\"> Checking public inputs belong to F\");\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return Scalar.geq(value, 0) && Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.evaluations.ql)\n        && checkEvaluationIsValid(curve, proof.evaluations.qr)\n        && checkEvaluationIsValid(curve, proof.evaluations.qm)\n        && checkEvaluationIsValid(curve, proof.evaluations.qo)\n        && checkEvaluationIsValid(curve, proof.evaluations.qc)\n        && checkEvaluationIsValid(curve, proof.evaluations.s1)\n        && checkEvaluationIsValid(curve, proof.evaluations.s2)\n        && checkEvaluationIsValid(curve, proof.evaluations.s3)\n        && checkEvaluationIsValid(curve, proof.evaluations.a)\n        && checkEvaluationIsValid(curve, proof.evaluations.b)\n        && checkEvaluationIsValid(curve, proof.evaluations.c)\n        && checkEvaluationIsValid(curve, proof.evaluations.z)\n        && checkEvaluationIsValid(curve, proof.evaluations.zw)\n        && checkEvaluationIsValid(curve, proof.evaluations.t1w)\n        && checkEvaluationIsValid(curve, proof.evaluations.t2w);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n    challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new BigBuffer(size * Fr.n8);\n    let denArr = new BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve);\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing r0(y)\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));\n\n        res = Fr.add(res, Fr.mul(c0, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve);\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 4; i++) {\n        let c1 = proof.evaluations.a;\n        c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n\n        res = Fr.add(res, Fr.mul(c1, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve);\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let res = Fr.zero;\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i]));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i + 3]));\n    }\n\n    return res;\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}\n\n\nexport function computeLagrangeLiSi(roots, x, xi, curve) {\n    const Fr = curve.Fr;\n    const len = roots.length;\n\n    const num = Fr.sub(Fr.exp(x, len), xi);\n    const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n\n    const Li = [];\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[((len - 1) * i) % len];\n        const den3 = Fr.sub(x, roots[i]);\n\n        Li[i] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));\n    }\n\n    return Li;\n}\n\nexport function computeLagrangeLiS2(roots, value, xi0, xi1, curve) {\n    const Fr = curve.Fr;\n\n    const Li = [];\n\n    const len = roots[0].length;\n    const n = len * roots.length;\n\n    const num1 = Fr.exp(value, n);\n    const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));\n    const num3 = Fr.mul(xi0, xi1);\n    const num = Fr.add(Fr.sub(num1, num2), num3);\n\n    let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[0][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[0][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i] = Fr.div(num, den);\n    }\n\n    den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[1][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[1][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i + len] = Fr.div(num, den);\n    }\n\n    return Li;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11869, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk_export_calldata.js"],"sourcesContent":["/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport {getCurveFromName} from \"./curves.js\";\nimport {utils} from \"ffjavascript\";\n\nconst {unstringifyBigInts} = utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `0x${nstr}`;\n    return nstr;\n}\n\nexport default async function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await getCurveFromName(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},` +\n    `${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},` +\n    `${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},` +\n    `${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},` +\n    `${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},` +\n    `${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},` +\n    `${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},` +\n    `${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},` +\n    `${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},` +\n    `${p256(proof.evaluations.inv)}],` +\n    `[${inputs}]`;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;;;AAEA,MAAM,EAAC,kBAAkB,EAAC,GAAG,+JAAK;AAElC,SAAS,MAAM,CAAC;IACZ,OAAO,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AACzC;AAEA,SAAS,KAAK,CAAC;IACX,IAAI,OAAO,EAAE,QAAQ,CAAC;IACtB,MAAO,KAAK,MAAM,GAAG,GAAI,OAAO,MAAM;IACtC,OAAO,CAAC,EAAE,EAAE,MAAM;IAClB,OAAO;AACX;AAEe,eAAe,qBAAqB,IAAI,EAAE,MAAM;IAC3D,MAAM,QAAQ,mBAAmB;IACjC,MAAM,MAAM,mBAAmB;IAE/B,MAAM,QAAQ,MAAM,IAAA,8JAAgB,EAAC,MAAM,KAAK;IAChD,MAAM,KAAK,MAAM,EAAE;IACnB,MAAM,KAAK,MAAM,EAAE;IAEnB,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;QACjC,IAAI,WAAW,IAAI,SAAS,SAAS;QACrC,SAAS,SAAS,KAAK,GAAG,CAAC,EAAE;IACjC;IAEA,OAAO,CAAC,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAC7E,GAAG,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GACpE,GAAG,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GACpE,GAAG,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GACpE,GAAG,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,CAAC,GAC5F,GAAG,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,CAAC,GAC5F,GAAG,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,GAC3F,GAAG,KAAK,MAAM,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,GACzF,GAAG,KAAK,MAAM,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,MAAM,WAAW,CAAC,GAAG,EAAE,CAAC,CAAC,GAC9F,GAAG,KAAK,MAAM,WAAW,CAAC,GAAG,EAAE,EAAE,CAAC,GAClC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;AACjB","ignoreList":[0]}},
    {"offset": {"line": 11921, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/src/fflonk.js"],"sourcesContent":["/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nexport { default as setup } from \"./fflonk_setup.js\";\nexport { default as prove } from \"./fflonk_prove.js\";\nexport { default as fullProve } from \"./fflonk_full_prove.js\";\nexport { default as verify } from \"./fflonk_verify.js\";\nexport { default as exportSolidityVerifier } from \"./fflonk_export_solidity_verifier.js\";\nexport { default as exportSolidityCallData } from \"./fflonk_export_calldata.js\";\n"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;AAiBA,GAEA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 11955, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/nisch/Desktop/Velocity-1/node_modules/snarkjs/main.js"],"sourcesContent":["export * as groth16 from \"./src/groth16.js\";\nexport * as powersOfTau from \"./src/powersoftau.js\";\nexport * as r1cs from \"./src/r1cs.js\";\nexport * as wtns from \"./src/wtns.js\";\nexport * as zKey from \"./src/zkey.js\";\nexport * as plonk from \"./src/plonk.js\";\nexport * as fflonk from \"./src/fflonk.js\";\nexport * as curves from \"./src/curves.js\";\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}}]
}